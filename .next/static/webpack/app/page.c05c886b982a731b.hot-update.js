"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/ema-crossover */ \"(app-pages-browser)/./src/services/strategies/ema-crossover.ts\");\n/* harmony import */ var _services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/services/strategies/sma-crossover */ \"(app-pages-browser)/./src/services/strategies/sma-crossover.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Function to detect signals from EMA data\n    const detectEMASignals = (data, fastEMA, slowEMA)=>{\n        const markers = [];\n        for(let i = 1; i < Math.min(data.length, fastEMA.length, slowEMA.length); i++){\n            const prevFast = fastEMA[i - 1];\n            const prevSlow = slowEMA[i - 1];\n            const currFast = fastEMA[i];\n            const currSlow = slowEMA[i];\n            // Debug crossover conditions\n            console.log(\"Checking crossover:\", {\n                time: new Date(data[i].time * 1000).toLocaleString(),\n                prevFast: prevFast === null || prevFast === void 0 ? void 0 : prevFast.toFixed(2),\n                prevSlow: prevSlow === null || prevSlow === void 0 ? void 0 : prevSlow.toFixed(2),\n                currFast: currFast === null || currFast === void 0 ? void 0 : currFast.toFixed(2),\n                currSlow: currSlow === null || currSlow === void 0 ? void 0 : currSlow.toFixed(2),\n                isBuy: prevFast <= prevSlow && currFast > currSlow,\n                isSell: prevFast >= prevSlow && currFast < currSlow\n            });\n            // Only add signals if we have valid EMA values\n            if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                // Buy signal: Fast EMA crosses above Slow EMA\n                if (prevFast <= prevSlow && currFast > currSlow) {\n                    markers.push({\n                        time: data[i].time,\n                        position: \"belowBar\",\n                        color: \"#26a69a\",\n                        shape: \"arrowUp\",\n                        text: \"BUY\\n$\".concat(data[i].close.toFixed(2)),\n                        size: 2\n                    });\n                    console.log(\"\\uD83D\\uDFE2 Buy Signal Detected:\", {\n                        price: data[i].close,\n                        time: new Date(data[i].time * 1000).toLocaleString(),\n                        fastEMA: currFast.toFixed(2),\n                        slowEMA: currSlow.toFixed(2),\n                        diff: (currFast - currSlow).toFixed(2)\n                    });\n                } else if (prevFast >= prevSlow && currFast < currSlow) {\n                    markers.push({\n                        time: data[i].time,\n                        position: \"aboveBar\",\n                        color: \"#ef5350\",\n                        shape: \"arrowDown\",\n                        text: \"SELL\\n$\".concat(data[i].close.toFixed(2)),\n                        size: 2\n                    });\n                    console.log(\"\\uD83D\\uDD34 Sell Signal Detected:\", {\n                        price: data[i].close,\n                        time: new Date(data[i].time * 1000).toLocaleString(),\n                        fastEMA: currFast.toFixed(2),\n                        slowEMA: currSlow.toFixed(2),\n                        diff: (currFast - currSlow).toFixed(2)\n                    });\n                }\n            }\n        }\n        return markers;\n    };\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = (data, chart)=>{\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            // Clear existing markers and indicators\n            safelyRemoveSeries(chart, markerSeriesRef.current);\n            markerSeriesRef.current = null;\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chart, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            if (strategy === \"none\") {\n                console.log(\"No strategy selected, clearing indicators\");\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!(selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.indicators)) {\n                console.log(\"No indicators found for strategy:\", strategy);\n                return;\n            }\n            console.log(\"Setting up strategy:\", selectedStrategy.id);\n            // Create marker series for signals\n            markerSeriesRef.current = candlestickSeriesRef.current; // Use the candlestick series for markers\n            // Run strategy analysis and update indicators\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                console.log(\"Calculating \".concat(selectedStrategy.id === \"ema_crossover\" ? \"EMAs\" : \"SMAs\", \" for crossover strategy\"));\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, fastPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, fastPeriod);\n                const slowLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, slowPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, slowPeriod);\n                // Add indicator lines\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    console.log(\"Adding indicator: \".concat(indicator.name));\n                    const colors = [\n                        \"#2962FF\",\n                        \"#FF6B6B\"\n                    ]; // Blue for fast, Red for slow\n                    const lineSeries = chart.addLineSeries({\n                        color: colors[index],\n                        lineWidth: 2,\n                        title: indicator.name,\n                        priceFormat: {\n                            type: \"price\",\n                            precision: 2,\n                            minMove: 0.01\n                        },\n                        lineStyle: 1\n                    });\n                    indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                    // Update indicator data with proper types\n                    const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                            time: data[idx].time,\n                            value: value\n                        }));\n                    lineSeries.setData(lineData);\n                });\n                // Get historical signals\n                const markers = [];\n                for(let i = 1; i < data.length; i++){\n                    const prevFast = fastLine[i - 1];\n                    const prevSlow = slowLine[i - 1];\n                    const currFast = fastLine[i];\n                    const currSlow = slowLine[i];\n                    if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                        if (prevFast <= prevSlow && currFast > currSlow) {\n                            // Buy signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"belowBar\",\n                                color: \"#26a69a\",\n                                shape: \"arrowUp\",\n                                text: \"BUY\",\n                                size: 2\n                            });\n                            console.log(\"Buy Signal at:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close,\n                                fastLine: currFast.toFixed(2),\n                                slowLine: currSlow.toFixed(2)\n                            });\n                        } else if (prevFast >= prevSlow && currFast < currSlow) {\n                            // Sell signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"aboveBar\",\n                                color: \"#ef5350\",\n                                shape: \"arrowDown\",\n                                text: \"SELL\",\n                                size: 2\n                            });\n                            console.log(\"Sell Signal at:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close,\n                                fastLine: currFast.toFixed(2),\n                                slowLine: currSlow.toFixed(2)\n                            });\n                        }\n                    }\n                }\n                if (markers.length > 0) {\n                    console.log(\"Setting markers:\", markers);\n                    markerSeriesRef.current.setMarkers(markers);\n                }\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current) {\n            // Clear existing indicators and markers\n            safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n            markerSeriesRef.current = null;\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chartRef.current, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            // Reinitialize strategy indicators\n            if (historicalDataRef.current.length > 0) {\n                console.log(\"Reinitializing strategy indicators with data length:\", historicalDataRef.current.length);\n                updateStrategyIndicators(historicalDataRef.current, chartRef.current);\n            }\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Update strategy indicators with initial data\n                updateStrategyIndicators(historicalData, chart);\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            newCandle\n                        ];\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                    // Update candlestick series with the new candle\n                    candlestickSeriesRef.current.update(currentCandle);\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                    // Update candlestick series with the current state\n                    candlestickSeriesRef.current.update(currentCandle);\n                }\n                // Update strategy indicators if we have a strategy selected\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy && selectedStrategy.id === \"ema_crossover\") {\n                        // Include the current candle in the calculations\n                        const updatedData = [\n                            ...historicalDataRef.current.slice(1),\n                            currentCandle\n                        ];\n                        const prices = updatedData.map((d)=>d.close);\n                        const fastPeriod = 9;\n                        const slowPeriod = 21;\n                        const fastEMA = (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, fastPeriod);\n                        const slowEMA = (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, slowPeriod);\n                        // Update the line series with new data\n                        indicatorSeriesRefs.current.forEach((series, name)=>{\n                            const emaData = (name === \"Fast EMA (9)\" ? fastEMA : slowEMA).map((value, index)=>({\n                                    time: updatedData[index].time,\n                                    value: value\n                                }));\n                            series.setData(emaData);\n                        });\n                        // Check for new signal\n                        const last = fastEMA.length - 1;\n                        const prev = last - 1;\n                        if (prev >= 0 && !isNaN(fastEMA[prev]) && !isNaN(slowEMA[prev]) && !isNaN(fastEMA[last]) && !isNaN(slowEMA[last])) {\n                            // Debug real-time crossover conditions\n                            const crossingUp = fastEMA[prev] <= slowEMA[prev] && fastEMA[last] > slowEMA[last];\n                            const crossingDown = fastEMA[prev] >= slowEMA[prev] && fastEMA[last] < slowEMA[last];\n                            if (crossingUp || crossingDown) {\n                                console.log(\"Real-time EMA Status:\", {\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    price: currentCandle.close,\n                                    prevFastEMA: fastEMA[prev].toFixed(2),\n                                    prevSlowEMA: slowEMA[prev].toFixed(2),\n                                    currFastEMA: fastEMA[last].toFixed(2),\n                                    currSlowEMA: slowEMA[last].toFixed(2),\n                                    signal: crossingUp ? \"BUY\" : \"SELL\"\n                                });\n                            }\n                            let newMarker = null;\n                            if (crossingUp) {\n                                // Buy signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"belowBar\",\n                                    color: \"#26a69a\",\n                                    shape: \"arrowUp\",\n                                    text: \"BUY\",\n                                    size: 2\n                                };\n                                console.log(\"\\uD83D\\uDFE2 Real-time Buy Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    fastEMA: fastEMA[last].toFixed(2),\n                                    slowEMA: slowEMA[last].toFixed(2),\n                                    diff: (fastEMA[last] - slowEMA[last]).toFixed(2)\n                                });\n                            } else if (crossingDown) {\n                                // Sell signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"aboveBar\",\n                                    color: \"#ef5350\",\n                                    shape: \"arrowDown\",\n                                    text: \"SELL\",\n                                    size: 2\n                                };\n                                console.log(\"\\uD83D\\uDD34 Real-time Sell Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    fastEMA: fastEMA[last].toFixed(2),\n                                    slowEMA: slowEMA[last].toFixed(2),\n                                    diff: (fastEMA[last] - slowEMA[last]).toFixed(2)\n                                });\n                            }\n                            // Add new marker if signal detected\n                            if (newMarker && candlestickSeriesRef.current) {\n                                const currentMarkers = candlestickSeriesRef.current.markers() || [];\n                                const signalExists = currentMarkers.some((m)=>m.time === newMarker.time && m.text === newMarker.text);\n                                if (!signalExists) {\n                                    candlestickSeriesRef.current.setMarkers([\n                                        ...currentMarkers,\n                                        newMarker\n                                    ]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 563,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"79wJC2kgSopMt/NxaIK+M+7bdVo=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRTBDO0FBQ087QUFDcUM7QUFFdEI7QUFDRztBQUNBO0FBTzVELFNBQVNRLGlCQUFpQixLQUE4QztRQUE5QyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBeUIsR0FBOUM7O0lBQy9CLE1BQU1DLG9CQUFvQlYsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1XLFdBQVdYLDZDQUFNQSxDQUFtQjtJQUMxQyxNQUFNWSx1QkFBdUJaLDZDQUFNQSxDQUFNO0lBQ3pDLE1BQU1hLHNCQUFzQmIsNkNBQU1BLENBQW1CLElBQUljO0lBQ3pELE1BQU1DLG9CQUFvQmYsNkNBQU1BLENBQVEsRUFBRTtJQUMxQyxNQUFNZ0Isa0JBQWtCaEIsNkNBQU1BLENBQU07SUFFcEMsMkNBQTJDO0lBQzNDLE1BQU1pQixtQkFBbUIsQ0FBQ0MsTUFBYUMsU0FBbUJDO1FBQ3hELE1BQU1DLFVBQWlCLEVBQUU7UUFDekIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLEtBQUtDLEdBQUcsQ0FBQ04sS0FBS08sTUFBTSxFQUFFTixRQUFRTSxNQUFNLEVBQUVMLFFBQVFLLE1BQU0sR0FBR0gsSUFBSztZQUM5RSxNQUFNSSxXQUFXUCxPQUFPLENBQUNHLElBQUksRUFBRTtZQUMvQixNQUFNSyxXQUFXUCxPQUFPLENBQUNFLElBQUksRUFBRTtZQUMvQixNQUFNTSxXQUFXVCxPQUFPLENBQUNHLEVBQUU7WUFDM0IsTUFBTU8sV0FBV1QsT0FBTyxDQUFDRSxFQUFFO1lBRTNCLDZCQUE2QjtZQUM3QlEsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QjtnQkFDakNDLE1BQU0sSUFBSUMsS0FBS2YsSUFBSSxDQUFDSSxFQUFFLENBQUNVLElBQUksR0FBRyxNQUFNRSxjQUFjO2dCQUNsRFIsUUFBUSxFQUFFQSxxQkFBQUEsK0JBQUFBLFNBQVVTLE9BQU8s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eEIscUJBQU8sOERBQUMwSztRQUFJQyxLQUFLMUs7UUFBbUIySyxXQUFVOzs7Ozs7QUFDaEQ7R0FwaUJnQjlLO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4PzhkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgVGltZSwgSUNoYXJ0QXBpLCBDaGFydE9wdGlvbnMsIERlZXBQYXJ0aWFsLCBMaW5lV2lkdGgsIEJ1c2luZXNzRGF5IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2hhcnQgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgZ2V0SGlzdG9yaWNhbERhdGEsIHN1YnNjcmliZVRvUHJpY2UgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFRpbWVmcmFtZSB9IGZyb20gJ0Avc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEknO1xuaW1wb3J0IHsgU3RyYXRlZ3lJZCwgZ2V0U3RyYXRlZ3kgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlRU1BIH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzL2VtYS1jcm9zc292ZXInO1xuaW1wb3J0IHsgY2FsY3VsYXRlU01BIH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzL3NtYS1jcm9zc292ZXInO1xuXG5pbnRlcmZhY2UgQ2FuZGxlc3RpY2tDaGFydFByb3BzIHtcbiAgdGltZWZyYW1lOiBUaW1lZnJhbWU7XG4gIHN0cmF0ZWd5OiBTdHJhdGVneUlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FuZGxlc3RpY2tDaGFydCh7IHRpbWVmcmFtZSwgc3RyYXRlZ3kgfTogQ2FuZGxlc3RpY2tDaGFydFByb3BzKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGluZGljYXRvclNlcmllc1JlZnMgPSB1c2VSZWY8TWFwPHN0cmluZywgYW55Pj4obmV3IE1hcCgpKTtcbiAgY29uc3QgaGlzdG9yaWNhbERhdGFSZWYgPSB1c2VSZWY8YW55W10+KFtdKTtcbiAgY29uc3QgbWFya2VyU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gZGV0ZWN0IHNpZ25hbHMgZnJvbSBFTUEgZGF0YVxuICBjb25zdCBkZXRlY3RFTUFTaWduYWxzID0gKGRhdGE6IGFueVtdLCBmYXN0RU1BOiBudW1iZXJbXSwgc2xvd0VNQTogbnVtYmVyW10pOiBhbnlbXSA9PiB7XG4gICAgY29uc3QgbWFya2VyczogYW55W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IE1hdGgubWluKGRhdGEubGVuZ3RoLCBmYXN0RU1BLmxlbmd0aCwgc2xvd0VNQS5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdEVNQVtpIC0gMV07XG4gICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dFTUFbaSAtIDFdO1xuICAgICAgY29uc3QgY3VyckZhc3QgPSBmYXN0RU1BW2ldO1xuICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93RU1BW2ldO1xuXG4gICAgICAvLyBEZWJ1ZyBjcm9zc292ZXIgY29uZGl0aW9uc1xuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGNyb3Nzb3ZlcjonLCB7XG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKGRhdGFbaV0udGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgIHByZXZGYXN0OiBwcmV2RmFzdD8udG9GaXhlZCgyKSxcbiAgICAgICAgcHJldlNsb3c6IHByZXZTbG93Py50b0ZpeGVkKDIpLFxuICAgICAgICBjdXJyRmFzdDogY3VyckZhc3Q/LnRvRml4ZWQoMiksXG4gICAgICAgIGN1cnJTbG93OiBjdXJyU2xvdz8udG9GaXhlZCgyKSxcbiAgICAgICAgaXNCdXk6IHByZXZGYXN0IDw9IHByZXZTbG93ICYmIGN1cnJGYXN0ID4gY3VyclNsb3csXG4gICAgICAgIGlzU2VsbDogcHJldkZhc3QgPj0gcHJldlNsb3cgJiYgY3VyckZhc3QgPCBjdXJyU2xvd1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9ubHkgYWRkIHNpZ25hbHMgaWYgd2UgaGF2ZSB2YWxpZCBFTUEgdmFsdWVzXG4gICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xuICAgICAgICAvLyBCdXkgc2lnbmFsOiBGYXN0IEVNQSBjcm9zc2VzIGFib3ZlIFNsb3cgRU1BXG4gICAgICAgIGlmIChwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93KSB7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYmVsb3dCYXInLFxuICAgICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dVcCcsXG4gICAgICAgICAgICB0ZXh0OiBgQlVZXFxuJCR7ZGF0YVtpXS5jbG9zZS50b0ZpeGVkKDIpfWAsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5+iIEJ1eSBTaWduYWwgRGV0ZWN0ZWQ6Jywge1xuICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgZmFzdEVNQTogY3VyckZhc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgIHNsb3dFTUE6IGN1cnJTbG93LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBkaWZmOiAoY3VyckZhc3QgLSBjdXJyU2xvdykudG9GaXhlZCgyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbGwgc2lnbmFsOiBGYXN0IEVNQSBjcm9zc2VzIGJlbG93IFNsb3cgRU1BXG4gICAgICAgIGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcbiAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXG4gICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgc2hhcGU6ICdhcnJvd0Rvd24nLFxuICAgICAgICAgICAgdGV4dDogYFNFTExcXG4kJHtkYXRhW2ldLmNsb3NlLnRvRml4ZWQoMil9YCxcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflLQgU2VsbCBTaWduYWwgRGV0ZWN0ZWQ6Jywge1xuICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgZmFzdEVNQTogY3VyckZhc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgIHNsb3dFTUE6IGN1cnJTbG93LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBkaWZmOiAoY3VyckZhc3QgLSBjdXJyU2xvdykudG9GaXhlZCgyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHNhZmVseSByZW1vdmUgYSBzZXJpZXNcbiAgY29uc3Qgc2FmZWx5UmVtb3ZlU2VyaWVzID0gKGNoYXJ0OiBJQ2hhcnRBcGksIHNlcmllczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzZXJpZXMgJiYgY2hhcnQpIHtcbiAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc2VyaWVzOicsIGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9yc1xuICBjb25zdCB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMgPSAoZGF0YTogYW55W10sIGNoYXJ0OiBJQ2hhcnRBcGkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFjaGFydCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0IG9yIGRhdGEgbm90IHJlYWR5LCBza2lwcGluZyB1cGRhdGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBleGlzdGluZyBtYXJrZXJzIGFuZCBpbmRpY2F0b3JzXG4gICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnQsIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0LCBzZXJpZXMpO1xuICAgICAgfSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbm9uZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIHN0cmF0ZWd5IHNlbGVjdGVkLCBjbGVhcmluZyBpbmRpY2F0b3JzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgIGlmICghc2VsZWN0ZWRTdHJhdGVneT8uaW5kaWNhdG9ycykge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gaW5kaWNhdG9ycyBmb3VuZCBmb3Igc3RyYXRlZ3k6Jywgc3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHVwIHN0cmF0ZWd5OicsIHNlbGVjdGVkU3RyYXRlZ3kuaWQpO1xuXG4gICAgICAvLyBDcmVhdGUgbWFya2VyIHNlcmllcyBmb3Igc2lnbmFsc1xuICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50OyAgLy8gVXNlIHRoZSBjYW5kbGVzdGljayBzZXJpZXMgZm9yIG1hcmtlcnNcblxuICAgICAgLy8gUnVuIHN0cmF0ZWd5IGFuYWx5c2lzIGFuZCB1cGRhdGUgaW5kaWNhdG9yc1xuICAgICAgY29uc3QgcHJpY2VzID0gZGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgIFxuICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyB8fCBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnc21hX2Nyb3Nzb3ZlcicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYENhbGN1bGF0aW5nICR7c2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInID8gJ0VNQXMnIDogJ1NNQXMnfSBmb3IgY3Jvc3NvdmVyIHN0cmF0ZWd5YCk7XG4gICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xuICAgICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XG4gICAgICAgIGNvbnN0IGZhc3RMaW5lID0gc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInIFxuICAgICAgICAgID8gY2FsY3VsYXRlRU1BKHByaWNlcywgZmFzdFBlcmlvZClcbiAgICAgICAgICA6IGNhbGN1bGF0ZVNNQShwcmljZXMsIGZhc3RQZXJpb2QpO1xuICAgICAgICBjb25zdCBzbG93TGluZSA9IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJ1xuICAgICAgICAgID8gY2FsY3VsYXRlRU1BKHByaWNlcywgc2xvd1BlcmlvZClcbiAgICAgICAgICA6IGNhbGN1bGF0ZVNNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xuXG4gICAgICAgIC8vIEFkZCBpbmRpY2F0b3IgbGluZXNcbiAgICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzLmZvckVhY2goKGluZGljYXRvciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGluZGljYXRvcjogJHtpbmRpY2F0b3IubmFtZX1gKTtcbiAgICAgICAgICBjb25zdCBjb2xvcnMgPSBbJyMyOTYyRkYnLCAnI0ZGNkI2QiddOyAvLyBCbHVlIGZvciBmYXN0LCBSZWQgZm9yIHNsb3dcbiAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgICBjb2xvcjogY29sb3JzW2luZGV4XSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICAgIHRpdGxlOiBpbmRpY2F0b3IubmFtZSxcbiAgICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgICAgICAgIHByZWNpc2lvbjogMixcbiAgICAgICAgICAgICAgbWluTW92ZTogMC4wMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lU3R5bGU6IDEsIC8vIFNvbGlkIGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KGluZGljYXRvci5uYW1lLCBsaW5lU2VyaWVzKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3IgZGF0YSB3aXRoIHByb3BlciB0eXBlc1xuICAgICAgICAgIGNvbnN0IGxpbmVEYXRhID0gKGluZGV4ID09PSAwID8gZmFzdExpbmUgOiBzbG93TGluZSkubWFwKCh2YWx1ZTogbnVtYmVyLCBpZHg6IG51bWJlcikgPT4gKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaWR4XS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGxpbmVTZXJpZXMuc2V0RGF0YShsaW5lRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdldCBoaXN0b3JpY2FsIHNpZ25hbHNcbiAgICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwcmV2RmFzdCA9IGZhc3RMaW5lW2kgLSAxXTtcbiAgICAgICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dMaW5lW2kgLSAxXTtcbiAgICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xuICAgICAgICAgIGNvbnN0IGN1cnJTbG93ID0gc2xvd0xpbmVbaV07XG5cbiAgICAgICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xuICAgICAgICAgICAgaWYgKHByZXZGYXN0IDw9IHByZXZTbG93ICYmIGN1cnJGYXN0ID4gY3VyclNsb3cpIHtcbiAgICAgICAgICAgICAgLy8gQnV5IHNpZ25hbFxuICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dVcCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ0JVWScsXG4gICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCdXkgU2lnbmFsIGF0OicsIHtcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHByaWNlOiBkYXRhW2ldLmNsb3NlLFxuICAgICAgICAgICAgICAgIGZhc3RMaW5lOiBjdXJyRmFzdC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgIHNsb3dMaW5lOiBjdXJyU2xvdy50b0ZpeGVkKDIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XG4gICAgICAgICAgICAgIC8vIFNlbGwgc2lnbmFsXG4gICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICAgICAgICAgICAgc2hhcGU6ICdhcnJvd0Rvd24nLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdTRUxMJyxcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NlbGwgU2lnbmFsIGF0OicsIHtcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHByaWNlOiBkYXRhW2ldLmNsb3NlLFxuICAgICAgICAgICAgICAgIGZhc3RMaW5lOiBjdXJyRmFzdC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgIHNsb3dMaW5lOiBjdXJyU2xvdy50b0ZpeGVkKDIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyBtYXJrZXJzOicsIG1hcmtlcnMpO1xuICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50LnNldE1hcmtlcnMobWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVTdHJhdGVneUluZGljYXRvcnM6JywgZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVwZGF0ZSB0aGUgc3RyYXRlZ3kgY2hhbmdlIGVmZmVjdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdTdHJhdGVneSBjaGFuZ2VkOicsIHN0cmF0ZWd5KTtcbiAgICBcbiAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgaW5kaWNhdG9ycyBhbmQgbWFya2Vyc1xuICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0UmVmLmN1cnJlbnQsIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0UmVmLmN1cnJlbnQhLCBzZXJpZXMpO1xuICAgICAgfSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgLy8gUmVpbml0aWFsaXplIHN0cmF0ZWd5IGluZGljYXRvcnNcbiAgICAgIGlmIChoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlaW5pdGlhbGl6aW5nIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBkYXRhIGxlbmd0aDonLCBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCk7XG4gICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjaGFydFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzdHJhdGVneV0pOyAvLyBPbmx5IHJ1biB3aGVuIHN0cmF0ZWd5IGNoYW5nZXNcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgY2hhcnQgd2l0aCB0aW1lZnJhbWU6JywgdGltZWZyYW1lKTtcblxuICAgIGNvbnN0IGZvcm1hdFRpbWUgPSAodGltZTogVGltZSkgPT4ge1xuICAgICAgbGV0IGRhdGU6IERhdGU7XG4gICAgICBcbiAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBCdXNpbmVzc0RheSBmb3JtYXRcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aW1lIGFzIEJ1c2luZXNzRGF5O1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcbiAgICAgICAgbW9udGg6ICdzaG9ydCcsXG4gICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgICAgICBob3VyMTI6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICAvLyBGb3IgZGFpbHkgdGltZWZyYW1lcywgZG9uJ3Qgc2hvdyB0aW1lXG4gICAgICBpZiAodGltZWZyYW1lID09PSAnMWQnKSB7XG4gICAgICAgIGRlbGV0ZSBmb3JtYXRPcHRpb25zLmhvdXI7XG4gICAgICAgIGRlbGV0ZSBmb3JtYXRPcHRpb25zLm1pbnV0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgZm9ybWF0T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNoYXJ0T3B0aW9uczogRGVlcFBhcnRpYWw8Q2hhcnRPcHRpb25zPiA9IHtcbiAgICAgIGxheW91dDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzFFMjIyRCcgfSxcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogJ1JvYm90bywgc2Fucy1zZXJpZicsXG4gICAgICB9LFxuICAgICAgZ3JpZDoge1xuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgICBob3J6TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgfSxcbiAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBtb2RlOiAxLFxuICAgICAgICB2ZXJ0TGluZToge1xuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxuICAgICAgICAgIHN0eWxlOiAzLFxuICAgICAgICB9LFxuICAgICAgICBob3J6TGluZToge1xuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxuICAgICAgICAgIHN0eWxlOiAzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRpbWVTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgc2Vjb25kc1Zpc2libGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgfSxcbiAgICAgIGxvY2FsaXphdGlvbjoge1xuICAgICAgICB0aW1lRm9ybWF0dGVyOiBmb3JtYXRUaW1lLFxuICAgICAgfSxcbiAgICAgIHdhdGVybWFyazoge1xuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xuICAgICAgLi4uY2hhcnRPcHRpb25zLFxuICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XG4gICAgICB1cENvbG9yOiAnIzI2YTY5YScsXG4gICAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxuICAgICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIHdpY2tEb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICB9KTtcblxuICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVzdGlja1NlcmllcztcblxuICAgIC8vIEZldGNoIGhpc3RvcmljYWwgZGF0YVxuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGlzdG9yaWNhbERhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWUpO1xuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVkIGhpc3RvcmljYWwgZGF0YTonLCBoaXN0b3JpY2FsRGF0YS5sZW5ndGgpO1xuICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gaGlzdG9yaWNhbERhdGE7XG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLnNldERhdGEoaGlzdG9yaWNhbERhdGEubWFwKGQgPT4gKHtcbiAgICAgICAgICB0aW1lOiBkLnRpbWUsXG4gICAgICAgICAgb3BlbjogZC5vcGVuLFxuICAgICAgICAgIGhpZ2g6IGQuaGlnaCxcbiAgICAgICAgICBsb3c6IGQubG93LFxuICAgICAgICAgIGNsb3NlOiBkLmNsb3NlXG4gICAgICAgIH0pKSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBpbml0aWFsIGRhdGFcbiAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhLCBjaGFydCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGhpc3RvcmljYWwgZGF0YTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxvYWREYXRhKCk7XG4gICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlYWwtdGltZSBwcmljZSB1cGRhdGVzIHdpdGggaW1wcm92ZWQgY2FuZGxlIGZvcm1hdGlvblxuICAgIGxldCBjdXJyZW50Q2FuZGxlID0ge1xuICAgICAgb3BlbjogMCxcbiAgICAgIGhpZ2g6IC1JbmZpbml0eSxcbiAgICAgIGxvdzogSW5maW5pdHksXG4gICAgICBjbG9zZTogMCxcbiAgICAgIHRpbWU6IDAsXG4gICAgfTtcblxuICAgIGNvbnN0IGdldEludGVydmFsU2Vjb25kcyA9ICh0ZjogVGltZWZyYW1lKTogbnVtYmVyID0+IHtcbiAgICAgIHN3aXRjaCAodGYpIHtcbiAgICAgICAgY2FzZSAnMW0nOiByZXR1cm4gNjA7XG4gICAgICAgIGNhc2UgJzVtJzogcmV0dXJuIDMwMDtcbiAgICAgICAgY2FzZSAnMTVtJzogcmV0dXJuIDkwMDtcbiAgICAgICAgY2FzZSAnMzBtJzogcmV0dXJuIDE4MDA7XG4gICAgICAgIGNhc2UgJzFoJzogcmV0dXJuIDM2MDA7XG4gICAgICAgIGNhc2UgJzRoJzogcmV0dXJuIDE0NDAwO1xuICAgICAgICBjYXNlICcxZCc6IHJldHVybiA4NjQwMDtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIDYwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZVRvUHJpY2UoKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsU2Vjb25kcyA9IGdldEludGVydmFsU2Vjb25kcyh0aW1lZnJhbWUpO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGNhbmRsZVRpbWVzdGFtcCA9IE1hdGguZmxvb3IoY3VycmVudFRpbWVzdGFtcCAvIGludGVydmFsU2Vjb25kcykgKiBpbnRlcnZhbFNlY29uZHM7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3IGNhbmRsZVxuICAgICAgICBpZiAoY2FuZGxlVGltZXN0YW1wICE9PSBjdXJyZW50Q2FuZGxlLnRpbWUpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBjYW5kbGUsIGZpbmFsaXplIGl0XG4gICAgICAgICAgaWYgKGN1cnJlbnRDYW5kbGUudGltZSAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FuZGxlID0ge1xuICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXG4gICAgICAgICAgICAgIG9wZW46IGN1cnJlbnRDYW5kbGUub3BlbixcbiAgICAgICAgICAgICAgaGlnaDogY3VycmVudENhbmRsZS5oaWdoLFxuICAgICAgICAgICAgICBsb3c6IGN1cnJlbnRDYW5kbGUubG93LFxuICAgICAgICAgICAgICBjbG9zZTogY3VycmVudENhbmRsZS5jbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShuZXdDYW5kbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgaGlzdG9yaWNhbCBkYXRhIHdpdGggdGhlIG5ldyBjYW5kbGVcbiAgICAgICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5zbGljZSgxKSwgbmV3Q2FuZGxlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgY2FuZGxlXG4gICAgICAgICAgY3VycmVudENhbmRsZSA9IHtcbiAgICAgICAgICAgIHRpbWU6IGNhbmRsZVRpbWVzdGFtcCxcbiAgICAgICAgICAgIG9wZW46IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBoaWdoOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBjYW5kbGVzdGljayBzZXJpZXMgd2l0aCB0aGUgbmV3IGNhbmRsZVxuICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYW5kbGVcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA+IGN1cnJlbnRDYW5kbGUuaGlnaCkgY3VycmVudENhbmRsZS5oaWdoID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA8IGN1cnJlbnRDYW5kbGUubG93KSBjdXJyZW50Q2FuZGxlLmxvdyA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgY3VycmVudENhbmRsZS5jbG9zZSA9IGRhdGEudmFsdWU7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzIGlmIHdlIGhhdmUgYSBzdHJhdGVneSBzZWxlY3RlZFxuICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJyAmJiBjaGFydFJlZi5jdXJyZW50ICYmIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zaXplID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkU3RyYXRlZ3kgPSBnZXRTdHJhdGVneShzdHJhdGVneSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kgJiYgc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInKSB7XG4gICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBjdXJyZW50IGNhbmRsZSBpbiB0aGUgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LnNsaWNlKDEpLCBjdXJyZW50Q2FuZGxlXTtcbiAgICAgICAgICAgIGNvbnN0IHByaWNlcyA9IHVwZGF0ZWREYXRhLm1hcChkID0+IGQuY2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgZmFzdFBlcmlvZCA9IDk7XG4gICAgICAgICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XG4gICAgICAgICAgICBjb25zdCBmYXN0RU1BID0gY2FsY3VsYXRlRU1BKHByaWNlcywgZmFzdFBlcmlvZCk7XG4gICAgICAgICAgICBjb25zdCBzbG93RU1BID0gY2FsY3VsYXRlRU1BKHByaWNlcywgc2xvd1BlcmlvZCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGluZSBzZXJpZXMgd2l0aCBuZXcgZGF0YVxuICAgICAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goKHNlcmllcywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBlbWFEYXRhID0gKG5hbWUgPT09ICdGYXN0IEVNQSAoOSknID8gZmFzdEVNQSA6IHNsb3dFTUEpLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIHRpbWU6IHVwZGF0ZWREYXRhW2luZGV4XS50aW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHNlcmllcy5zZXREYXRhKGVtYURhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXcgc2lnbmFsXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gZmFzdEVNQS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGxhc3QgLSAxO1xuICAgICAgICAgICAgaWYgKHByZXYgPj0gMCAmJiAhaXNOYU4oZmFzdEVNQVtwcmV2XSkgJiYgIWlzTmFOKHNsb3dFTUFbcHJldl0pICYmIFxuICAgICAgICAgICAgICAgICFpc05hTihmYXN0RU1BW2xhc3RdKSAmJiAhaXNOYU4oc2xvd0VNQVtsYXN0XSkpIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIERlYnVnIHJlYWwtdGltZSBjcm9zc292ZXIgY29uZGl0aW9uc1xuICAgICAgICAgICAgICBjb25zdCBjcm9zc2luZ1VwID0gZmFzdEVNQVtwcmV2XSA8PSBzbG93RU1BW3ByZXZdICYmIGZhc3RFTUFbbGFzdF0gPiBzbG93RU1BW2xhc3RdO1xuICAgICAgICAgICAgICBjb25zdCBjcm9zc2luZ0Rvd24gPSBmYXN0RU1BW3ByZXZdID49IHNsb3dFTUFbcHJldl0gJiYgZmFzdEVNQVtsYXN0XSA8IHNsb3dFTUFbbGFzdF07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoY3Jvc3NpbmdVcCB8fCBjcm9zc2luZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhbC10aW1lIEVNQSBTdGF0dXM6Jywge1xuICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoY3VycmVudENhbmRsZS50aW1lICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIHByaWNlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxuICAgICAgICAgICAgICAgICAgcHJldkZhc3RFTUE6IGZhc3RFTUFbcHJldl0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIHByZXZTbG93RU1BOiBzbG93RU1BW3ByZXZdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBjdXJyRmFzdEVNQTogZmFzdEVNQVtsYXN0XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgY3VyclNsb3dFTUE6IHNsb3dFTUFbbGFzdF0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIHNpZ25hbDogY3Jvc3NpbmdVcCA/ICdCVVknIDogJ1NFTEwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgbmV3TWFya2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGNyb3NzaW5nVXApIHtcbiAgICAgICAgICAgICAgICAvLyBCdXkgc2lnbmFsXG4gICAgICAgICAgICAgICAgbmV3TWFya2VyID0ge1xuICAgICAgICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdiZWxvd0JhcicsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgICAgICAgICAgICAgICAgc2hhcGU6ICdhcnJvd1VwJyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdCVVknLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5+iIFJlYWwtdGltZSBCdXkgU2lnbmFsOicsIHtcbiAgICAgICAgICAgICAgICAgIHByaWNlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxuICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoY3VycmVudENhbmRsZS50aW1lICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIGZhc3RFTUE6IGZhc3RFTUFbbGFzdF0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIHNsb3dFTUE6IHNsb3dFTUFbbGFzdF0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIGRpZmY6IChmYXN0RU1BW2xhc3RdIC0gc2xvd0VNQVtsYXN0XSkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzaW5nRG93bikge1xuICAgICAgICAgICAgICAgIC8vIFNlbGwgc2lnbmFsXG4gICAgICAgICAgICAgICAgbmV3TWFya2VyID0ge1xuICAgICAgICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgICAgICAgc2hhcGU6ICdhcnJvd0Rvd24nLFxuICAgICAgICAgICAgICAgICAgdGV4dDogJ1NFTEwnLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5S0IFJlYWwtdGltZSBTZWxsIFNpZ25hbDonLCB7XG4gICAgICAgICAgICAgICAgICBwcmljZTogY3VycmVudENhbmRsZS5jbG9zZSxcbiAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKGN1cnJlbnRDYW5kbGUudGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBmYXN0RU1BOiBmYXN0RU1BW2xhc3RdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBzbG93RU1BOiBzbG93RU1BW2xhc3RdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBkaWZmOiAoZmFzdEVNQVtsYXN0XSAtIHNsb3dFTUFbbGFzdF0pLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFkZCBuZXcgbWFya2VyIGlmIHNpZ25hbCBkZXRlY3RlZFxuICAgICAgICAgICAgICBpZiAobmV3TWFya2VyICYmIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya2VycyA9IGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQubWFya2VycygpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbEV4aXN0cyA9IGN1cnJlbnRNYXJrZXJzLnNvbWUoXG4gICAgICAgICAgICAgICAgICAobTogYW55KSA9PiBtLnRpbWUgPT09IG5ld01hcmtlci50aW1lICYmIG0udGV4dCA9PT0gbmV3TWFya2VyLnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghc2lnbmFsRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnNldE1hcmtlcnMoWy4uLmN1cnJlbnRNYXJrZXJzLCBuZXdNYXJrZXJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aW1lZnJhbWUpO1xuXG4gICAgLy8gUmVtb3ZlIFRyYWRpbmdWaWV3IGxvZ28gZWxlbWVudHMgaWYgdGhleSBleGlzdFxuICAgIGNvbnN0IHJlbW92ZVRyYWRpbmdWaWV3TG9nbyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ29FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3R2LWF0dHItbG9nbycpO1xuICAgICAgaWYgKGxvZ29FbGVtZW50KSB7XG4gICAgICAgIGxvZ29FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoZWFkZXJMb2dvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnR2LWhlYWRlcl9fbGluaycpO1xuICAgICAgaWYgKGhlYWRlckxvZ28pIHtcbiAgICAgICAgaGVhZGVyTG9nby5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUnVuIGxvZ28gcmVtb3ZhbCBhZnRlciBjaGFydCBpcyBjcmVhdGVkXG4gICAgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvKCk7XG4gICAgLy8gQWxzbyBydW4gYWZ0ZXIgYSBzaG9ydCBkZWxheSB0byBjYXRjaCBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xuICAgIGNvbnN0IGxvZ29UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlbW92ZVRyYWRpbmdWaWV3TG9nbywgMTAwKTtcblxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5hcHBseU9wdGlvbnMoe1xuICAgICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIGNsZWFyVGltZW91dChsb2dvVGltZW91dElkKTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt0aW1lZnJhbWUsIHN0cmF0ZWd5XSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiIC8+O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiY3JlYXRlQ2hhcnQiLCJnZXRIaXN0b3JpY2FsRGF0YSIsInN1YnNjcmliZVRvUHJpY2UiLCJnZXRTdHJhdGVneSIsImNhbGN1bGF0ZUVNQSIsImNhbGN1bGF0ZVNNQSIsIkNhbmRsZXN0aWNrQ2hhcnQiLCJ0aW1lZnJhbWUiLCJzdHJhdGVneSIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJoaXN0b3JpY2FsRGF0YVJlZiIsIm1hcmtlclNlcmllc1JlZiIsImRldGVjdEVNQVNpZ25hbHMiLCJkYXRhIiwiZmFzdEVNQSIsInNsb3dFTUEiLCJtYXJrZXJzIiwiaSIsIk1hdGgiLCJtaW4iLCJsZW5ndGgiLCJwcmV2RmFzdCIsInByZXZTbG93IiwiY3VyckZhc3QiLCJjdXJyU2xvdyIsImNvbnNvbGUiLCJsb2ciLCJ0aW1lIiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwidG9GaXhlZCIsImlzQnV5IiwiaXNTZWxsIiwiaXNOYU4iLCJwdXNoIiwicG9zaXRpb24iLCJjb2xvciIsInNoYXBlIiwidGV4dCIsImNsb3NlIiwic2l6ZSIsInByaWNlIiwiZGlmZiIsInNhZmVseVJlbW92ZVNlcmllcyIsImNoYXJ0Iiwic2VyaWVzIiwicmVtb3ZlU2VyaWVzIiwiZSIsImVycm9yIiwidXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzIiwiY3VycmVudCIsImZvckVhY2giLCJjbGVhciIsInNlbGVjdGVkU3RyYXRlZ3kiLCJpbmRpY2F0b3JzIiwiaWQiLCJwcmljZXMiLCJtYXAiLCJkIiwiZmFzdFBlcmlvZCIsInNsb3dQZXJpb2QiLCJmYXN0TGluZSIsInNsb3dMaW5lIiwiaW5kaWNhdG9yIiwiaW5kZXgiLCJuYW1lIiwiY29sb3JzIiwibGluZVNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJsaW5lV2lkdGgiLCJ0aXRsZSIsInByaWNlRm9ybWF0IiwidHlwZSIsInByZWNpc2lvbiIsIm1pbk1vdmUiLCJsaW5lU3R5bGUiLCJzZXQiLCJsaW5lRGF0YSIsInZhbHVlIiwiaWR4Iiwic2V0RGF0YSIsInNldE1hcmtlcnMiLCJmb3JtYXRUaW1lIiwiZGF0ZSIsInllYXIiLCJtb250aCIsImRheSIsImZvcm1hdE9wdGlvbnMiLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjcm9zc2hhaXIiLCJtb2RlIiwidmVydExpbmUiLCJ3aWR0aCIsInN0eWxlIiwiaG9yekxpbmUiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJyaWdodFByaWNlU2NhbGUiLCJsb2NhbGl6YXRpb24iLCJ0aW1lRm9ybWF0dGVyIiwid2F0ZXJtYXJrIiwidmlzaWJsZSIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY2FuZGxlc3RpY2tTZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsInVwQ29sb3IiLCJkb3duQ29sb3IiLCJib3JkZXJWaXNpYmxlIiwid2lja1VwQ29sb3IiLCJ3aWNrRG93bkNvbG9yIiwibG9hZERhdGEiLCJoaXN0b3JpY2FsRGF0YSIsIm9wZW4iLCJoaWdoIiwibG93IiwiY3VycmVudENhbmRsZSIsIkluZmluaXR5IiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJ1bnN1YnNjcmliZSIsImludGVydmFsU2Vjb25kcyIsImN1cnJlbnRUaW1lc3RhbXAiLCJmbG9vciIsIm5vdyIsImNhbmRsZVRpbWVzdGFtcCIsIm5ld0NhbmRsZSIsInVwZGF0ZSIsInNsaWNlIiwidXBkYXRlZERhdGEiLCJlbWFEYXRhIiwibGFzdCIsInByZXYiLCJjcm9zc2luZ1VwIiwiY3Jvc3NpbmdEb3duIiwicHJldkZhc3RFTUEiLCJwcmV2U2xvd0VNQSIsImN1cnJGYXN0RU1BIiwiY3VyclNsb3dFTUEiLCJzaWduYWwiLCJuZXdNYXJrZXIiLCJjdXJyZW50TWFya2VycyIsInNpZ25hbEV4aXN0cyIsInNvbWUiLCJtIiwicmVtb3ZlVHJhZGluZ1ZpZXdMb2dvIiwibG9nb0VsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicmVtb3ZlIiwiaGVhZGVyTG9nbyIsInF1ZXJ5U2VsZWN0b3IiLCJsb2dvVGltZW91dElkIiwic2V0VGltZW91dCIsImhhbmRsZVJlc2l6ZSIsImFwcGx5T3B0aW9ucyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/strategies/ema-crossover.ts":
/*!**************************************************!*\
  !*** ./src/services/strategies/ema-crossover.ts ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateEMA: function() { return /* binding */ calculateEMA; }\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n\nfunction calculateEMA(data, period) {\n    const ema = [];\n    const multiplier = 2 / (period + 1);\n    // First EMA uses SMA as initial value\n    let sum = 0;\n    for(let i = 0; i < period; i++){\n        sum += data[i];\n        ema.push(NaN); // Fill initial values with NaN\n    }\n    ema[period - 1] = sum / period;\n    // Calculate EMA for remaining values\n    for(let i = period; i < data.length; i++){\n        const currentValue = data[i];\n        const previousEMA = ema[i - 1];\n        const currentEMA = (currentValue - previousEMA) * multiplier + previousEMA;\n        ema.push(currentEMA);\n    }\n    return ema;\n}\n// Create the strategy object\nconst emaCrossoverStrategy = {\n    id: \"ema_crossover\",\n    name: \"EMA Crossover\",\n    description: \"Generates signals based on crossovers between fast and slow EMAs\",\n    analyze: (data)=>{\n        const prices = data.map((d)=>d.close);\n        const fastPeriod = 9; // Fast EMA period\n        const slowPeriod = 21; // Slow EMA period\n        const fastEMA = calculateEMA(prices, fastPeriod);\n        const slowEMA = calculateEMA(prices, slowPeriod);\n        // Need at least two points to compare crossover\n        if (fastEMA.length < 2 || slowEMA.length < 2) return null;\n        const last = fastEMA.length - 1;\n        const prev = last - 1;\n        // Check for crossover\n        const isCrossUp = fastEMA[prev] <= slowEMA[prev] && fastEMA[last] > slowEMA[last];\n        const isCrossDown = fastEMA[prev] >= slowEMA[prev] && fastEMA[last] < slowEMA[last];\n        if (isCrossUp) {\n            return {\n                type: \"buy\",\n                price: data[last].close,\n                time: data[last].time,\n                message: \"Buy Signal: Fast EMA (\".concat(fastEMA[last].toFixed(2), \") crossed above Slow EMA (\").concat(slowEMA[last].toFixed(2), \")\")\n            };\n        }\n        if (isCrossDown) {\n            return {\n                type: \"sell\",\n                price: data[last].close,\n                time: data[last].time,\n                message: \"Sell Signal: Fast EMA (\".concat(fastEMA[last].toFixed(2), \") crossed below Slow EMA (\").concat(slowEMA[last].toFixed(2), \")\")\n            };\n        }\n        return null;\n    },\n    indicators: [\n        {\n            name: \"Fast EMA (9)\",\n            data: []\n        },\n        {\n            name: \"Slow EMA (21)\",\n            data: []\n        }\n    ]\n};\n// Register the strategy\n(0,_index__WEBPACK_IMPORTED_MODULE_0__.registerStrategy)(emaCrossoverStrategy);\n// Export the strategy object\n/* harmony default export */ __webpack_exports__[\"default\"] = (emaCrossoverStrategy);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zdHJhdGVnaWVzL2VtYS1jcm9zc292ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDcUU7QUFFOUQsU0FBU0MsYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ3pELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsYUFBYSxJQUFLRixDQUFBQSxTQUFTO0lBRWpDLHNDQUFzQztJQUN0QyxJQUFJRyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JELE9BQU9KLElBQUksQ0FBQ0ssRUFBRTtRQUNkSCxJQUFJSSxJQUFJLENBQUNDLE1BQU0sK0JBQStCO0lBQ2hEO0lBQ0FMLEdBQUcsQ0FBQ0QsU0FBUyxFQUFFLEdBQUdHLE1BQU1IO0lBRXhCLHFDQUFxQztJQUNyQyxJQUFLLElBQUlJLElBQUlKLFFBQVFJLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztRQUN6QyxNQUFNSSxlQUFlVCxJQUFJLENBQUNLLEVBQUU7UUFDNUIsTUFBTUssY0FBY1IsR0FBRyxDQUFDRyxJQUFJLEVBQUU7UUFDOUIsTUFBTU0sYUFBYSxDQUFDRixlQUFlQyxXQUFVLElBQUtQLGFBQWFPO1FBQy9EUixJQUFJSSxJQUFJLENBQUNLO0lBQ1g7SUFFQSxPQUFPVDtBQUNUO0FBRUEsNkJBQTZCO0FBQzdCLE1BQU1VLHVCQUFpQztJQUNyQ0MsSUFBSTtJQUNKQyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsU0FBUyxDQUFDaEI7UUFDUixNQUFNaUIsU0FBU2pCLEtBQUtrQixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEtBQUs7UUFDcEMsTUFBTUMsYUFBYSxHQUFJLGtCQUFrQjtRQUN6QyxNQUFNQyxhQUFhLElBQUksa0JBQWtCO1FBRXpDLE1BQU1DLFVBQVV4QixhQUFha0IsUUFBUUk7UUFDckMsTUFBTUcsVUFBVXpCLGFBQWFrQixRQUFRSztRQUVyQyxnREFBZ0Q7UUFDaEQsSUFBSUMsUUFBUWYsTUFBTSxHQUFHLEtBQUtnQixRQUFRaEIsTUFBTSxHQUFHLEdBQUcsT0FBTztRQUVyRCxNQUFNaUIsT0FBT0YsUUFBUWYsTUFBTSxHQUFHO1FBQzlCLE1BQU1rQixPQUFPRCxPQUFPO1FBRXBCLHNCQUFzQjtRQUN0QixNQUFNRSxZQUFZSixPQUFPLENBQUNHLEtBQUssSUFBSUYsT0FBTyxDQUFDRSxLQUFLLElBQUlILE9BQU8sQ0FBQ0UsS0FBSyxHQUFHRCxPQUFPLENBQUNDLEtBQUs7UUFDakYsTUFBTUcsY0FBY0wsT0FBTyxDQUFDRyxLQUFLLElBQUlGLE9BQU8sQ0FBQ0UsS0FBSyxJQUFJSCxPQUFPLENBQUNFLEtBQUssR0FBR0QsT0FBTyxDQUFDQyxLQUFLO1FBRW5GLElBQUlFLFdBQVc7WUFDYixPQUFPO2dCQUNMRSxNQUFNO2dCQUNOQyxPQUFPOUIsSUFBSSxDQUFDeUIsS0FBSyxDQUFDTCxLQUFLO2dCQUN2QlcsTUFBTS9CLElBQUksQ0FBQ3lCLEtBQUssQ0FBQ00sSUFBSTtnQkFDckJDLFNBQVMseUJBQThFUixPQUFyREQsT0FBTyxDQUFDRSxLQUFLLENBQUNRLE9BQU8sQ0FBQyxJQUFHLDhCQUFxRCxPQUF6QlQsT0FBTyxDQUFDQyxLQUFLLENBQUNRLE9BQU8sQ0FBQyxJQUFHO1lBQ2xIO1FBQ0Y7UUFFQSxJQUFJTCxhQUFhO1lBQ2YsT0FBTztnQkFDTEMsTUFBTTtnQkFDTkMsT0FBTzlCLElBQUksQ0FBQ3lCLEtBQUssQ0FBQ0wsS0FBSztnQkFDdkJXLE1BQU0vQixJQUFJLENBQUN5QixLQUFLLENBQUNNLElBQUk7Z0JBQ3JCQyxTQUFTLDBCQUErRVIsT0FBckRELE9BQU8sQ0FBQ0UsS0FBSyxDQUFDUSxPQUFPLENBQUMsSUFBRyw4QkFBcUQsT0FBekJULE9BQU8sQ0FBQ0MsS0FBSyxDQUFDUSxPQUFPLENBQUMsSUFBRztZQUNuSDtRQUNGO1FBRUEsT0FBTztJQUNUO0lBQ0FDLFlBQVk7UUFDVjtZQUNFcEIsTUFBTTtZQUNOZCxNQUFNLEVBQUU7UUFDVjtRQUNBO1lBQ0VjLE1BQU07WUFDTmQsTUFBTSxFQUFFO1FBQ1Y7S0FDRDtBQUNIO0FBRUEsd0JBQXdCO0FBQ3hCRix3REFBZ0JBLENBQUNjO0FBRWpCLDZCQUE2QjtBQUM3QiwrREFBZUEsb0JBQW9CQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9zdHJhdGVnaWVzL2VtYS1jcm9zc292ZXIudHM/M2QzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW5kbGVzdGlja0RhdGEgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5pbXBvcnQgeyBTdHJhdGVneSwgU3RyYXRlZ3lTaWduYWwsIHJlZ2lzdGVyU3RyYXRlZ3kgfSBmcm9tICcuL2luZGV4JztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFTUEoZGF0YTogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gIGNvbnN0IGVtYTogbnVtYmVyW10gPSBbXTtcclxuICBjb25zdCBtdWx0aXBsaWVyID0gMiAvIChwZXJpb2QgKyAxKTtcclxuXHJcbiAgLy8gRmlyc3QgRU1BIHVzZXMgU01BIGFzIGluaXRpYWwgdmFsdWVcclxuICBsZXQgc3VtID0gMDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBlcmlvZDsgaSsrKSB7XHJcbiAgICBzdW0gKz0gZGF0YVtpXTtcclxuICAgIGVtYS5wdXNoKE5hTik7IC8vIEZpbGwgaW5pdGlhbCB2YWx1ZXMgd2l0aCBOYU5cclxuICB9XHJcbiAgZW1hW3BlcmlvZCAtIDFdID0gc3VtIC8gcGVyaW9kO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgRU1BIGZvciByZW1haW5pbmcgdmFsdWVzXHJcbiAgZm9yIChsZXQgaSA9IHBlcmlvZDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRhdGFbaV07XHJcbiAgICBjb25zdCBwcmV2aW91c0VNQSA9IGVtYVtpIC0gMV07XHJcbiAgICBjb25zdCBjdXJyZW50RU1BID0gKGN1cnJlbnRWYWx1ZSAtIHByZXZpb3VzRU1BKSAqIG11bHRpcGxpZXIgKyBwcmV2aW91c0VNQTtcclxuICAgIGVtYS5wdXNoKGN1cnJlbnRFTUEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVtYTtcclxufVxyXG5cclxuLy8gQ3JlYXRlIHRoZSBzdHJhdGVneSBvYmplY3RcclxuY29uc3QgZW1hQ3Jvc3NvdmVyU3RyYXRlZ3k6IFN0cmF0ZWd5ID0ge1xyXG4gIGlkOiAnZW1hX2Nyb3Nzb3ZlcicsXHJcbiAgbmFtZTogJ0VNQSBDcm9zc292ZXInLFxyXG4gIGRlc2NyaXB0aW9uOiAnR2VuZXJhdGVzIHNpZ25hbHMgYmFzZWQgb24gY3Jvc3NvdmVycyBiZXR3ZWVuIGZhc3QgYW5kIHNsb3cgRU1BcycsXHJcbiAgYW5hbHl6ZTogKGRhdGE6IENhbmRsZXN0aWNrRGF0YVtdKSA9PiB7XHJcbiAgICBjb25zdCBwcmljZXMgPSBkYXRhLm1hcChkID0+IGQuY2xvc2UpO1xyXG4gICAgY29uc3QgZmFzdFBlcmlvZCA9IDk7ICAvLyBGYXN0IEVNQSBwZXJpb2RcclxuICAgIGNvbnN0IHNsb3dQZXJpb2QgPSAyMTsgLy8gU2xvdyBFTUEgcGVyaW9kXHJcblxyXG4gICAgY29uc3QgZmFzdEVNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpO1xyXG4gICAgY29uc3Qgc2xvd0VNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xyXG5cclxuICAgIC8vIE5lZWQgYXQgbGVhc3QgdHdvIHBvaW50cyB0byBjb21wYXJlIGNyb3Nzb3ZlclxyXG4gICAgaWYgKGZhc3RFTUEubGVuZ3RoIDwgMiB8fCBzbG93RU1BLmxlbmd0aCA8IDIpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IGxhc3QgPSBmYXN0RU1BLmxlbmd0aCAtIDE7XHJcbiAgICBjb25zdCBwcmV2ID0gbGFzdCAtIDE7XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGNyb3Nzb3ZlclxyXG4gICAgY29uc3QgaXNDcm9zc1VwID0gZmFzdEVNQVtwcmV2XSA8PSBzbG93RU1BW3ByZXZdICYmIGZhc3RFTUFbbGFzdF0gPiBzbG93RU1BW2xhc3RdO1xyXG4gICAgY29uc3QgaXNDcm9zc0Rvd24gPSBmYXN0RU1BW3ByZXZdID49IHNsb3dFTUFbcHJldl0gJiYgZmFzdEVNQVtsYXN0XSA8IHNsb3dFTUFbbGFzdF07XHJcblxyXG4gICAgaWYgKGlzQ3Jvc3NVcCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdidXknLFxyXG4gICAgICAgIHByaWNlOiBkYXRhW2xhc3RdLmNsb3NlLFxyXG4gICAgICAgIHRpbWU6IGRhdGFbbGFzdF0udGltZSBhcyBudW1iZXIsXHJcbiAgICAgICAgbWVzc2FnZTogYEJ1eSBTaWduYWw6IEZhc3QgRU1BICgke2Zhc3RFTUFbbGFzdF0udG9GaXhlZCgyKX0pIGNyb3NzZWQgYWJvdmUgU2xvdyBFTUEgKCR7c2xvd0VNQVtsYXN0XS50b0ZpeGVkKDIpfSlgXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ3Jvc3NEb3duKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3NlbGwnLFxyXG4gICAgICAgIHByaWNlOiBkYXRhW2xhc3RdLmNsb3NlLFxyXG4gICAgICAgIHRpbWU6IGRhdGFbbGFzdF0udGltZSBhcyBudW1iZXIsXHJcbiAgICAgICAgbWVzc2FnZTogYFNlbGwgU2lnbmFsOiBGYXN0IEVNQSAoJHtmYXN0RU1BW2xhc3RdLnRvRml4ZWQoMil9KSBjcm9zc2VkIGJlbG93IFNsb3cgRU1BICgke3Nsb3dFTUFbbGFzdF0udG9GaXhlZCgyKX0pYFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcbiAgaW5kaWNhdG9yczogW1xyXG4gICAge1xyXG4gICAgICBuYW1lOiAnRmFzdCBFTUEgKDkpJyxcclxuICAgICAgZGF0YTogW10sIC8vIFdpbGwgYmUgcG9wdWxhdGVkIHdoZW4gc3RyYXRlZ3kgcnVuc1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1Nsb3cgRU1BICgyMSknLFxyXG4gICAgICBkYXRhOiBbXSwgLy8gV2lsbCBiZSBwb3B1bGF0ZWQgd2hlbiBzdHJhdGVneSBydW5zXHJcbiAgICB9LFxyXG4gIF0sXHJcbn07XHJcblxyXG4vLyBSZWdpc3RlciB0aGUgc3RyYXRlZ3lcclxucmVnaXN0ZXJTdHJhdGVneShlbWFDcm9zc292ZXJTdHJhdGVneSk7XHJcblxyXG4vLyBFeHBvcnQgdGhlIHN0cmF0ZWd5IG9iamVjdFxyXG5leHBvcnQgZGVmYXVsdCBlbWFDcm9zc292ZXJTdHJhdGVneTsgIl0sIm5hbWVzIjpbInJlZ2lzdGVyU3RyYXRlZ3kiLCJjYWxjdWxhdGVFTUEiLCJkYXRhIiwicGVyaW9kIiwiZW1hIiwibXVsdGlwbGllciIsInN1bSIsImkiLCJwdXNoIiwiTmFOIiwibGVuZ3RoIiwiY3VycmVudFZhbHVlIiwicHJldmlvdXNFTUEiLCJjdXJyZW50RU1BIiwiZW1hQ3Jvc3NvdmVyU3RyYXRlZ3kiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImFuYWx5emUiLCJwcmljZXMiLCJtYXAiLCJkIiwiY2xvc2UiLCJmYXN0UGVyaW9kIiwic2xvd1BlcmlvZCIsImZhc3RFTUEiLCJzbG93RU1BIiwibGFzdCIsInByZXYiLCJpc0Nyb3NzVXAiLCJpc0Nyb3NzRG93biIsInR5cGUiLCJwcmljZSIsInRpbWUiLCJtZXNzYWdlIiwidG9GaXhlZCIsImluZGljYXRvcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/strategies/ema-crossover.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/strategies/sma-crossover.ts":
/*!**************************************************!*\
  !*** ./src/services/strategies/sma-crossover.ts ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateSMA: function() { return /* binding */ calculateSMA; },\n/* harmony export */   smaCrossoverStrategy: function() { return /* binding */ smaCrossoverStrategy; }\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n\n// Calculate Simple Moving Average (SMA)\nfunction calculateSMA(data, period) {\n    const sma = [];\n    // Fill initial values with NaN until we have enough data\n    for(let i = 0; i < period - 1; i++){\n        sma.push(NaN);\n    }\n    // Calculate SMA for each point after the initial period\n    for(let i = period - 1; i < data.length; i++){\n        let sum = 0;\n        for(let j = 0; j < period; j++){\n            sum += data[i - j];\n        }\n        sma.push(sum / period);\n    }\n    return sma;\n}\n// Convert any time format to Unix timestamp\nfunction getUnixTime(time) {\n    if (typeof time === \"number\") {\n        return time;\n    }\n    if (typeof time === \"string\") {\n        return Math.floor(new Date(time).getTime() / 1000);\n    }\n    // Handle BusinessDay format\n    const { year, month, day } = time;\n    return Math.floor(new Date(year, month - 1, day).getTime() / 1000);\n}\nconst smaCrossoverStrategy = {\n    id: \"sma_crossover\",\n    name: \"SMA Crossover\",\n    description: \"Fast SMA (9) crossing Slow SMA (21)\",\n    indicators: [\n        {\n            name: \"Fast SMA (9)\",\n            data: []\n        },\n        {\n            name: \"Slow SMA (21)\",\n            data: []\n        }\n    ],\n    analyze: (data)=>{\n        const prices = data.map((d)=>d.close);\n        const fastSMA = calculateSMA(prices, 9);\n        const slowSMA = calculateSMA(prices, 21);\n        // Need at least two points to detect a crossover\n        if (fastSMA.length < 2) return null;\n        const last = fastSMA.length - 1;\n        const prev = last - 1;\n        // Check for crossovers\n        if (!isNaN(fastSMA[prev]) && !isNaN(slowSMA[prev]) && !isNaN(fastSMA[last]) && !isNaN(slowSMA[last])) {\n            // Buy signal: Fast SMA crosses above Slow SMA\n            if (fastSMA[prev] <= slowSMA[prev] && fastSMA[last] > slowSMA[last]) {\n                return {\n                    type: \"buy\",\n                    price: data[last].close,\n                    time: getUnixTime(data[last].time),\n                    message: \"Buy Signal: Fast SMA (\".concat(fastSMA[last].toFixed(2), \") crossed above Slow SMA (\").concat(slowSMA[last].toFixed(2), \")\")\n                };\n            }\n            // Sell signal: Fast SMA crosses below Slow SMA\n            if (fastSMA[prev] >= slowSMA[prev] && fastSMA[last] < slowSMA[last]) {\n                return {\n                    type: \"sell\",\n                    price: data[last].close,\n                    time: getUnixTime(data[last].time),\n                    message: \"Sell Signal: Fast SMA (\".concat(fastSMA[last].toFixed(2), \") crossed below Slow SMA (\").concat(slowSMA[last].toFixed(2), \")\")\n                };\n            }\n        }\n        return null;\n    }\n};\n// Register the strategy\n(0,_index__WEBPACK_IMPORTED_MODULE_0__.registerStrategy)(smaCrossoverStrategy);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zdHJhdGVnaWVzL3NtYS1jcm9zc292ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFFO0FBR3JFLHdDQUF3QztBQUNqQyxTQUFTQyxhQUFhQyxJQUFjLEVBQUVDLE1BQWM7SUFDekQsTUFBTUMsTUFBZ0IsRUFBRTtJQUV4Qix5REFBeUQ7SUFDekQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFNBQVMsR0FBR0UsSUFBSztRQUNuQ0QsSUFBSUUsSUFBSSxDQUFDQztJQUNYO0lBRUEsd0RBQXdEO0lBQ3hELElBQUssSUFBSUYsSUFBSUYsU0FBUyxHQUFHRSxJQUFJSCxLQUFLTSxNQUFNLEVBQUVILElBQUs7UUFDN0MsSUFBSUksTUFBTTtRQUNWLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxRQUFRTyxJQUFLO1lBQy9CRCxPQUFPUCxJQUFJLENBQUNHLElBQUlLLEVBQUU7UUFDcEI7UUFDQU4sSUFBSUUsSUFBSSxDQUFDRyxNQUFNTjtJQUNqQjtJQUVBLE9BQU9DO0FBQ1Q7QUFFQSw0Q0FBNEM7QUFDNUMsU0FBU08sWUFBWUMsSUFBVTtJQUM3QixJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxTQUFTLFVBQVU7UUFDNUIsT0FBT0MsS0FBS0MsS0FBSyxDQUFDLElBQUlDLEtBQUtILE1BQU1JLE9BQU8sS0FBSztJQUMvQztJQUNBLDRCQUE0QjtJQUM1QixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxHQUFHLEVBQUUsR0FBR1A7SUFDN0IsT0FBT0MsS0FBS0MsS0FBSyxDQUFDLElBQUlDLEtBQUtFLE1BQU1DLFFBQVEsR0FBR0MsS0FBS0gsT0FBTyxLQUFLO0FBQy9EO0FBRU8sTUFBTUksdUJBQWlDO0lBQzVDQyxJQUFJO0lBQ0pDLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxZQUFZO1FBQ1Y7WUFDRUYsTUFBTTtZQUNOcEIsTUFBTSxFQUFFO1FBQ1Y7UUFDQTtZQUNFb0IsTUFBTTtZQUNOcEIsTUFBTSxFQUFFO1FBQ1Y7S0FDRDtJQUNEdUIsU0FBUyxDQUFDdkI7UUFDUixNQUFNd0IsU0FBU3hCLEtBQUt5QixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEtBQUs7UUFDcEMsTUFBTUMsVUFBVTdCLGFBQWF5QixRQUFRO1FBQ3JDLE1BQU1LLFVBQVU5QixhQUFheUIsUUFBUTtRQUVyQyxpREFBaUQ7UUFDakQsSUFBSUksUUFBUXRCLE1BQU0sR0FBRyxHQUFHLE9BQU87UUFFL0IsTUFBTXdCLE9BQU9GLFFBQVF0QixNQUFNLEdBQUc7UUFDOUIsTUFBTXlCLE9BQU9ELE9BQU87UUFFcEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0UsTUFBTUosT0FBTyxDQUFDRyxLQUFLLEtBQUssQ0FBQ0MsTUFBTUgsT0FBTyxDQUFDRSxLQUFLLEtBQzdDLENBQUNDLE1BQU1KLE9BQU8sQ0FBQ0UsS0FBSyxLQUFLLENBQUNFLE1BQU1ILE9BQU8sQ0FBQ0MsS0FBSyxHQUFHO1lBRWxELDhDQUE4QztZQUM5QyxJQUFJRixPQUFPLENBQUNHLEtBQUssSUFBSUYsT0FBTyxDQUFDRSxLQUFLLElBQUlILE9BQU8sQ0FBQ0UsS0FBSyxHQUFHRCxPQUFPLENBQUNDLEtBQUssRUFBRTtnQkFDbkUsT0FBTztvQkFDTEcsTUFBTTtvQkFDTkMsT0FBT2xDLElBQUksQ0FBQzhCLEtBQUssQ0FBQ0gsS0FBSztvQkFDdkJqQixNQUFNRCxZQUFZVCxJQUFJLENBQUM4QixLQUFLLENBQUNwQixJQUFJO29CQUNqQ3lCLFNBQVMseUJBQThFTixPQUFyREQsT0FBTyxDQUFDRSxLQUFLLENBQUNNLE9BQU8sQ0FBQyxJQUFHLDhCQUFxRCxPQUF6QlAsT0FBTyxDQUFDQyxLQUFLLENBQUNNLE9BQU8sQ0FBQyxJQUFHO2dCQUNsSDtZQUNGO1lBRUEsK0NBQStDO1lBQy9DLElBQUlSLE9BQU8sQ0FBQ0csS0FBSyxJQUFJRixPQUFPLENBQUNFLEtBQUssSUFBSUgsT0FBTyxDQUFDRSxLQUFLLEdBQUdELE9BQU8sQ0FBQ0MsS0FBSyxFQUFFO2dCQUNuRSxPQUFPO29CQUNMRyxNQUFNO29CQUNOQyxPQUFPbEMsSUFBSSxDQUFDOEIsS0FBSyxDQUFDSCxLQUFLO29CQUN2QmpCLE1BQU1ELFlBQVlULElBQUksQ0FBQzhCLEtBQUssQ0FBQ3BCLElBQUk7b0JBQ2pDeUIsU0FBUywwQkFBK0VOLE9BQXJERCxPQUFPLENBQUNFLEtBQUssQ0FBQ00sT0FBTyxDQUFDLElBQUcsOEJBQXFELE9BQXpCUCxPQUFPLENBQUNDLEtBQUssQ0FBQ00sT0FBTyxDQUFDLElBQUc7Z0JBQ25IO1lBQ0Y7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFFRix3QkFBd0I7QUFDeEJ0Qyx3REFBZ0JBLENBQUNvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvc3RyYXRlZ2llcy9zbWEtY3Jvc3NvdmVyLnRzPzQ3YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RyYXRlZ3ksIFN0cmF0ZWd5U2lnbmFsLCByZWdpc3RlclN0cmF0ZWd5IH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBUaW1lLCBCdXNpbmVzc0RheSB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG5cbi8vIENhbGN1bGF0ZSBTaW1wbGUgTW92aW5nIEF2ZXJhZ2UgKFNNQSlcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTTUEoZGF0YTogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCBzbWE6IG51bWJlcltdID0gW107XG4gIFxuICAvLyBGaWxsIGluaXRpYWwgdmFsdWVzIHdpdGggTmFOIHVudGlsIHdlIGhhdmUgZW5vdWdoIGRhdGFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2QgLSAxOyBpKyspIHtcbiAgICBzbWEucHVzaChOYU4pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIFNNQSBmb3IgZWFjaCBwb2ludCBhZnRlciB0aGUgaW5pdGlhbCBwZXJpb2RcbiAgZm9yIChsZXQgaSA9IHBlcmlvZCAtIDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwZXJpb2Q7IGorKykge1xuICAgICAgc3VtICs9IGRhdGFbaSAtIGpdO1xuICAgIH1cbiAgICBzbWEucHVzaChzdW0gLyBwZXJpb2QpO1xuICB9XG5cbiAgcmV0dXJuIHNtYTtcbn1cblxuLy8gQ29udmVydCBhbnkgdGltZSBmb3JtYXQgdG8gVW5peCB0aW1lc3RhbXBcbmZ1bmN0aW9uIGdldFVuaXhUaW1lKHRpbWU6IFRpbWUpOiBudW1iZXIge1xuICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKHRpbWUpLmdldFRpbWUoKSAvIDEwMDApO1xuICB9XG4gIC8vIEhhbmRsZSBCdXNpbmVzc0RheSBmb3JtYXRcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aW1lIGFzIEJ1c2luZXNzRGF5O1xuICByZXR1cm4gTWF0aC5mbG9vcihuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkuZ2V0VGltZSgpIC8gMTAwMCk7XG59XG5cbmV4cG9ydCBjb25zdCBzbWFDcm9zc292ZXJTdHJhdGVneTogU3RyYXRlZ3kgPSB7XG4gIGlkOiAnc21hX2Nyb3Nzb3ZlcicsXG4gIG5hbWU6ICdTTUEgQ3Jvc3NvdmVyJyxcbiAgZGVzY3JpcHRpb246ICdGYXN0IFNNQSAoOSkgY3Jvc3NpbmcgU2xvdyBTTUEgKDIxKScsXG4gIGluZGljYXRvcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnRmFzdCBTTUEgKDkpJyxcbiAgICAgIGRhdGE6IFtdXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnU2xvdyBTTUEgKDIxKScsXG4gICAgICBkYXRhOiBbXVxuICAgIH1cbiAgXSxcbiAgYW5hbHl6ZTogKGRhdGEpID0+IHtcbiAgICBjb25zdCBwcmljZXMgPSBkYXRhLm1hcChkID0+IGQuY2xvc2UpO1xuICAgIGNvbnN0IGZhc3RTTUEgPSBjYWxjdWxhdGVTTUEocHJpY2VzLCA5KTtcbiAgICBjb25zdCBzbG93U01BID0gY2FsY3VsYXRlU01BKHByaWNlcywgMjEpO1xuXG4gICAgLy8gTmVlZCBhdCBsZWFzdCB0d28gcG9pbnRzIHRvIGRldGVjdCBhIGNyb3Nzb3ZlclxuICAgIGlmIChmYXN0U01BLmxlbmd0aCA8IDIpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbGFzdCA9IGZhc3RTTUEubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBwcmV2ID0gbGFzdCAtIDE7XG5cbiAgICAvLyBDaGVjayBmb3IgY3Jvc3NvdmVyc1xuICAgIGlmICghaXNOYU4oZmFzdFNNQVtwcmV2XSkgJiYgIWlzTmFOKHNsb3dTTUFbcHJldl0pICYmIFxuICAgICAgICAhaXNOYU4oZmFzdFNNQVtsYXN0XSkgJiYgIWlzTmFOKHNsb3dTTUFbbGFzdF0pKSB7XG4gICAgICBcbiAgICAgIC8vIEJ1eSBzaWduYWw6IEZhc3QgU01BIGNyb3NzZXMgYWJvdmUgU2xvdyBTTUFcbiAgICAgIGlmIChmYXN0U01BW3ByZXZdIDw9IHNsb3dTTUFbcHJldl0gJiYgZmFzdFNNQVtsYXN0XSA+IHNsb3dTTUFbbGFzdF0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnYnV5JyxcbiAgICAgICAgICBwcmljZTogZGF0YVtsYXN0XS5jbG9zZSxcbiAgICAgICAgICB0aW1lOiBnZXRVbml4VGltZShkYXRhW2xhc3RdLnRpbWUpLFxuICAgICAgICAgIG1lc3NhZ2U6IGBCdXkgU2lnbmFsOiBGYXN0IFNNQSAoJHtmYXN0U01BW2xhc3RdLnRvRml4ZWQoMil9KSBjcm9zc2VkIGFib3ZlIFNsb3cgU01BICgke3Nsb3dTTUFbbGFzdF0udG9GaXhlZCgyKX0pYFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZWxsIHNpZ25hbDogRmFzdCBTTUEgY3Jvc3NlcyBiZWxvdyBTbG93IFNNQVxuICAgICAgaWYgKGZhc3RTTUFbcHJldl0gPj0gc2xvd1NNQVtwcmV2XSAmJiBmYXN0U01BW2xhc3RdIDwgc2xvd1NNQVtsYXN0XSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdzZWxsJyxcbiAgICAgICAgICBwcmljZTogZGF0YVtsYXN0XS5jbG9zZSxcbiAgICAgICAgICB0aW1lOiBnZXRVbml4VGltZShkYXRhW2xhc3RdLnRpbWUpLFxuICAgICAgICAgIG1lc3NhZ2U6IGBTZWxsIFNpZ25hbDogRmFzdCBTTUEgKCR7ZmFzdFNNQVtsYXN0XS50b0ZpeGVkKDIpfSkgY3Jvc3NlZCBiZWxvdyBTbG93IFNNQSAoJHtzbG93U01BW2xhc3RdLnRvRml4ZWQoMil9KWBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gUmVnaXN0ZXIgdGhlIHN0cmF0ZWd5XG5yZWdpc3RlclN0cmF0ZWd5KHNtYUNyb3Nzb3ZlclN0cmF0ZWd5KTsgIl0sIm5hbWVzIjpbInJlZ2lzdGVyU3RyYXRlZ3kiLCJjYWxjdWxhdGVTTUEiLCJkYXRhIiwicGVyaW9kIiwic21hIiwiaSIsInB1c2giLCJOYU4iLCJsZW5ndGgiLCJzdW0iLCJqIiwiZ2V0VW5peFRpbWUiLCJ0aW1lIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsImdldFRpbWUiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJzbWFDcm9zc292ZXJTdHJhdGVneSIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiaW5kaWNhdG9ycyIsImFuYWx5emUiLCJwcmljZXMiLCJtYXAiLCJkIiwiY2xvc2UiLCJmYXN0U01BIiwic2xvd1NNQSIsImxhc3QiLCJwcmV2IiwiaXNOYU4iLCJ0eXBlIiwicHJpY2UiLCJtZXNzYWdlIiwidG9GaXhlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/strategies/sma-crossover.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\"\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        // Fetch and set historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 99,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"2rN9armGVJ1f+QeW0pB7tlSVqXQ=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQzBDO0FBQzZCO0FBQ0g7QUFNN0QsU0FBU0ksaUJBQWlCLEtBQW9DO1FBQXBDLEVBQUVDLFNBQVMsRUFBeUIsR0FBcEM7O0lBQy9CLE1BQU1DLG9CQUFvQkwsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1NLFdBQVdOLDZDQUFNQSxDQUFtQjtJQUUxQ0QsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNNLGtCQUFrQkUsT0FBTyxFQUFFO1FBRWhDLE1BQU1DLGVBQWU7WUFDbkJDLFFBQVE7Z0JBQ05DLFlBQVk7b0JBQUVDLE9BQU87Z0JBQVU7Z0JBQy9CQyxXQUFXO1lBQ2I7WUFDQUMsTUFBTTtnQkFDSkMsV0FBVztvQkFBRUgsT0FBTztnQkFBVTtnQkFDOUJJLFdBQVc7b0JBQUVKLE9BQU87Z0JBQVU7WUFDaEM7WUFDQUssV0FBVztnQkFDVEMsTUFBTTtnQkFDTkMsVUFBVTtvQkFDUkMsT0FBTztvQkFDUFIsT0FBTztvQkFDUFMsT0FBTztnQkFDVDtnQkFDQUMsVUFBVTtvQkFDUkYsT0FBTztvQkFDUFIsT0FBTztvQkFDUFMsT0FBTztnQkFDVDtZQUNGO1lBQ0FFLFdBQVc7Z0JBQ1RDLGFBQWE7WUFDZjtZQUNBQyxpQkFBaUI7Z0JBQ2ZELGFBQWE7WUFDZjtRQUNGO1FBRUEsTUFBTUUsUUFBUXhCLCtEQUFXQSxDQUFDSSxrQkFBa0JFLE9BQU8sRUFBRTtZQUNuRCxHQUFHQyxZQUFZO1lBQ2ZXLE9BQU9kLGtCQUFrQkUsT0FBTyxDQUFDbUIsV0FBVztZQUM1Q0MsUUFBUXRCLGtCQUFrQkUsT0FBTyxDQUFDcUIsWUFBWTtRQUNoRDtRQUVBLE1BQU1DLG9CQUFvQkosTUFBTUssb0JBQW9CLENBQUM7WUFDbkRDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxlQUFlO1lBQ2ZDLGFBQWE7WUFDYkMsZUFBZTtRQUNqQjtRQUVBLGdDQUFnQztRQUNoQyxNQUFNQyxXQUFXO1lBQ2YsSUFBSTtnQkFDRixNQUFNQyxpQkFBaUIsTUFBTW5DLGlGQUFpQkEsQ0FBQ0U7Z0JBQy9DeUIsa0JBQWtCUyxPQUFPLENBQUNELGVBQWVFLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBTTt3QkFDakRDLE1BQU1ELEVBQUVDLElBQUk7d0JBQ1pDLE1BQU1GLEVBQUVFLElBQUk7d0JBQ1pDLE1BQU1ILEVBQUVHLElBQUk7d0JBQ1pDLEtBQUtKLEVBQUVJLEdBQUc7d0JBQ1ZDLE9BQU9MLEVBQUVLLEtBQUs7b0JBQ2hCO1lBQ0YsRUFBRSxPQUFPQyxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtZQUNsRDtRQUNGO1FBRUFWO1FBQ0E5QixTQUFTQyxPQUFPLEdBQUdrQjtRQUVuQixNQUFNdUIsZUFBZTtZQUNuQixJQUFJM0Msa0JBQWtCRSxPQUFPLElBQUlELFNBQVNDLE9BQU8sRUFBRTtnQkFDakRELFNBQVNDLE9BQU8sQ0FBQzBDLFlBQVksQ0FBQztvQkFDNUI5QixPQUFPZCxrQkFBa0JFLE9BQU8sQ0FBQ21CLFdBQVc7b0JBQzVDQyxRQUFRdEIsa0JBQWtCRSxPQUFPLENBQUNxQixZQUFZO2dCQUNoRDtZQUNGO1FBQ0Y7UUFFQXNCLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVIO1FBRWxDLE9BQU87WUFDTEUsT0FBT0UsbUJBQW1CLENBQUMsVUFBVUo7WUFDckMsSUFBSTFDLFNBQVNDLE9BQU8sRUFBRTtnQkFDcEJELFNBQVNDLE9BQU8sQ0FBQzhDLE1BQU07WUFDekI7UUFDRjtJQUNGLEdBQUc7UUFBQ2pEO0tBQVU7SUFFZCxxQkFBTyw4REFBQ2tEO1FBQUlDLEtBQUtsRDtRQUFtQm1ELFdBQVU7Ozs7OztBQUNoRDtHQTFGZ0JyRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0LCBDb2xvclR5cGUsIElDaGFydEFwaSB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XHJcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhIH0gZnJvbSAnQC9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhbmRsZXN0aWNrQ2hhcnRQcm9wcyB7XHJcbiAgdGltZWZyYW1lOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgdGltZWZyYW1lIH06IENhbmRsZXN0aWNrQ2hhcnRQcm9wcykge1xyXG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0T3B0aW9ucyA9IHtcclxuICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogeyBjb2xvcjogJyMxRTIyMkQnIH0sXHJcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIGdyaWQ6IHtcclxuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxyXG4gICAgICAgIGhvcnpMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGNyb3NzaGFpcjoge1xyXG4gICAgICAgIG1vZGU6IDEsXHJcbiAgICAgICAgdmVydExpbmU6IHtcclxuICAgICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcclxuICAgICAgICAgIHN0eWxlOiAzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9yekxpbmU6IHtcclxuICAgICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcclxuICAgICAgICAgIHN0eWxlOiAzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVTY2FsZToge1xyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXHJcbiAgICAgIH0sXHJcbiAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xyXG4gICAgICAuLi5jaGFydE9wdGlvbnMsXHJcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XHJcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcclxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxyXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxyXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBGZXRjaCBhbmQgc2V0IGhpc3RvcmljYWwgZGF0YVxyXG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgaGlzdG9yaWNhbERhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWUpO1xyXG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLnNldERhdGEoaGlzdG9yaWNhbERhdGEubWFwKGQgPT4gKHtcclxuICAgICAgICAgIHRpbWU6IGQudGltZSxcclxuICAgICAgICAgIG9wZW46IGQub3BlbixcclxuICAgICAgICAgIGhpZ2g6IGQuaGlnaCxcclxuICAgICAgICAgIGxvdzogZC5sb3csXHJcbiAgICAgICAgICBjbG9zZTogZC5jbG9zZVxyXG4gICAgICAgIH0pKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWREYXRhKCk7XHJcbiAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICBpZiAoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5hcHBseU9wdGlvbnMoe1xyXG4gICAgICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW3RpbWVmcmFtZV0pO1xyXG5cclxuICByZXR1cm4gPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgLz47XHJcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiY3JlYXRlQ2hhcnQiLCJnZXRIaXN0b3JpY2FsRGF0YSIsIkNhbmRsZXN0aWNrQ2hhcnQiLCJ0aW1lZnJhbWUiLCJjaGFydENvbnRhaW5lclJlZiIsImNoYXJ0UmVmIiwiY3VycmVudCIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRDb2xvciIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjcm9zc2hhaXIiLCJtb2RlIiwidmVydExpbmUiLCJ3aWR0aCIsInN0eWxlIiwiaG9yekxpbmUiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInJpZ2h0UHJpY2VTY2FsZSIsImNoYXJ0IiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJsb2FkRGF0YSIsImhpc3RvcmljYWxEYXRhIiwic2V0RGF0YSIsIm1hcCIsImQiLCJ0aW1lIiwib3BlbiIsImhpZ2giLCJsb3ciLCJjbG9zZSIsImVycm9yIiwiY29uc29sZSIsImhhbmRsZVJlc2l6ZSIsImFwcGx5T3B0aW9ucyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlIiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts":
/*!**********************************************!*\
  !*** ./src/services/api/cryptoCompareAPI.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentPrice: function() { return /* binding */ getCurrentPrice; },\n/* harmony export */   getHistoricalData: function() { return /* binding */ getHistoricalData; },\n/* harmony export */   subscribeToPrice: function() { return /* binding */ subscribeToPrice; },\n/* harmony export */   subscribeToTrades: function() { return /* binding */ subscribeToTrades; }\n/* harmony export */ });\nconst TIMEFRAME_CONFIG = {\n    \"1m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 60\n    },\n    \"5m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 300\n    },\n    \"15m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 900\n    },\n    \"30m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 1800\n    },\n    \"1h\": {\n        endpoint: \"histohour\",\n        limit: 720,\n        interval: 3600\n    },\n    \"4h\": {\n        endpoint: \"histohour\",\n        limit: 720,\n        interval: 14400\n    },\n    \"1d\": {\n        endpoint: \"histoday\",\n        limit: 365,\n        interval: 86400\n    },\n    \"1w\": {\n        endpoint: \"histoday\",\n        limit: 365,\n        interval: 604800\n    }\n};\nlet socket = null;\nlet priceUpdateCallbacks = [];\nlet tradeUpdateCallbacks = [];\nlet pendingSubscription = false;\nlet lastPrice = 0;\nlet reconnectAttempts = 0;\nlet currentTimeframe = \"1m\";\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 2000;\n// Fallback to REST API when WebSocket fails\nasync function fetchPriceUpdate() {\n    try {\n        const response = await fetch(\"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\");\n        const data = await response.json();\n        const price = data.USD;\n        const timestamp = Math.floor(Date.now() / 1000);\n        if (price && !isNaN(price) && price !== lastPrice) {\n            lastPrice = price;\n            priceUpdateCallbacks.forEach((callback)=>callback({\n                    time: timestamp,\n                    value: price\n                }));\n        }\n    } catch (error) {\n        console.error(\"Error fetching price via REST:\", error);\n    }\n}\nfunction sendSubscription(ws) {\n    const subscribeMsg = {\n        \"action\": \"SubAdd\",\n        \"subs\": [\n            \"5~CCCAGG~BTC~USD\",\n            \"2~Coinbase~BTC~USD\",\n            \"11~BTC~USD\" // Direct price feed\n        ]\n    };\n    try {\n        ws.send(JSON.stringify(subscribeMsg));\n        console.log(\"Subscribed to price feeds\");\n        pendingSubscription = false;\n    } catch (error) {\n        console.error(\"Error sending subscription:\", error);\n        pendingSubscription = true;\n    }\n}\n// Update the WebSocket message handler to respect timeframes\nfunction handlePriceUpdate(price, timestamp, timeframe) {\n    const config = TIMEFRAME_CONFIG[timeframe];\n    const interval = config.interval;\n    // Align timestamp to the current timeframe interval\n    const alignedTimestamp = Math.floor(timestamp / interval) * interval;\n    if (price && !isNaN(price) && price !== lastPrice) {\n        lastPrice = price;\n        priceUpdateCallbacks.forEach((callback)=>callback({\n                time: alignedTimestamp,\n                value: price\n            }));\n        if (tradeUpdateCallbacks.length > 0) {\n            tradeUpdateCallbacks.forEach((callback)=>callback({\n                    time: alignedTimestamp,\n                    price: price,\n                    volume24h: 0 // Volume will be updated separately\n                }));\n        }\n    }\n}\nfunction connectWebSocket() {\n    if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n        if (pendingSubscription) {\n            sendSubscription(socket);\n        }\n        return;\n    }\n    // Don't try to reconnect too many times\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n        console.log(\"Max reconnection attempts reached, falling back to REST API\");\n        // Set up periodic REST API polling as fallback\n        const pollInterval = setInterval(fetchPriceUpdate, 5000);\n        return;\n    }\n    try {\n        // Close existing socket if any\n        if (socket) {\n            socket.close();\n            socket = null;\n        }\n        socket = new WebSocket(\"wss://streamer.cryptocompare.com/v2\");\n        socket.onopen = ()=>{\n            console.log(\"Connected to CryptoCompare WebSocket\");\n            reconnectAttempts = 0; // Reset attempts on successful connection\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                sendSubscription(socket);\n            } else {\n                pendingSubscription = true;\n            }\n        };\n        socket.onmessage = (event)=>{\n            try {\n                const data = JSON.parse(event.data);\n                if (data.TYPE === \"20\" && data.MESSAGE === \"SUBSCRIBECOMPLETE\") {\n                    console.log(\"Successfully subscribed to feeds\");\n                    return;\n                }\n                const timestamp = Math.floor(Date.now() / 1000);\n                let price = null;\n                if (data.TYPE === \"11\" || data.TYPE === \"2\" || data.TYPE === \"5\") {\n                    price = parseFloat(data.PRICE);\n                    if (price && !isNaN(price)) {\n                        handlePriceUpdate(price, timestamp, currentTimeframe);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error processing message:\", error);\n            }\n        };\n        socket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            reconnectAttempts++;\n            reconnect();\n        };\n        socket.onclose = (event)=>{\n            console.log(\"WebSocket closed with code \".concat(event.code, \", reason: \").concat(event.reason));\n            reconnect();\n        };\n        // Ping every 15 seconds to keep connection alive\n        const pingInterval = setInterval(()=>{\n            if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n                try {\n                    socket.send(JSON.stringify({\n                        \"action\": \"PING\"\n                    }));\n                } catch (error) {\n                    console.error(\"Error sending ping:\", error);\n                    reconnect();\n                }\n            }\n        }, 15000);\n        // Clean up ping interval on socket close\n        socket.addEventListener(\"close\", ()=>clearInterval(pingInterval));\n    } catch (error) {\n        console.error(\"Error creating WebSocket:\", error);\n        reconnectAttempts++;\n        setTimeout(connectWebSocket, RECONNECT_DELAY);\n    }\n}\nfunction reconnect() {\n    if (socket) {\n        try {\n            socket.close();\n        } catch (error) {\n            console.error(\"Error closing socket:\", error);\n        }\n        socket = null;\n    }\n    setTimeout(connectWebSocket, RECONNECT_DELAY * Math.min(reconnectAttempts, 5));\n}\nfunction subscribeToPrice(callback) {\n    let timeframe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"1m\";\n    currentTimeframe = timeframe;\n    priceUpdateCallbacks.push(callback);\n    // Immediately get current price via REST API\n    getCurrentPrice().then((price)=>{\n        const timestamp = Math.floor(Date.now() / 1000);\n        callback({\n            time: timestamp,\n            value: price\n        });\n    }).catch(console.error);\n    // If this is the first subscriber, connect to WebSocket\n    if (priceUpdateCallbacks.length === 1) {\n        connectWebSocket();\n    }\n    return ()=>{\n        priceUpdateCallbacks = priceUpdateCallbacks.filter((cb)=>cb !== callback);\n        if (priceUpdateCallbacks.length === 0 && tradeUpdateCallbacks.length === 0 && socket) {\n            socket.close();\n            socket = null;\n        }\n    };\n}\nfunction subscribeToTrades(callback) {\n    tradeUpdateCallbacks.push(callback);\n    // If this is the first subscriber, connect to WebSocket\n    if (tradeUpdateCallbacks.length === 1 && priceUpdateCallbacks.length === 0) {\n        connectWebSocket();\n    }\n    return ()=>{\n        tradeUpdateCallbacks = tradeUpdateCallbacks.filter((cb)=>cb !== callback);\n        if (priceUpdateCallbacks.length === 0 && tradeUpdateCallbacks.length === 0 && socket) {\n            socket.close();\n            socket = null;\n        }\n    };\n}\nasync function getCurrentPrice() {\n    try {\n        const response = await fetch(\"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\");\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.USD;\n    } catch (error) {\n        console.error(\"Error fetching price:\", error);\n        throw error;\n    }\n}\nasync function getHistoricalData() {\n    let timeframe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1m\";\n    try {\n        var _data_Data;\n        const config = TIMEFRAME_CONFIG[timeframe];\n        const endTime = Math.floor(Date.now() / 1000);\n        // Calculate the appropriate aggregate parameter based on timeframe\n        let aggregate = 1;\n        if (config.endpoint === \"histominute\") {\n            aggregate = config.interval / 60;\n        } else if (config.endpoint === \"histohour\") {\n            aggregate = config.interval / 3600;\n        } else if (config.endpoint === \"histoday\") {\n            aggregate = config.interval / 86400;\n        }\n        const url = \"https://min-api.cryptocompare.com/data/v2/\".concat(config.endpoint, \"?fsym=BTC&tsym=USD&limit=\").concat(config.limit, \"&toTs=\").concat(endTime, \"&aggregate=\").concat(aggregate);\n        console.log(\"Fetching historical data for \".concat(timeframe, \" timeframe...\"));\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!((_data_Data = data.Data) === null || _data_Data === void 0 ? void 0 : _data_Data.Data)) {\n            throw new Error(\"Invalid data format received from API\");\n        }\n        return data.Data.Data;\n    } catch (error) {\n        console.error(\"Error fetching historical data:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBcUJBLE1BQU1BLG1CQUF1RDtJQUMzRCxNQUFNO1FBQUVDLFVBQVU7UUFBZUMsT0FBTztRQUFNQyxVQUFVO0lBQUc7SUFDM0QsTUFBTTtRQUFFRixVQUFVO1FBQWVDLE9BQU87UUFBTUMsVUFBVTtJQUFJO0lBQzVELE9BQU87UUFBRUYsVUFBVTtRQUFlQyxPQUFPO1FBQU1DLFVBQVU7SUFBSTtJQUM3RCxPQUFPO1FBQUVGLFVBQVU7UUFBZUMsT0FBTztRQUFNQyxVQUFVO0lBQUs7SUFDOUQsTUFBTTtRQUFFRixVQUFVO1FBQWFDLE9BQU87UUFBS0MsVUFBVTtJQUFLO0lBQzFELE1BQU07UUFBRUYsVUFBVTtRQUFhQyxPQUFPO1FBQUtDLFVBQVU7SUFBTTtJQUMzRCxNQUFNO1FBQUVGLFVBQVU7UUFBWUMsT0FBTztRQUFLQyxVQUFVO0lBQU07SUFDMUQsTUFBTTtRQUFFRixVQUFVO1FBQVlDLE9BQU87UUFBS0MsVUFBVTtJQUFPO0FBQzdEO0FBRUEsSUFBSUMsU0FBMkI7QUFDL0IsSUFBSUMsdUJBQXNELEVBQUU7QUFDNUQsSUFBSUMsdUJBQXNELEVBQUU7QUFDNUQsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLG1CQUE4QjtBQUNsQyxNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMsa0JBQWtCO0FBRXhCLDRDQUE0QztBQUM1QyxlQUFlQztJQUNiLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU07UUFDN0IsTUFBTUMsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1FBQ2hDLE1BQU1DLFFBQVFGLEtBQUtHLEdBQUc7UUFDdEIsTUFBTUMsWUFBWUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7UUFFMUMsSUFBSU4sU0FBUyxDQUFDTyxNQUFNUCxVQUFVQSxVQUFVVixXQUFXO1lBQ2pEQSxZQUFZVTtZQUNaYixxQkFBcUJxQixPQUFPLENBQUNDLENBQUFBLFdBQVlBLFNBQVM7b0JBQ2hEQyxNQUFNUjtvQkFDTlMsT0FBT1g7Z0JBQ1Q7UUFDRjtJQUNGLEVBQUUsT0FBT1ksT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtJQUNsRDtBQUNGO0FBRUEsU0FBU0UsaUJBQWlCQyxFQUFhO0lBQ3JDLE1BQU1DLGVBQWU7UUFDbkIsVUFBVTtRQUNWLFFBQVE7WUFDTjtZQUNBO1lBQ0EsYUFBMEIsb0JBQW9CO1NBQy9DO0lBQ0g7SUFFQSxJQUFJO1FBQ0ZELEdBQUdFLElBQUksQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDSDtRQUN2QkgsUUFBUU8sR0FBRyxDQUFDO1FBQ1ovQixzQkFBc0I7SUFDeEIsRUFBRSxPQUFPdUIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtRQUM3Q3ZCLHNCQUFzQjtJQUN4QjtBQUNGO0FBRUEsNkRBQTZEO0FBQzdELFNBQVNnQyxrQkFBa0JyQixLQUFhLEVBQUVFLFNBQXVCLEVBQUVvQixTQUFvQjtJQUNyRixNQUFNQyxTQUFTekMsZ0JBQWdCLENBQUN3QyxVQUFVO0lBQzFDLE1BQU1yQyxXQUFXc0MsT0FBT3RDLFFBQVE7SUFFaEMsb0RBQW9EO0lBQ3BELE1BQU11QyxtQkFBbUJyQixLQUFLQyxLQUFLLENBQUNGLFlBQVlqQixZQUFZQTtJQUU1RCxJQUFJZSxTQUFTLENBQUNPLE1BQU1QLFVBQVVBLFVBQVVWLFdBQVc7UUFDakRBLFlBQVlVO1FBRVpiLHFCQUFxQnFCLE9BQU8sQ0FBQ0MsQ0FBQUEsV0FBWUEsU0FBUztnQkFDaERDLE1BQU1jO2dCQUNOYixPQUFPWDtZQUNUO1FBRUEsSUFBSVoscUJBQXFCcUMsTUFBTSxHQUFHLEdBQUc7WUFDbkNyQyxxQkFBcUJvQixPQUFPLENBQUNDLENBQUFBLFdBQVlBLFNBQVM7b0JBQ2hEQyxNQUFNYztvQkFDTnhCLE9BQU9BO29CQUNQMEIsV0FBVyxFQUFFLG9DQUFvQztnQkFDbkQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTQztJQUNQLElBQUl6QyxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVEwQyxVQUFVLE1BQUtDLFVBQVVDLElBQUksRUFBRTtRQUN6QyxJQUFJekMscUJBQXFCO1lBQ3ZCeUIsaUJBQWlCNUI7UUFDbkI7UUFDQTtJQUNGO0lBRUEsd0NBQXdDO0lBQ3hDLElBQUlLLHFCQUFxQkUsd0JBQXdCO1FBQy9Db0IsUUFBUU8sR0FBRyxDQUFDO1FBQ1osK0NBQStDO1FBQy9DLE1BQU1XLGVBQWVDLFlBQVlyQyxrQkFBa0I7UUFDbkQ7SUFDRjtJQUVBLElBQUk7UUFDRiwrQkFBK0I7UUFDL0IsSUFBSVQsUUFBUTtZQUNWQSxPQUFPK0MsS0FBSztZQUNaL0MsU0FBUztRQUNYO1FBRUFBLFNBQVMsSUFBSTJDLFVBQVU7UUFFdkIzQyxPQUFPZ0QsTUFBTSxHQUFHO1lBQ2RyQixRQUFRTyxHQUFHLENBQUM7WUFDWjdCLG9CQUFvQixHQUFHLDBDQUEwQztZQUNqRSxJQUFJTCxVQUFVQSxPQUFPMEMsVUFBVSxLQUFLQyxVQUFVQyxJQUFJLEVBQUU7Z0JBQ2xEaEIsaUJBQWlCNUI7WUFDbkIsT0FBTztnQkFDTEcsc0JBQXNCO1lBQ3hCO1FBQ0Y7UUFFQUgsT0FBT2lELFNBQVMsR0FBRyxDQUFDQztZQUNsQixJQUFJO2dCQUNGLE1BQU10QyxPQUFPb0IsS0FBS21CLEtBQUssQ0FBQ0QsTUFBTXRDLElBQUk7Z0JBRWxDLElBQUlBLEtBQUt3QyxJQUFJLEtBQUssUUFBUXhDLEtBQUt5QyxPQUFPLEtBQUsscUJBQXFCO29CQUM5RDFCLFFBQVFPLEdBQUcsQ0FBQztvQkFDWjtnQkFDRjtnQkFFQSxNQUFNbEIsWUFBWUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7Z0JBQzFDLElBQUlOLFFBQXVCO2dCQUUzQixJQUFJRixLQUFLd0MsSUFBSSxLQUFLLFFBQVF4QyxLQUFLd0MsSUFBSSxLQUFLLE9BQU94QyxLQUFLd0MsSUFBSSxLQUFLLEtBQUs7b0JBQ2hFdEMsUUFBUXdDLFdBQVcxQyxLQUFLMkMsS0FBSztvQkFDN0IsSUFBSXpDLFNBQVMsQ0FBQ08sTUFBTVAsUUFBUTt3QkFDMUJxQixrQkFBa0JyQixPQUFPRSxXQUFXVjtvQkFDdEM7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9vQixPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtZQUM3QztRQUNGO1FBRUExQixPQUFPd0QsT0FBTyxHQUFHLENBQUM5QjtZQUNoQkMsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkE7WUFDbENyQjtZQUNBb0Q7UUFDRjtRQUVBekQsT0FBTzBELE9BQU8sR0FBRyxDQUFDUjtZQUNoQnZCLFFBQVFPLEdBQUcsQ0FBQyw4QkFBcURnQixPQUF2QkEsTUFBTVMsSUFBSSxFQUFDLGNBQXlCLE9BQWJULE1BQU1VLE1BQU07WUFDN0VIO1FBQ0Y7UUFFQSxpREFBaUQ7UUFDakQsTUFBTUksZUFBZWYsWUFBWTtZQUMvQixJQUFJOUMsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRMEMsVUFBVSxNQUFLQyxVQUFVQyxJQUFJLEVBQUU7Z0JBQ3pDLElBQUk7b0JBQ0Y1QyxPQUFPK0IsSUFBSSxDQUFDQyxLQUFLQyxTQUFTLENBQUM7d0JBQUUsVUFBVTtvQkFBTztnQkFDaEQsRUFBRSxPQUFPUCxPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMsdUJBQXVCQTtvQkFDckMrQjtnQkFDRjtZQUNGO1FBQ0YsR0FBRztRQUVILHlDQUF5QztRQUN6Q3pELE9BQU84RCxnQkFBZ0IsQ0FBQyxTQUFTLElBQU1DLGNBQWNGO0lBRXZELEVBQUUsT0FBT25DLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0NyQjtRQUNBMkQsV0FBV3ZCLGtCQUFrQmpDO0lBQy9CO0FBQ0Y7QUFFQSxTQUFTaUQ7SUFDUCxJQUFJekQsUUFBUTtRQUNWLElBQUk7WUFDRkEsT0FBTytDLEtBQUs7UUFDZCxFQUFFLE9BQU9yQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3pDO1FBQ0ExQixTQUFTO0lBQ1g7SUFDQWdFLFdBQVd2QixrQkFBa0JqQyxrQkFBa0JTLEtBQUtnRCxHQUFHLENBQUM1RCxtQkFBbUI7QUFDN0U7QUFFTyxTQUFTNkQsaUJBQWlCM0MsUUFBbUM7UUFBRWEsWUFBQUEsaUVBQXVCO0lBQzNGOUIsbUJBQW1COEI7SUFDbkJuQyxxQkFBcUJrRSxJQUFJLENBQUM1QztJQUUxQiw2Q0FBNkM7SUFDN0M2QyxrQkFBa0JDLElBQUksQ0FBQ3ZELENBQUFBO1FBQ3JCLE1BQU1FLFlBQVlDLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0MsR0FBRyxLQUFLO1FBQzFDRyxTQUFTO1lBQ1BDLE1BQU1SO1lBQ05TLE9BQU9YO1FBQ1Q7SUFDRixHQUFHd0QsS0FBSyxDQUFDM0MsUUFBUUQsS0FBSztJQUV0Qix3REFBd0Q7SUFDeEQsSUFBSXpCLHFCQUFxQnNDLE1BQU0sS0FBSyxHQUFHO1FBQ3JDRTtJQUNGO0lBRUEsT0FBTztRQUNMeEMsdUJBQXVCQSxxQkFBcUJzRSxNQUFNLENBQUNDLENBQUFBLEtBQU1BLE9BQU9qRDtRQUNoRSxJQUFJdEIscUJBQXFCc0MsTUFBTSxLQUFLLEtBQUtyQyxxQkFBcUJxQyxNQUFNLEtBQUssS0FBS3ZDLFFBQVE7WUFDcEZBLE9BQU8rQyxLQUFLO1lBQ1ovQyxTQUFTO1FBQ1g7SUFDRjtBQUNGO0FBRU8sU0FBU3lFLGtCQUFrQmxELFFBQW1DO0lBQ25FckIscUJBQXFCaUUsSUFBSSxDQUFDNUM7SUFFMUIsd0RBQXdEO0lBQ3hELElBQUlyQixxQkFBcUJxQyxNQUFNLEtBQUssS0FBS3RDLHFCQUFxQnNDLE1BQU0sS0FBSyxHQUFHO1FBQzFFRTtJQUNGO0lBRUEsT0FBTztRQUNMdkMsdUJBQXVCQSxxQkFBcUJxRSxNQUFNLENBQUNDLENBQUFBLEtBQU1BLE9BQU9qRDtRQUNoRSxJQUFJdEIscUJBQXFCc0MsTUFBTSxLQUFLLEtBQUtyQyxxQkFBcUJxQyxNQUFNLEtBQUssS0FBS3ZDLFFBQVE7WUFDcEZBLE9BQU8rQyxLQUFLO1lBQ1ovQyxTQUFTO1FBQ1g7SUFDRjtBQUNGO0FBRU8sZUFBZW9FO0lBQ3BCLElBQUk7UUFDRixNQUFNMUQsV0FBVyxNQUFNQyxNQUFNO1FBQzdCLElBQUksQ0FBQ0QsU0FBU2dFLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sdUJBQXVDLE9BQWhCakUsU0FBU2tFLE1BQU07UUFDeEQ7UUFDQSxNQUFNaEUsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1FBQ2hDLE9BQU9ELEtBQUtHLEdBQUc7SUFDakIsRUFBRSxPQUFPVyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDLE1BQU1BO0lBQ1I7QUFDRjtBQUVPLGVBQWVtRDtRQUFrQnpDLFlBQUFBLGlFQUF1QjtJQUM3RCxJQUFJO1lBd0JHeEI7UUF2QkwsTUFBTXlCLFNBQVN6QyxnQkFBZ0IsQ0FBQ3dDLFVBQVU7UUFDMUMsTUFBTTBDLFVBQVU3RCxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztRQUV4QyxtRUFBbUU7UUFDbkUsSUFBSTJELFlBQVk7UUFDaEIsSUFBSTFDLE9BQU94QyxRQUFRLEtBQUssZUFBZTtZQUNyQ2tGLFlBQVkxQyxPQUFPdEMsUUFBUSxHQUFHO1FBQ2hDLE9BQU8sSUFBSXNDLE9BQU94QyxRQUFRLEtBQUssYUFBYTtZQUMxQ2tGLFlBQVkxQyxPQUFPdEMsUUFBUSxHQUFHO1FBQ2hDLE9BQU8sSUFBSXNDLE9BQU94QyxRQUFRLEtBQUssWUFBWTtZQUN6Q2tGLFlBQVkxQyxPQUFPdEMsUUFBUSxHQUFHO1FBQ2hDO1FBRUEsTUFBTWlGLE1BQU0sNkNBQXdGM0MsT0FBM0NBLE9BQU94QyxRQUFRLEVBQUMsNkJBQWdEaUYsT0FBckJ6QyxPQUFPdkMsS0FBSyxFQUFDLFVBQTZCaUYsT0FBckJELFNBQVEsZUFBdUIsT0FBVkM7UUFFOUlwRCxRQUFRTyxHQUFHLENBQUMsZ0NBQTBDLE9BQVZFLFdBQVU7UUFDdEQsTUFBTTFCLFdBQVcsTUFBTUMsTUFBTXFFO1FBRTdCLElBQUksQ0FBQ3RFLFNBQVNnRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLHVCQUF1QyxPQUFoQmpFLFNBQVNrRSxNQUFNO1FBQ3hEO1FBRUEsTUFBTWhFLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtRQUNoQyxJQUFJLEdBQUNELGFBQUFBLEtBQUtxRSxJQUFJLGNBQVRyRSxpQ0FBQUEsV0FBV3FFLElBQUksR0FBRTtZQUNwQixNQUFNLElBQUlOLE1BQU07UUFDbEI7UUFFQSxPQUFPL0QsS0FBS3FFLElBQUksQ0FBQ0EsSUFBSTtJQUN2QixFQUFFLE9BQU92RCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEkudHM/NTNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUaW1lLCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5cclxuaW50ZXJmYWNlIFByaWNlRGF0YSB7XHJcbiAgdGltZTogVVRDVGltZXN0YW1wO1xyXG4gIHZhbHVlOiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUcmFkZURhdGEge1xyXG4gIHRpbWU6IFVUQ1RpbWVzdGFtcDtcclxuICBwcmljZTogbnVtYmVyO1xyXG4gIHZvbHVtZTI0aDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUaW1lZnJhbWVDb25maWcgPSB7XHJcbiAgZW5kcG9pbnQ6IHN0cmluZztcclxuICBsaW1pdDogbnVtYmVyO1xyXG4gIGludGVydmFsOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRpbWVmcmFtZSA9ICcxbScgfCAnNW0nIHwgJzE1bScgfCAnMzBtJyB8ICcxaCcgfCAnNGgnIHwgJzFkJyB8ICcxdyc7XHJcblxyXG5jb25zdCBUSU1FRlJBTUVfQ09ORklHOiBSZWNvcmQ8VGltZWZyYW1lLCBUaW1lZnJhbWVDb25maWc+ID0ge1xyXG4gICcxbSc6IHsgZW5kcG9pbnQ6ICdoaXN0b21pbnV0ZScsIGxpbWl0OiAxNDQwLCBpbnRlcnZhbDogNjAgfSxcclxuICAnNW0nOiB7IGVuZHBvaW50OiAnaGlzdG9taW51dGUnLCBsaW1pdDogMTQ0MCwgaW50ZXJ2YWw6IDMwMCB9LFxyXG4gICcxNW0nOiB7IGVuZHBvaW50OiAnaGlzdG9taW51dGUnLCBsaW1pdDogMTQ0MCwgaW50ZXJ2YWw6IDkwMCB9LFxyXG4gICczMG0nOiB7IGVuZHBvaW50OiAnaGlzdG9taW51dGUnLCBsaW1pdDogMTQ0MCwgaW50ZXJ2YWw6IDE4MDAgfSxcclxuICAnMWgnOiB7IGVuZHBvaW50OiAnaGlzdG9ob3VyJywgbGltaXQ6IDcyMCwgaW50ZXJ2YWw6IDM2MDAgfSxcclxuICAnNGgnOiB7IGVuZHBvaW50OiAnaGlzdG9ob3VyJywgbGltaXQ6IDcyMCwgaW50ZXJ2YWw6IDE0NDAwIH0sXHJcbiAgJzFkJzogeyBlbmRwb2ludDogJ2hpc3RvZGF5JywgbGltaXQ6IDM2NSwgaW50ZXJ2YWw6IDg2NDAwIH0sXHJcbiAgJzF3JzogeyBlbmRwb2ludDogJ2hpc3RvZGF5JywgbGltaXQ6IDM2NSwgaW50ZXJ2YWw6IDYwNDgwMCB9XHJcbn07XHJcblxyXG5sZXQgc29ja2V0OiBXZWJTb2NrZXQgfCBudWxsID0gbnVsbDtcclxubGV0IHByaWNlVXBkYXRlQ2FsbGJhY2tzOiAoKGRhdGE6IFByaWNlRGF0YSkgPT4gdm9pZClbXSA9IFtdO1xyXG5sZXQgdHJhZGVVcGRhdGVDYWxsYmFja3M6ICgoZGF0YTogVHJhZGVEYXRhKSA9PiB2b2lkKVtdID0gW107XHJcbmxldCBwZW5kaW5nU3Vic2NyaXB0aW9uID0gZmFsc2U7XHJcbmxldCBsYXN0UHJpY2UgPSAwO1xyXG5sZXQgcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG5sZXQgY3VycmVudFRpbWVmcmFtZTogVGltZWZyYW1lID0gJzFtJztcclxuY29uc3QgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDU7XHJcbmNvbnN0IFJFQ09OTkVDVF9ERUxBWSA9IDIwMDA7XHJcblxyXG4vLyBGYWxsYmFjayB0byBSRVNUIEFQSSB3aGVuIFdlYlNvY2tldCBmYWlsc1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFByaWNlVXBkYXRlKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUJUQyZ0c3ltcz1VU0QnKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBwcmljZSA9IGRhdGEuVVNEO1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgYXMgVVRDVGltZXN0YW1wO1xyXG5cclxuICAgIGlmIChwcmljZSAmJiAhaXNOYU4ocHJpY2UpICYmIHByaWNlICE9PSBsYXN0UHJpY2UpIHtcclxuICAgICAgbGFzdFByaWNlID0gcHJpY2U7XHJcbiAgICAgIHByaWNlVXBkYXRlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soe1xyXG4gICAgICAgIHRpbWU6IHRpbWVzdGFtcCxcclxuICAgICAgICB2YWx1ZTogcHJpY2VcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcmljZSB2aWEgUkVTVDonLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZW5kU3Vic2NyaXB0aW9uKHdzOiBXZWJTb2NrZXQpIHtcclxuICBjb25zdCBzdWJzY3JpYmVNc2cgPSB7XHJcbiAgICBcImFjdGlvblwiOiBcIlN1YkFkZFwiLFxyXG4gICAgXCJzdWJzXCI6IFtcclxuICAgICAgXCI1fkNDQ0FHR35CVEN+VVNEXCIsICAgICAgIC8vIEFnZ3JlZ2F0ZSBpbmRleCAobW9zdCBmcmVxdWVudClcclxuICAgICAgXCIyfkNvaW5iYXNlfkJUQ35VU0RcIiwgICAgIC8vIENvaW5iYXNlIHRpY2tlclxyXG4gICAgICBcIjExfkJUQ35VU0RcIiAgICAgICAgICAgICAgLy8gRGlyZWN0IHByaWNlIGZlZWRcclxuICAgIF1cclxuICB9O1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KHN1YnNjcmliZU1zZykpO1xyXG4gICAgY29uc29sZS5sb2coJ1N1YnNjcmliZWQgdG8gcHJpY2UgZmVlZHMnKTtcclxuICAgIHBlbmRpbmdTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyBzdWJzY3JpcHRpb246JywgZXJyb3IpO1xyXG4gICAgcGVuZGluZ1N1YnNjcmlwdGlvbiA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVcGRhdGUgdGhlIFdlYlNvY2tldCBtZXNzYWdlIGhhbmRsZXIgdG8gcmVzcGVjdCB0aW1lZnJhbWVzXHJcbmZ1bmN0aW9uIGhhbmRsZVByaWNlVXBkYXRlKHByaWNlOiBudW1iZXIsIHRpbWVzdGFtcDogVVRDVGltZXN0YW1wLCB0aW1lZnJhbWU6IFRpbWVmcmFtZSkge1xyXG4gIGNvbnN0IGNvbmZpZyA9IFRJTUVGUkFNRV9DT05GSUdbdGltZWZyYW1lXTtcclxuICBjb25zdCBpbnRlcnZhbCA9IGNvbmZpZy5pbnRlcnZhbDtcclxuICBcclxuICAvLyBBbGlnbiB0aW1lc3RhbXAgdG8gdGhlIGN1cnJlbnQgdGltZWZyYW1lIGludGVydmFsXHJcbiAgY29uc3QgYWxpZ25lZFRpbWVzdGFtcCA9IE1hdGguZmxvb3IodGltZXN0YW1wIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwgYXMgVVRDVGltZXN0YW1wO1xyXG4gIFxyXG4gIGlmIChwcmljZSAmJiAhaXNOYU4ocHJpY2UpICYmIHByaWNlICE9PSBsYXN0UHJpY2UpIHtcclxuICAgIGxhc3RQcmljZSA9IHByaWNlO1xyXG4gICAgXHJcbiAgICBwcmljZVVwZGF0ZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHtcclxuICAgICAgdGltZTogYWxpZ25lZFRpbWVzdGFtcCxcclxuICAgICAgdmFsdWU6IHByaWNlXHJcbiAgICB9KSk7XHJcblxyXG4gICAgaWYgKHRyYWRlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdHJhZGVVcGRhdGVDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh7XHJcbiAgICAgICAgdGltZTogYWxpZ25lZFRpbWVzdGFtcCxcclxuICAgICAgICBwcmljZTogcHJpY2UsXHJcbiAgICAgICAgdm9sdW1lMjRoOiAwIC8vIFZvbHVtZSB3aWxsIGJlIHVwZGF0ZWQgc2VwYXJhdGVseVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb25uZWN0V2ViU29ja2V0KCkge1xyXG4gIGlmIChzb2NrZXQ/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICBpZiAocGVuZGluZ1N1YnNjcmlwdGlvbikge1xyXG4gICAgICBzZW5kU3Vic2NyaXB0aW9uKHNvY2tldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBEb24ndCB0cnkgdG8gcmVjb25uZWN0IHRvbyBtYW55IHRpbWVzXHJcbiAgaWYgKHJlY29ubmVjdEF0dGVtcHRzID49IE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMpIHtcclxuICAgIGNvbnNvbGUubG9nKCdNYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIHJlYWNoZWQsIGZhbGxpbmcgYmFjayB0byBSRVNUIEFQSScpO1xyXG4gICAgLy8gU2V0IHVwIHBlcmlvZGljIFJFU1QgQVBJIHBvbGxpbmcgYXMgZmFsbGJhY2tcclxuICAgIGNvbnN0IHBvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZldGNoUHJpY2VVcGRhdGUsIDUwMDApO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIENsb3NlIGV4aXN0aW5nIHNvY2tldCBpZiBhbnlcclxuICAgIGlmIChzb2NrZXQpIHtcclxuICAgICAgc29ja2V0LmNsb3NlKCk7XHJcbiAgICAgIHNvY2tldCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc29ja2V0ID0gbmV3IFdlYlNvY2tldCgnd3NzOi8vc3RyZWFtZXIuY3J5cHRvY29tcGFyZS5jb20vdjInKTtcclxuXHJcbiAgICBzb2NrZXQub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIENyeXB0b0NvbXBhcmUgV2ViU29ja2V0Jyk7XHJcbiAgICAgIHJlY29ubmVjdEF0dGVtcHRzID0gMDsgLy8gUmVzZXQgYXR0ZW1wdHMgb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXHJcbiAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgc2VuZFN1YnNjcmlwdGlvbihzb2NrZXQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBlbmRpbmdTdWJzY3JpcHRpb24gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChkYXRhLlRZUEUgPT09IFwiMjBcIiAmJiBkYXRhLk1FU1NBR0UgPT09IFwiU1VCU0NSSUJFQ09NUExFVEVcIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBzdWJzY3JpYmVkIHRvIGZlZWRzJyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSBhcyBVVENUaW1lc3RhbXA7XHJcbiAgICAgICAgbGV0IHByaWNlOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGRhdGEuVFlQRSA9PT0gXCIxMVwiIHx8IGRhdGEuVFlQRSA9PT0gXCIyXCIgfHwgZGF0YS5UWVBFID09PSBcIjVcIikge1xyXG4gICAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0KGRhdGEuUFJJQ0UpO1xyXG4gICAgICAgICAgaWYgKHByaWNlICYmICFpc05hTihwcmljZSkpIHtcclxuICAgICAgICAgICAgaGFuZGxlUHJpY2VVcGRhdGUocHJpY2UsIHRpbWVzdGFtcCwgY3VycmVudFRpbWVmcmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgbWVzc2FnZTonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc29ja2V0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcclxuICAgICAgcmVjb25uZWN0QXR0ZW1wdHMrKztcclxuICAgICAgcmVjb25uZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBXZWJTb2NrZXQgY2xvc2VkIHdpdGggY29kZSAke2V2ZW50LmNvZGV9LCByZWFzb246ICR7ZXZlbnQucmVhc29ufWApO1xyXG4gICAgICByZWNvbm5lY3QoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGluZyBldmVyeSAxNSBzZWNvbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBhbGl2ZVxyXG4gICAgY29uc3QgcGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBpZiAoc29ja2V0Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IFwiYWN0aW9uXCI6IFwiUElOR1wiIH0pKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyBwaW5nOicsIGVycm9yKTtcclxuICAgICAgICAgIHJlY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgMTUwMDApO1xyXG5cclxuICAgIC8vIENsZWFuIHVwIHBpbmcgaW50ZXJ2YWwgb24gc29ja2V0IGNsb3NlXHJcbiAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiBjbGVhckludGVydmFsKHBpbmdJbnRlcnZhbCkpO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgV2ViU29ja2V0OicsIGVycm9yKTtcclxuICAgIHJlY29ubmVjdEF0dGVtcHRzKys7XHJcbiAgICBzZXRUaW1lb3V0KGNvbm5lY3RXZWJTb2NrZXQsIFJFQ09OTkVDVF9ERUxBWSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNvbm5lY3QoKSB7XHJcbiAgaWYgKHNvY2tldCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc29ja2V0LmNsb3NlKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbG9zaW5nIHNvY2tldDonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBzb2NrZXQgPSBudWxsO1xyXG4gIH1cclxuICBzZXRUaW1lb3V0KGNvbm5lY3RXZWJTb2NrZXQsIFJFQ09OTkVDVF9ERUxBWSAqIE1hdGgubWluKHJlY29ubmVjdEF0dGVtcHRzLCA1KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVUb1ByaWNlKGNhbGxiYWNrOiAoZGF0YTogUHJpY2VEYXRhKSA9PiB2b2lkLCB0aW1lZnJhbWU6IFRpbWVmcmFtZSA9ICcxbScpIHtcclxuICBjdXJyZW50VGltZWZyYW1lID0gdGltZWZyYW1lO1xyXG4gIHByaWNlVXBkYXRlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gIFxyXG4gIC8vIEltbWVkaWF0ZWx5IGdldCBjdXJyZW50IHByaWNlIHZpYSBSRVNUIEFQSVxyXG4gIGdldEN1cnJlbnRQcmljZSgpLnRoZW4ocHJpY2UgPT4ge1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgYXMgVVRDVGltZXN0YW1wO1xyXG4gICAgY2FsbGJhY2soe1xyXG4gICAgICB0aW1lOiB0aW1lc3RhbXAsXHJcbiAgICAgIHZhbHVlOiBwcmljZVxyXG4gICAgfSk7XHJcbiAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgXHJcbiAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3Qgc3Vic2NyaWJlciwgY29ubmVjdCB0byBXZWJTb2NrZXRcclxuICBpZiAocHJpY2VVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICBjb25uZWN0V2ViU29ja2V0KCk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBwcmljZVVwZGF0ZUNhbGxiYWNrcyA9IHByaWNlVXBkYXRlQ2FsbGJhY2tzLmZpbHRlcihjYiA9PiBjYiAhPT0gY2FsbGJhY2spO1xyXG4gICAgaWYgKHByaWNlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCAmJiB0cmFkZVVwZGF0ZUNhbGxiYWNrcy5sZW5ndGggPT09IDAgJiYgc29ja2V0KSB7XHJcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xyXG4gICAgICBzb2NrZXQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVUb1RyYWRlcyhjYWxsYmFjazogKGRhdGE6IFRyYWRlRGF0YSkgPT4gdm9pZCkge1xyXG4gIHRyYWRlVXBkYXRlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gIFxyXG4gIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHN1YnNjcmliZXIsIGNvbm5lY3QgdG8gV2ViU29ja2V0XHJcbiAgaWYgKHRyYWRlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMSAmJiBwcmljZVVwZGF0ZUNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgIGNvbm5lY3RXZWJTb2NrZXQoKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIHRyYWRlVXBkYXRlQ2FsbGJhY2tzID0gdHJhZGVVcGRhdGVDYWxsYmFja3MuZmlsdGVyKGNiID0+IGNiICE9PSBjYWxsYmFjayk7XHJcbiAgICBpZiAocHJpY2VVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAwICYmIHRyYWRlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCAmJiBzb2NrZXQpIHtcclxuICAgICAgc29ja2V0LmNsb3NlKCk7XHJcbiAgICAgIHNvY2tldCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRQcmljZSgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUJUQyZ0c3ltcz1VU0QnKTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIHJldHVybiBkYXRhLlVTRDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJpY2U6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SGlzdG9yaWNhbERhdGEodGltZWZyYW1lOiBUaW1lZnJhbWUgPSAnMW0nKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb25maWcgPSBUSU1FRlJBTUVfQ09ORklHW3RpbWVmcmFtZV07XHJcbiAgICBjb25zdCBlbmRUaW1lID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYXBwcm9wcmlhdGUgYWdncmVnYXRlIHBhcmFtZXRlciBiYXNlZCBvbiB0aW1lZnJhbWVcclxuICAgIGxldCBhZ2dyZWdhdGUgPSAxO1xyXG4gICAgaWYgKGNvbmZpZy5lbmRwb2ludCA9PT0gJ2hpc3RvbWludXRlJykge1xyXG4gICAgICBhZ2dyZWdhdGUgPSBjb25maWcuaW50ZXJ2YWwgLyA2MDtcclxuICAgIH0gZWxzZSBpZiAoY29uZmlnLmVuZHBvaW50ID09PSAnaGlzdG9ob3VyJykge1xyXG4gICAgICBhZ2dyZWdhdGUgPSBjb25maWcuaW50ZXJ2YWwgLyAzNjAwO1xyXG4gICAgfSBlbHNlIGlmIChjb25maWcuZW5kcG9pbnQgPT09ICdoaXN0b2RheScpIHtcclxuICAgICAgYWdncmVnYXRlID0gY29uZmlnLmludGVydmFsIC8gODY0MDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vbWluLWFwaS5jcnlwdG9jb21wYXJlLmNvbS9kYXRhL3YyLyR7Y29uZmlnLmVuZHBvaW50fT9mc3ltPUJUQyZ0c3ltPVVTRCZsaW1pdD0ke2NvbmZpZy5saW1pdH0mdG9Ucz0ke2VuZFRpbWV9JmFnZ3JlZ2F0ZT0ke2FnZ3JlZ2F0ZX1gO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgaGlzdG9yaWNhbCBkYXRhIGZvciAke3RpbWVmcmFtZX0gdGltZWZyYW1lLi4uYCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgaWYgKCFkYXRhLkRhdGE/LkRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgZm9ybWF0IHJlY2VpdmVkIGZyb20gQVBJJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGEuRGF0YS5EYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59ICJdLCJuYW1lcyI6WyJUSU1FRlJBTUVfQ09ORklHIiwiZW5kcG9pbnQiLCJsaW1pdCIsImludGVydmFsIiwic29ja2V0IiwicHJpY2VVcGRhdGVDYWxsYmFja3MiLCJ0cmFkZVVwZGF0ZUNhbGxiYWNrcyIsInBlbmRpbmdTdWJzY3JpcHRpb24iLCJsYXN0UHJpY2UiLCJyZWNvbm5lY3RBdHRlbXB0cyIsImN1cnJlbnRUaW1lZnJhbWUiLCJNQVhfUkVDT05ORUNUX0FUVEVNUFRTIiwiUkVDT05ORUNUX0RFTEFZIiwiZmV0Y2hQcmljZVVwZGF0ZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsInByaWNlIiwiVVNEIiwidGltZXN0YW1wIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImlzTmFOIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwidGltZSIsInZhbHVlIiwiZXJyb3IiLCJjb25zb2xlIiwic2VuZFN1YnNjcmlwdGlvbiIsIndzIiwic3Vic2NyaWJlTXNnIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJsb2ciLCJoYW5kbGVQcmljZVVwZGF0ZSIsInRpbWVmcmFtZSIsImNvbmZpZyIsImFsaWduZWRUaW1lc3RhbXAiLCJsZW5ndGgiLCJ2b2x1bWUyNGgiLCJjb25uZWN0V2ViU29ja2V0IiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJwb2xsSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsb3NlIiwib25vcGVuIiwib25tZXNzYWdlIiwiZXZlbnQiLCJwYXJzZSIsIlRZUEUiLCJNRVNTQUdFIiwicGFyc2VGbG9hdCIsIlBSSUNFIiwib25lcnJvciIsInJlY29ubmVjdCIsIm9uY2xvc2UiLCJjb2RlIiwicmVhc29uIiwicGluZ0ludGVydmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsZWFySW50ZXJ2YWwiLCJzZXRUaW1lb3V0IiwibWluIiwic3Vic2NyaWJlVG9QcmljZSIsInB1c2giLCJnZXRDdXJyZW50UHJpY2UiLCJ0aGVuIiwiY2F0Y2giLCJmaWx0ZXIiLCJjYiIsInN1YnNjcmliZVRvVHJhZGVzIiwib2siLCJFcnJvciIsInN0YXR1cyIsImdldEhpc3RvcmljYWxEYXRhIiwiZW5kVGltZSIsImFnZ3JlZ2F0ZSIsInVybCIsIkRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/moving-averages */ \"(app-pages-browser)/./src/services/strategies/moving-averages.ts\");\n/* harmony import */ var _TickerHeader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TickerHeader */ \"(app-pages-browser)/./src/components/Chart/TickerHeader.tsx\");\n/* harmony import */ var _utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/priceFormat */ \"(app-pages-browser)/./src/utils/priceFormat.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Function to get interval in seconds\nconst getIntervalSeconds = (tf)=>{\n    switch(tf){\n        case \"1m\":\n            return 60;\n        case \"5m\":\n            return 300;\n        case \"15m\":\n            return 900;\n        case \"30m\":\n            return 1800;\n        case \"1h\":\n            return 3600;\n        case \"4h\":\n            return 14400;\n        case \"1d\":\n            return 86400;\n        default:\n            return 60;\n    }\n};\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token = \"BTC\", baseToken = \"USDT\", exchange = \"CryptoCompare\", onPairChange = ()=>{} } = param;\n    _s();\n    const [selectedExchange, setSelectedExchange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(exchange);\n    const [currentBaseToken, setCurrentBaseToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(baseToken);\n    const [currentPrice, setCurrentPrice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken));\n    const [priceStats, setPriceStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>({\n            change1h: \"0.00\",\n            change24h: \"0.00\",\n            change7d: \"0.00\",\n            high24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken),\n            low24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken)\n        }));\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const currentCandleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastSignalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Handle trading pair change\n    const handlePairChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((newToken, newBaseToken)=>{\n        onPairChange(newToken, newBaseToken);\n        setCurrentBaseToken(newBaseToken);\n    }, [\n        onPairChange\n    ]);\n    // Function to update price stats\n    const updatePriceStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((data)=>{\n        if (data.length < 2) return;\n        const currentPrice = data[data.length - 1].close;\n        // Calculate different time period changes\n        const last1h = data.slice(-1); // Last hour\n        const last24h = data.slice(-24); // Last 24 hours\n        const last7d = data.slice(-168); // Last 7 days (24 * 7)\n        const high24h = Math.max(...last24h.map((d)=>d.high));\n        const low24h = Math.min(...last24h.map((d)=>d.low));\n        // Calculate percentage changes\n        const getPercentChange = (periodData)=>{\n            if (periodData.length < 2) return 0;\n            const oldPrice = periodData[0].close;\n            return (currentPrice - oldPrice) / oldPrice * 100;\n        };\n        const change1h = getPercentChange(last1h);\n        const change24h = getPercentChange(last24h);\n        const change7d = getPercentChange(last7d);\n        // Format prices using the price format utility\n        const formattedCurrentPrice = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(currentPrice, currentBaseToken);\n        const formattedHigh = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(high24h, currentBaseToken);\n        const formattedLow = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(low24h, currentBaseToken);\n        setCurrentPrice(formattedCurrentPrice);\n        setPriceStats({\n            change1h: change1h.toFixed(2),\n            change24h: change24h.toFixed(2),\n            change7d: change7d.toFixed(2),\n            high24h: formattedHigh,\n            low24h: formattedLow\n        });\n    }, [\n        currentBaseToken\n    ]);\n    // Function to add strategy indicators\n    const addStrategyIndicators = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chart, data)=>{\n        if (!chart) {\n            console.error(\"Chart is not initialized\");\n            return;\n        }\n        try {\n            // Clear any existing indicators\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    if (series && chart) {\n                        chart.removeSeries(series);\n                    }\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            if (markerSeriesRef.current) {\n                try {\n                    chart.removeSeries(markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            if (strategy === \"none\") return;\n            // Calculate indicators based on strategy\n            const prices = data.map((d)=>d.close);\n            let fastLine = [];\n            let slowLine = [];\n            switch(strategy){\n                case \"ema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 21);\n                    break;\n                case \"sma_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 21);\n                    break;\n                case \"tema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 7);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 21);\n                    break;\n                case \"golden_cross\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 50);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 200);\n                    break;\n                case \"hull_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 21);\n                    break;\n                case \"ema_5_13\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 5);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 13);\n                    break;\n            }\n            // Add indicator lines\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy) return;\n            const colors = [\n                \"#2962FF\",\n                \"#FF6B6B\"\n            ];\n            selectedStrategy.indicators.forEach((indicator, index)=>{\n                const lineSeries = chart.addLineSeries({\n                    color: colors[index],\n                    lineWidth: 2,\n                    title: indicator.name,\n                    priceFormat: {\n                        type: \"price\",\n                        precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                        minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n                    }\n                });\n                indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                lineSeries.setData(lineData);\n                // Add crossover markers to the first line series only\n                if (index === 0) {\n                    // Detect crossovers and create markers\n                    const markers = [];\n                    for(let i = 1; i < data.length; i++){\n                        const prevFast = fastLine[i - 1];\n                        const prevSlow = slowLine[i - 1];\n                        const currFast = fastLine[i];\n                        const currSlow = slowLine[i];\n                        // Check for crossover\n                        if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                            // Bullish crossover (fast crosses above slow)\n                            if (prevFast <= prevSlow && currFast > currSlow) {\n                                markers.push({\n                                    time: data[i].time,\n                                    position: \"belowBar\",\n                                    color: \"#26a69a\",\n                                    shape: \"triangle\",\n                                    size: 2\n                                });\n                            } else if (prevFast >= prevSlow && currFast < currSlow) {\n                                markers.push({\n                                    time: data[i].time,\n                                    position: \"aboveBar\",\n                                    color: \"#ef5350\",\n                                    shape: \"triangle\",\n                                    size: 2\n                                });\n                            }\n                        }\n                    }\n                    lineSeries.setMarkers(markers);\n                }\n            });\n        } catch (error) {\n            console.error(\"Error adding strategy indicators:\", error);\n        }\n    }, [\n        strategy,\n        currentBaseToken\n    ]);\n    // Effect for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartRef.current || historicalDataRef.current.length === 0) {\n            return;\n        }\n        try {\n            addStrategyIndicators(chartRef.current, historicalDataRef.current);\n        } catch (error) {\n            console.error(\"Error in strategy change effect:\", error);\n        }\n    }, [\n        strategy,\n        addStrategyIndicators\n    ]);\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\",\n                visible: true,\n                scaleMargins: {\n                    top: 0.1,\n                    bottom: 0.4\n                },\n                autoScale: true,\n                mode: 0,\n                alignLabels: true,\n                borderVisible: true,\n                entireTextOnly: true,\n                ticksVisible: true\n            },\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight,\n            localization: {\n                priceFormatter: (price)=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(price, currentBaseToken)\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, chartOptions);\n        // Create candlestick series with price format\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\",\n            priceFormat: {\n                type: \"price\",\n                precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n            }\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        chartRef.current = chart;\n        // Load initial data\n        const loadData = async ()=>{\n            try {\n                const data = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe, token, currentBaseToken);\n                historicalDataRef.current = data;\n                candlestickSeries.setData(data);\n                updatePriceStats(data);\n                if (strategy !== \"none\") {\n                    addStrategyIndicators(chart, data);\n                }\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            }\n        };\n        loadData();\n        // Real-time updates\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (!candlestickSeriesRef.current) return;\n            const intervalSeconds = getIntervalSeconds(timeframe);\n            const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n            // If this is a new candle\n            if (!currentCandleRef.current || candleTimestamp !== currentCandleRef.current.time) {\n                // If we had a previous candle, add it to historical data and check for signals\n                if (currentCandleRef.current) {\n                    historicalDataRef.current = [\n                        ...historicalDataRef.current,\n                        currentCandleRef.current\n                    ];\n                    // Update strategies with the new historical data\n                    if (strategy !== \"none\" && chartRef.current) {\n                        addStrategyIndicators(chartRef.current, historicalDataRef.current);\n                    }\n                }\n                // Start new candle\n                currentCandleRef.current = {\n                    time: candleTimestamp,\n                    open: data.value,\n                    high: data.value,\n                    low: data.value,\n                    close: data.value\n                };\n            } else {\n                // Update current candle\n                currentCandleRef.current.high = Math.max(currentCandleRef.current.high, data.value);\n                currentCandleRef.current.low = Math.min(currentCandleRef.current.low, data.value);\n                currentCandleRef.current.close = data.value;\n            }\n            // Update the chart with current candle\n            candlestickSeriesRef.current.update(currentCandleRef.current);\n            // Update price stats with the latest data\n            if (historicalDataRef.current.length > 0) {\n                updatePriceStats([\n                    ...historicalDataRef.current,\n                    currentCandleRef.current\n                ]);\n            }\n        }, timeframe, token, currentBaseToken);\n        // Handle window resize\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            unsubscribe();\n            // Clean up indicator series\n            if (chartRef.current) {\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    try {\n                        var _chartRef_current;\n                        (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.removeSeries(series);\n                    } catch (e) {\n                        console.error(\"Error removing indicator series during cleanup:\", e);\n                    }\n                });\n                indicatorSeriesRefs.current.clear();\n                if (markerSeriesRef.current) {\n                    try {\n                        chartRef.current.removeSeries(markerSeriesRef.current);\n                    } catch (e) {\n                        console.error(\"Error removing marker series during cleanup:\", e);\n                    }\n                    markerSeriesRef.current = null;\n                }\n                chart.remove();\n            }\n        };\n    }, [\n        timeframe,\n        currentBaseToken,\n        strategy,\n        token,\n        updatePriceStats,\n        addStrategyIndicators\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col w-full h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TickerHeader__WEBPACK_IMPORTED_MODULE_6__.TickerHeader, {\n                token: token,\n                baseToken: baseToken,\n                exchange: exchange,\n                currentPrice: currentPrice,\n                priceStats: priceStats,\n                onExchangeChange: setSelectedExchange,\n                onPairChange: handlePairChange\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 436,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"flex-1\"\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 445,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 435,\n        columnNumber: 5\n    }, this);\n}\n_s(CandlestickChart, \"fSolAksHyALEaMVIoak3hb68RJc=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVpRTtBQUNoQjtBQUNnRDtBQUNqQztBQU9qQjtBQUNEO0FBUWpCO0FBbUI3QixzQ0FBc0M7QUFDdEMsTUFBTWUscUJBQXFCLENBQUNDO0lBQzFCLE9BQVFBO1FBQ04sS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFPLE9BQU87UUFDbkIsS0FBSztZQUFPLE9BQU87UUFDbkIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEI7WUFBUyxPQUFPO0lBQ2xCO0FBQ0Y7QUFFTyxTQUFTQyxpQkFBaUIsS0FPVDtRQVBTLEVBQy9CQyxTQUFTLEVBQ1RDLFFBQVEsRUFDUkMsUUFBUSxLQUFLLEVBQ2JDLFlBQVksTUFBTSxFQUNsQkMsV0FBVyxlQUFlLEVBQzFCQyxlQUFlLEtBQU8sQ0FBQyxFQUNELEdBUFM7O0lBUS9CLE1BQU0sQ0FBQ0Msa0JBQWtCQyxvQkFBb0IsR0FBR3ZCLCtDQUFRQSxDQUFDb0I7SUFDekQsTUFBTSxDQUFDSSxrQkFBa0JDLG9CQUFvQixHQUFHekIsK0NBQVFBLENBQUNtQjtJQUN6RCxNQUFNLENBQUNPLGNBQWNDLGdCQUFnQixHQUFHM0IsK0NBQVFBLENBQVMsSUFBTVcsK0RBQVdBLENBQUMsR0FBR1E7SUFDOUUsTUFBTSxDQUFDUyxZQUFZQyxjQUFjLEdBQUc3QiwrQ0FBUUEsQ0FBQyxJQUFPO1lBQ2xEOEIsVUFBVTtZQUNWQyxXQUFXO1lBQ1hDLFVBQVU7WUFDVkMsU0FBU3RCLCtEQUFXQSxDQUFDLEdBQUdRO1lBQ3hCZSxRQUFRdkIsK0RBQVdBLENBQUMsR0FBR1E7UUFDekI7SUFFQSxNQUFNZ0Isb0JBQW9CcEMsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1xQyxXQUFXckMs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U0FBU3FDLE9BQU8sY0FBaEJyQyx3Q0FBQUEsa0JBQWtCd0MsWUFBWSxDQUFDRDtvQkFDakMsRUFBRSxPQUFPRSxHQUFHO3dCQUNWTixRQUFRQyxLQUFLLENBQUMsbURBQW1ESztvQkFDbkU7Z0JBQ0Y7Z0JBQ0F2QyxvQkFBb0JtQyxPQUFPLENBQUNLLEtBQUs7Z0JBRWpDLElBQUl0QyxnQkFBZ0JpQyxPQUFPLEVBQUU7b0JBQzNCLElBQUk7d0JBQ0ZyQyxTQUFTcUMsT0FBTyxDQUFDRyxZQUFZLENBQUNwQyxnQkFBZ0JpQyxPQUFPO29CQUN2RCxFQUFFLE9BQU9JLEdBQUc7d0JBQ1ZOLFFBQVFDLEtBQUssQ0FBQyxnREFBZ0RLO29CQUNoRTtvQkFDQXJDLGdCQUFnQmlDLE9BQU8sR0FBRztnQkFDNUI7Z0JBRUFILE1BQU00RixNQUFNO1lBQ2Q7UUFDRjtJQUNGLEdBQUc7UUFBQ2xKO1FBQVdRO1FBQWtCUDtRQUFVQztRQUFPNkI7UUFBa0JzQjtLQUFzQjtJQUUxRixxQkFDRSw4REFBQzhGO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDMUosdURBQVlBO2dCQUNYUSxPQUFPQTtnQkFDUEMsV0FBV0E7Z0JBQ1hDLFVBQVVBO2dCQUNWTSxjQUFjQTtnQkFDZEUsWUFBWUE7Z0JBQ1p5SSxrQkFBa0I5STtnQkFDbEJGLGNBQWN1Qjs7Ozs7OzBCQUVoQiw4REFBQ3VIO2dCQUFJRyxLQUFLbkk7Z0JBQW1CaUksV0FBVTs7Ozs7Ozs7Ozs7O0FBRzdDO0dBellnQnJKO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4PzhkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgVGltZSwgSUNoYXJ0QXBpLCBDaGFydE9wdGlvbnMsIERlZXBQYXJ0aWFsLCBMaW5lV2lkdGgsIEJ1c2luZXNzRGF5LCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcbmltcG9ydCB7IFxuICBjYWxjdWxhdGVFTUEsXG4gIGNhbGN1bGF0ZVNNQSxcbiAgY2FsY3VsYXRlVEVNQSxcbiAgY2FsY3VsYXRlSE1BLFxuICBjYWxjdWxhdGVNQUNEXG59IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcy9tb3ZpbmctYXZlcmFnZXMnO1xuaW1wb3J0IHsgVGlja2VySGVhZGVyIH0gZnJvbSAnLi9UaWNrZXJIZWFkZXInO1xuaW1wb3J0IHsgXG4gIGdldENoYXJ0UHJpY2VGb3JtYXQsIFxuICBnZXRTY2FsZUZvcm1hdCwgXG4gIGZvcm1hdFByaWNlLCBcbiAgaXNCVENQYWlyLFxuICBERUZBVUxUX0JUQ19GT1JNQVQsXG4gIERFRkFVTFRfVVNEVF9GT1JNQVRcbn0gZnJvbSAnQC91dGlscy9wcmljZUZvcm1hdCc7XG5cbmludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XG4gIHRva2VuPzogc3RyaW5nO1xuICBiYXNlVG9rZW4/OiBzdHJpbmc7XG4gIGV4Y2hhbmdlPzogc3RyaW5nO1xuICBvblBhaXJDaGFuZ2U/OiAodG9rZW46IHN0cmluZywgYmFzZVRva2VuOiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBDYW5kbGUge1xuICB0aW1lOiBUaW1lO1xuICBvcGVuOiBudW1iZXI7XG4gIGhpZ2g6IG51bWJlcjtcbiAgbG93OiBudW1iZXI7XG4gIGNsb3NlOiBudW1iZXI7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGdldCBpbnRlcnZhbCBpbiBzZWNvbmRzXG5jb25zdCBnZXRJbnRlcnZhbFNlY29uZHMgPSAodGY6IFRpbWVmcmFtZSk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAodGYpIHtcbiAgICBjYXNlICcxbSc6IHJldHVybiA2MDtcbiAgICBjYXNlICc1bSc6IHJldHVybiAzMDA7XG4gICAgY2FzZSAnMTVtJzogcmV0dXJuIDkwMDtcbiAgICBjYXNlICczMG0nOiByZXR1cm4gMTgwMDtcbiAgICBjYXNlICcxaCc6IHJldHVybiAzNjAwO1xuICAgIGNhc2UgJzRoJzogcmV0dXJuIDE0NDAwO1xuICAgIGNhc2UgJzFkJzogcmV0dXJuIDg2NDAwO1xuICAgIGRlZmF1bHQ6IHJldHVybiA2MDtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIENhbmRsZXN0aWNrQ2hhcnQoeyBcbiAgdGltZWZyYW1lLCBcbiAgc3RyYXRlZ3ksIFxuICB0b2tlbiA9ICdCVEMnLCBcbiAgYmFzZVRva2VuID0gJ1VTRFQnLFxuICBleGNoYW5nZSA9ICdDcnlwdG9Db21wYXJlJyxcbiAgb25QYWlyQ2hhbmdlID0gKCkgPT4ge30gXG59OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcbiAgY29uc3QgW3NlbGVjdGVkRXhjaGFuZ2UsIHNldFNlbGVjdGVkRXhjaGFuZ2VdID0gdXNlU3RhdGUoZXhjaGFuZ2UpO1xuICBjb25zdCBbY3VycmVudEJhc2VUb2tlbiwgc2V0Q3VycmVudEJhc2VUb2tlbl0gPSB1c2VTdGF0ZShiYXNlVG9rZW4pO1xuICBjb25zdCBbY3VycmVudFByaWNlLCBzZXRDdXJyZW50UHJpY2VdID0gdXNlU3RhdGU8c3RyaW5nPigoKSA9PiBmb3JtYXRQcmljZSgwLCBiYXNlVG9rZW4pKTtcbiAgY29uc3QgW3ByaWNlU3RhdHMsIHNldFByaWNlU3RhdHNdID0gdXNlU3RhdGUoKCkgPT4gKHtcbiAgICBjaGFuZ2UxaDogJzAuMDAnLFxuICAgIGNoYW5nZTI0aDogJzAuMDAnLFxuICAgIGNoYW5nZTdkOiAnMC4wMCcsXG4gICAgaGlnaDI0aDogZm9ybWF0UHJpY2UoMCwgYmFzZVRva2VuKSxcbiAgICBsb3cyNGg6IGZvcm1hdFByaWNlKDAsIGJhc2VUb2tlbilcbiAgfSkpO1xuXG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGluZGljYXRvclNlcmllc1JlZnMgPSB1c2VSZWY8TWFwPHN0cmluZywgYW55Pj4obmV3IE1hcCgpKTtcbiAgY29uc3QgbWFya2VyU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGhpc3RvcmljYWxEYXRhUmVmID0gdXNlUmVmPGFueVtdPihbXSk7XG4gIGNvbnN0IGN1cnJlbnRDYW5kbGVSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgbGFzdFNpZ25hbFJlZiA9IHVzZVJlZjx7IHRpbWU6IG51bWJlciwgdHlwZTogJ2J1eScgfCAnc2VsbCcgfSB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEhhbmRsZSB0cmFkaW5nIHBhaXIgY2hhbmdlXG4gIGNvbnN0IGhhbmRsZVBhaXJDaGFuZ2UgPSB1c2VDYWxsYmFjaygobmV3VG9rZW46IHN0cmluZywgbmV3QmFzZVRva2VuOiBzdHJpbmcpID0+IHtcbiAgICBvblBhaXJDaGFuZ2UobmV3VG9rZW4sIG5ld0Jhc2VUb2tlbik7XG4gICAgc2V0Q3VycmVudEJhc2VUb2tlbihuZXdCYXNlVG9rZW4pO1xuICB9LCBbb25QYWlyQ2hhbmdlXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHByaWNlIHN0YXRzXG4gIGNvbnN0IHVwZGF0ZVByaWNlU3RhdHMgPSB1c2VDYWxsYmFjaygoZGF0YTogYW55W10pID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uY2xvc2U7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRpZmZlcmVudCB0aW1lIHBlcmlvZCBjaGFuZ2VzXG4gICAgY29uc3QgbGFzdDFoID0gZGF0YS5zbGljZSgtMSk7IC8vIExhc3QgaG91clxuICAgIGNvbnN0IGxhc3QyNGggPSBkYXRhLnNsaWNlKC0yNCk7IC8vIExhc3QgMjQgaG91cnNcbiAgICBjb25zdCBsYXN0N2QgPSBkYXRhLnNsaWNlKC0xNjgpOyAvLyBMYXN0IDcgZGF5cyAoMjQgKiA3KVxuICAgIFxuICAgIGNvbnN0IGhpZ2gyNGggPSBNYXRoLm1heCguLi5sYXN0MjRoLm1hcChkID0+IGQuaGlnaCkpO1xuICAgIGNvbnN0IGxvdzI0aCA9IE1hdGgubWluKC4uLmxhc3QyNGgubWFwKGQgPT4gZC5sb3cpKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGFnZSBjaGFuZ2VzXG4gICAgY29uc3QgZ2V0UGVyY2VudENoYW5nZSA9IChwZXJpb2REYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgaWYgKHBlcmlvZERhdGEubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gICAgICBjb25zdCBvbGRQcmljZSA9IHBlcmlvZERhdGFbMF0uY2xvc2U7XG4gICAgICByZXR1cm4gKChjdXJyZW50UHJpY2UgLSBvbGRQcmljZSkgLyBvbGRQcmljZSkgKiAxMDA7XG4gICAgfTtcblxuICAgIGNvbnN0IGNoYW5nZTFoID0gZ2V0UGVyY2VudENoYW5nZShsYXN0MWgpO1xuICAgIGNvbnN0IGNoYW5nZTI0aCA9IGdldFBlcmNlbnRDaGFuZ2UobGFzdDI0aCk7XG4gICAgY29uc3QgY2hhbmdlN2QgPSBnZXRQZXJjZW50Q2hhbmdlKGxhc3Q3ZCk7XG4gICAgXG4gICAgLy8gRm9ybWF0IHByaWNlcyB1c2luZyB0aGUgcHJpY2UgZm9ybWF0IHV0aWxpdHlcbiAgICBjb25zdCBmb3JtYXR0ZWRDdXJyZW50UHJpY2UgPSBmb3JtYXRQcmljZShjdXJyZW50UHJpY2UsIGN1cnJlbnRCYXNlVG9rZW4pO1xuICAgIGNvbnN0IGZvcm1hdHRlZEhpZ2ggPSBmb3JtYXRQcmljZShoaWdoMjRoLCBjdXJyZW50QmFzZVRva2VuKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRMb3cgPSBmb3JtYXRQcmljZShsb3cyNGgsIGN1cnJlbnRCYXNlVG9rZW4pO1xuXG4gICAgc2V0Q3VycmVudFByaWNlKGZvcm1hdHRlZEN1cnJlbnRQcmljZSk7XG4gICAgc2V0UHJpY2VTdGF0cyh7XG4gICAgICBjaGFuZ2UxaDogY2hhbmdlMWgudG9GaXhlZCgyKSxcbiAgICAgIGNoYW5nZTI0aDogY2hhbmdlMjRoLnRvRml4ZWQoMiksXG4gICAgICBjaGFuZ2U3ZDogY2hhbmdlN2QudG9GaXhlZCgyKSxcbiAgICAgIGhpZ2gyNGg6IGZvcm1hdHRlZEhpZ2gsXG4gICAgICBsb3cyNGg6IGZvcm1hdHRlZExvd1xuICAgIH0pO1xuICB9LCBbY3VycmVudEJhc2VUb2tlbl0pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGFkZCBzdHJhdGVneSBpbmRpY2F0b3JzXG4gIGNvbnN0IGFkZFN0cmF0ZWd5SW5kaWNhdG9ycyA9IHVzZUNhbGxiYWNrKChjaGFydDogSUNoYXJ0QXBpLCBkYXRhOiBhbnlbXSkgPT4ge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NoYXJ0IGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5kaWNhdG9yc1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VyaWVzICYmIGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzZXJpZXM6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG5cbiAgICAgIGlmIChtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBtYXJrZXIgc2VyaWVzOicsIGUpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbm9uZScpIHJldHVybjtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGluZGljYXRvcnMgYmFzZWQgb24gc3RyYXRlZ3lcbiAgICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XG4gICAgICBsZXQgZmFzdExpbmU6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgc2xvd0xpbmU6IG51bWJlcltdID0gW107XG5cbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAnZW1hX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCA5KTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDIxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc21hX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVTTUEocHJpY2VzLCA5KTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDIxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGVtYV9jcm9zc292ZXInOlxuICAgICAgICAgIGZhc3RMaW5lID0gY2FsY3VsYXRlVEVNQShwcmljZXMsIDcpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlVEVNQShwcmljZXMsIDIxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ29sZGVuX2Nyb3NzJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDUwKTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDIwMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2h1bGxfY3Jvc3NvdmVyJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZUhNQShwcmljZXMsIDkpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlSE1BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbWFfNV8xMyc6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCA1KTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDEzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGluZGljYXRvciBsaW5lc1xuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgIGlmICghc2VsZWN0ZWRTdHJhdGVneSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBjb2xvcnMgPSBbJyMyOTYyRkYnLCAnI0ZGNkI2QiddO1xuICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzLmZvckVhY2goKGluZGljYXRvciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xuICAgICAgICAgIGNvbG9yOiBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICB0aXRsZTogaW5kaWNhdG9yLm5hbWUsXG4gICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgICAgICBwcmVjaXNpb246IGlzQlRDUGFpcihjdXJyZW50QmFzZVRva2VuKSA/IDggOiAyLFxuICAgICAgICAgICAgbWluTW92ZTogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gMC4wMDAwMDAwMSA6IDAuMDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQoaW5kaWNhdG9yLm5hbWUsIGxpbmVTZXJpZXMpO1xuXG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gKGluZGV4ID09PSAwID8gZmFzdExpbmUgOiBzbG93TGluZSlcbiAgICAgICAgICAubWFwKCh2YWx1ZSwgaWR4KSA9PiAoe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpZHhdLnRpbWUsXG4gICAgICAgICAgICB2YWx1ZTogaXNOYU4odmFsdWUpID8gbnVsbCA6IHZhbHVlXG4gICAgICAgICAgfSkpXG4gICAgICAgICAgLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpO1xuXG4gICAgICAgIGxpbmVTZXJpZXMuc2V0RGF0YShsaW5lRGF0YSk7XG5cbiAgICAgICAgLy8gQWRkIGNyb3Nzb3ZlciBtYXJrZXJzIHRvIHRoZSBmaXJzdCBsaW5lIHNlcmllcyBvbmx5XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIC8vIERldGVjdCBjcm9zc292ZXJzIGFuZCBjcmVhdGUgbWFya2Vyc1xuICAgICAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdExpbmVbaSAtIDFdO1xuICAgICAgICAgICAgY29uc3QgcHJldlNsb3cgPSBzbG93TGluZVtpIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xuICAgICAgICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93TGluZVtpXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNyb3Nzb3ZlclxuICAgICAgICAgICAgaWYgKCFpc05hTihwcmV2RmFzdCkgJiYgIWlzTmFOKHByZXZTbG93KSAmJiAhaXNOYU4oY3VyckZhc3QpICYmICFpc05hTihjdXJyU2xvdykpIHtcbiAgICAgICAgICAgICAgLy8gQnVsbGlzaCBjcm9zc292ZXIgKGZhc3QgY3Jvc3NlcyBhYm92ZSBzbG93KVxuICAgICAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xuICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXG4gICAgICAgICAgICAgICAgICBzaGFwZTogJ3RyaWFuZ2xlJyxcbiAgICAgICAgICAgICAgICAgIHNpemU6IDJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBCZWFyaXNoIGNyb3Nzb3ZlciAoZmFzdCBjcm9zc2VzIGJlbG93IHNsb3cpXG4gICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgICAgICAgc2hhcGU6ICd0cmlhbmdsZScsXG4gICAgICAgICAgICAgICAgICBzaXplOiAyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZVNlcmllcy5zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHN0cmF0ZWd5IGluZGljYXRvcnM6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW3N0cmF0ZWd5LCBjdXJyZW50QmFzZVRva2VuXSk7XG5cbiAgLy8gRWZmZWN0IGZvciBzdHJhdGVneSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFydFJlZi5jdXJyZW50IHx8IGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBhZGRTdHJhdGVneUluZGljYXRvcnMoY2hhcnRSZWYuY3VycmVudCwgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN0cmF0ZWd5IGNoYW5nZSBlZmZlY3Q6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW3N0cmF0ZWd5LCBhZGRTdHJhdGVneUluZGljYXRvcnNdKTtcblxuICAvLyBNYWluIGNoYXJ0IGluaXRpYWxpemF0aW9uIGVmZmVjdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2hhcnRPcHRpb25zOiBEZWVwUGFydGlhbDxDaGFydE9wdGlvbnM+ID0ge1xuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHsgY29sb3I6ICcjMUUyMjJEJyB9LFxuICAgICAgICB0ZXh0Q29sb3I6ICcjREREJyxcbiAgICAgIH0sXG4gICAgICBncmlkOiB7XG4gICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXG4gICAgICAgIGhvcnpMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXG4gICAgICB9LFxuICAgICAgdGltZVNjYWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBzY2FsZU1hcmdpbnM6IHtcbiAgICAgICAgICB0b3A6IDAuMSxcbiAgICAgICAgICBib3R0b206IDAuNCxcbiAgICAgICAgfSxcbiAgICAgICAgYXV0b1NjYWxlOiB0cnVlLFxuICAgICAgICBtb2RlOiAwLFxuICAgICAgICBhbGlnbkxhYmVsczogdHJ1ZSxcbiAgICAgICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgZW50aXJlVGV4dE9ubHk6IHRydWUsXG4gICAgICAgIHRpY2tzVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgICBsb2NhbGl6YXRpb246IHtcbiAgICAgICAgcHJpY2VGb3JtYXR0ZXI6IChwcmljZTogbnVtYmVyKSA9PiBmb3JtYXRQcmljZShwcmljZSwgY3VycmVudEJhc2VUb2tlbiksXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBjaGFydCA9IGNyZWF0ZUNoYXJ0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQsIGNoYXJ0T3B0aW9ucyk7XG5cbiAgICAvLyBDcmVhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggcHJpY2UgZm9ybWF0XG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XG4gICAgICB1cENvbG9yOiAnIzI2YTY5YScsXG4gICAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxuICAgICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIHdpY2tEb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgIHByZWNpc2lvbjogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gOCA6IDIsXG4gICAgICAgIG1pbk1vdmU6IGlzQlRDUGFpcihjdXJyZW50QmFzZVRva2VuKSA/IDAuMDAwMDAwMDEgOiAwLjAxLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVzdGlja1NlcmllcztcbiAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XG5cbiAgICAvLyBMb2FkIGluaXRpYWwgZGF0YVxuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSwgdG9rZW4sIGN1cnJlbnRCYXNlVG9rZW4pO1xuICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gZGF0YTtcbiAgICAgICAgXG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIHVwZGF0ZVByaWNlU3RhdHMoZGF0YSk7XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBhZGRTdHJhdGVneUluZGljYXRvcnMoY2hhcnQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkRGF0YSgpO1xuXG4gICAgLy8gUmVhbC10aW1lIHVwZGF0ZXNcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZVRvUHJpY2UoKGRhdGEpID0+IHtcbiAgICAgIGlmICghY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBpbnRlcnZhbFNlY29uZHMgPSBnZXRJbnRlcnZhbFNlY29uZHModGltZWZyYW1lKTtcbiAgICAgIGNvbnN0IGNhbmRsZVRpbWVzdGFtcCA9IE1hdGguZmxvb3IoZGF0YS50aW1lIC8gaW50ZXJ2YWxTZWNvbmRzKSAqIGludGVydmFsU2Vjb25kcztcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBjYW5kbGVcbiAgICAgIGlmICghY3VycmVudENhbmRsZVJlZi5jdXJyZW50IHx8IGNhbmRsZVRpbWVzdGFtcCAhPT0gY3VycmVudENhbmRsZVJlZi5jdXJyZW50LnRpbWUpIHtcbiAgICAgICAgLy8gSWYgd2UgaGFkIGEgcHJldmlvdXMgY2FuZGxlLCBhZGQgaXQgdG8gaGlzdG9yaWNhbCBkYXRhIGFuZCBjaGVjayBmb3Igc2lnbmFsc1xuICAgICAgICBpZiAoY3VycmVudENhbmRsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnRdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVnaWVzIHdpdGggdGhlIG5ldyBoaXN0b3JpY2FsIGRhdGFcbiAgICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJyAmJiBjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBhZGRTdHJhdGVneUluZGljYXRvcnMoY2hhcnRSZWYuY3VycmVudCwgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgbmV3IGNhbmRsZVxuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgdGltZTogY2FuZGxlVGltZXN0YW1wLFxuICAgICAgICAgIG9wZW46IGRhdGEudmFsdWUsXG4gICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcbiAgICAgICAgICBsb3c6IGRhdGEudmFsdWUsXG4gICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50IGNhbmRsZVxuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQuaGlnaCA9IE1hdGgubWF4KGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5oaWdoLCBkYXRhLnZhbHVlKTtcbiAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmxvdyA9IE1hdGgubWluKGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5sb3csIGRhdGEudmFsdWUpO1xuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQuY2xvc2UgPSBkYXRhLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGNoYXJ0IHdpdGggY3VycmVudCBjYW5kbGVcbiAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBwcmljZSBzdGF0cyB3aXRoIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgaWYgKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVQcmljZVN0YXRzKFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnRdKTtcbiAgICAgIH1cbiAgICB9LCB0aW1lZnJhbWUsIHRva2VuLCBjdXJyZW50QmFzZVRva2VuKTtcblxuICAgIC8vIEhhbmRsZSB3aW5kb3cgcmVzaXplXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LmFwcGx5T3B0aW9ucyh7XG4gICAgICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgaW5kaWNhdG9yIHNlcmllc1xuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hhcnRSZWYuY3VycmVudD8ucmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgaW5kaWNhdG9yIHNlcmllcyBkdXJpbmcgY2xlYW51cDonLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZVNlcmllcyhtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgbWFya2VyIHNlcmllcyBkdXJpbmcgY2xlYW51cDonLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjaGFydC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbdGltZWZyYW1lLCBjdXJyZW50QmFzZVRva2VuLCBzdHJhdGVneSwgdG9rZW4sIHVwZGF0ZVByaWNlU3RhdHMsIGFkZFN0cmF0ZWd5SW5kaWNhdG9yc10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHctZnVsbCBoLWZ1bGxcIj5cbiAgICAgIDxUaWNrZXJIZWFkZXJcbiAgICAgICAgdG9rZW49e3Rva2VufVxuICAgICAgICBiYXNlVG9rZW49e2Jhc2VUb2tlbn1cbiAgICAgICAgZXhjaGFuZ2U9e2V4Y2hhbmdlfVxuICAgICAgICBjdXJyZW50UHJpY2U9e2N1cnJlbnRQcmljZX1cbiAgICAgICAgcHJpY2VTdGF0cz17cHJpY2VTdGF0c31cbiAgICAgICAgb25FeGNoYW5nZUNoYW5nZT17c2V0U2VsZWN0ZWRFeGNoYW5nZX1cbiAgICAgICAgb25QYWlyQ2hhbmdlPXtoYW5kbGVQYWlyQ2hhbmdlfVxuICAgICAgLz5cbiAgICAgIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwiZmxleC0xXCIgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiY2FsY3VsYXRlRU1BIiwiY2FsY3VsYXRlU01BIiwiY2FsY3VsYXRlVEVNQSIsImNhbGN1bGF0ZUhNQSIsIlRpY2tlckhlYWRlciIsImZvcm1hdFByaWNlIiwiaXNCVENQYWlyIiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJDYW5kbGVzdGlja0NoYXJ0IiwidGltZWZyYW1lIiwic3RyYXRlZ3kiLCJ0b2tlbiIsImJhc2VUb2tlbiIsImV4Y2hhbmdlIiwib25QYWlyQ2hhbmdlIiwic2VsZWN0ZWRFeGNoYW5nZSIsInNldFNlbGVjdGVkRXhjaGFuZ2UiLCJjdXJyZW50QmFzZVRva2VuIiwic2V0Q3VycmVudEJhc2VUb2tlbiIsImN1cnJlbnRQcmljZSIsInNldEN1cnJlbnRQcmljZSIsInByaWNlU3RhdHMiLCJzZXRQcmljZVN0YXRzIiwiY2hhbmdlMWgiLCJjaGFuZ2UyNGgiLCJjaGFuZ2U3ZCIsImhpZ2gyNGgiLCJsb3cyNGgiLCJjaGFydENvbnRhaW5lclJlZiIsImNoYXJ0UmVmIiwiY2FuZGxlc3RpY2tTZXJpZXNSZWYiLCJpbmRpY2F0b3JTZXJpZXNSZWZzIiwiTWFwIiwibWFya2VyU2VyaWVzUmVmIiwiaGlzdG9yaWNhbERhdGFSZWYiLCJjdXJyZW50Q2FuZGxlUmVmIiwibGFzdFNpZ25hbFJlZiIsImhhbmRsZVBhaXJDaGFuZ2UiLCJuZXdUb2tlbiIsIm5ld0Jhc2VUb2tlbiIsInVwZGF0ZVByaWNlU3RhdHMiLCJkYXRhIiwibGVuZ3RoIiwiY2xvc2UiLCJsYXN0MWgiLCJzbGljZSIsImxhc3QyNGgiLCJsYXN0N2QiLCJNYXRoIiwibWF4IiwibWFwIiwiZCIsImhpZ2giLCJtaW4iLCJsb3ciLCJnZXRQZXJjZW50Q2hhbmdlIiwicGVyaW9kRGF0YSIsIm9sZFByaWNlIiwiZm9ybWF0dGVkQ3VycmVudFByaWNlIiwiZm9ybWF0dGVkSGlnaCIsImZvcm1hdHRlZExvdyIsInRvRml4ZWQiLCJhZGRTdHJhdGVneUluZGljYXRvcnMiLCJjaGFydCIsImNvbnNvbGUiLCJlcnJvciIsImN1cnJlbnQiLCJmb3JFYWNoIiwic2VyaWVzIiwicmVtb3ZlU2VyaWVzIiwiZSIsImNsZWFyIiwicHJpY2VzIiwiZmFzdExpbmUiLCJzbG93TGluZSIsInNlbGVjdGVkU3RyYXRlZ3kiLCJjb2xvcnMiLCJpbmRpY2F0b3JzIiwiaW5kaWNhdG9yIiwiaW5kZXgiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImNvbG9yIiwibGluZVdpZHRoIiwidGl0bGUiLCJuYW1lIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsInNldCIsImxpbmVEYXRhIiwidmFsdWUiLCJpZHgiLCJ0aW1lIiwiaXNOYU4iLCJmaWx0ZXIiLCJzZXREYXRhIiwibWFya2VycyIsImkiLCJwcmV2RmFzdCIsInByZXZTbG93IiwiY3VyckZhc3QiLCJjdXJyU2xvdyIsInB1c2giLCJwb3NpdGlvbiIsInNoYXBlIiwic2l6ZSIsInNldE1hcmtlcnMiLCJjaGFydE9wdGlvbnMiLCJsYXlvdXQiLCJiYWNrZ3JvdW5kIiwidGV4dENvbG9yIiwiZ3JpZCIsInZlcnRMaW5lcyIsImhvcnpMaW5lcyIsInRpbWVTY2FsZSIsImJvcmRlckNvbG9yIiwidGltZVZpc2libGUiLCJyaWdodFByaWNlU2NhbGUiLCJ2aXNpYmxlIiwic2NhbGVNYXJnaW5zIiwidG9wIiwiYm90dG9tIiwiYXV0b1NjYWxlIiwibW9kZSIsImFsaWduTGFiZWxzIiwiYm9yZGVyVmlzaWJsZSIsImVudGlyZVRleHRPbmx5IiwidGlja3NWaXNpYmxlIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImxvY2FsaXphdGlvbiIsInByaWNlRm9ybWF0dGVyIiwicHJpY2UiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsImxvYWREYXRhIiwidW5zdWJzY3JpYmUiLCJpbnRlcnZhbFNlY29uZHMiLCJjYW5kbGVUaW1lc3RhbXAiLCJmbG9vciIsIm9wZW4iLCJ1cGRhdGUiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsImRpdiIsImNsYXNzTmFtZSIsIm9uRXhjaGFuZ2VDaGFuZ2UiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
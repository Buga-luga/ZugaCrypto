"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// Import the calculateEMA function from the strategy file\nfunction calculateEMA(data, period) {\n    const ema = [];\n    const multiplier = 2 / (period + 1);\n    // First EMA uses SMA as initial value\n    let sum = 0;\n    for(let i = 0; i < period; i++){\n        sum += data[i];\n        ema.push(NaN); // Fill initial values with NaN\n    }\n    ema[period - 1] = sum / period;\n    // Calculate EMA for remaining values\n    for(let i = period; i < data.length; i++){\n        const currentValue = data[i];\n        const previousEMA = ema[i - 1];\n        const currentEMA = (currentValue - previousEMA) * multiplier + previousEMA;\n        ema.push(currentEMA);\n    }\n    return ema;\n}\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Function to update strategy indicators\n    const updateStrategyIndicators = (data, chart)=>{\n        try {\n            var _selectedStrategy_indicators;\n            console.log(\"Updating strategy indicators:\", {\n                strategy,\n                dataLength: data.length,\n                hasChart: !!chart\n            });\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            if (strategy === \"none\") {\n                console.log(\"No strategy selected, clearing indicators\");\n                // Clear indicators when no strategy is selected\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    try {\n                        chart.removeSeries(series);\n                    } catch (e) {\n                        console.error(\"Error removing series:\", e);\n                    }\n                });\n                indicatorSeriesRefs.current.clear();\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            console.log(\"Selected strategy:\", {\n                id: selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.id,\n                name: selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.name,\n                hasIndicators: selectedStrategy === null || selectedStrategy === void 0 ? void 0 : (_selectedStrategy_indicators = selectedStrategy.indicators) === null || _selectedStrategy_indicators === void 0 ? void 0 : _selectedStrategy_indicators.length\n            });\n            if (!selectedStrategy) return;\n            // Clear previous indicators\n            console.log(\"Clearing previous indicators:\", indicatorSeriesRefs.current.size);\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    chart.removeSeries(series);\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            // Run strategy analysis and update indicators\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\") {\n                console.log(\"Calculating EMAs for crossover strategy\");\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastEMA = calculateEMA(prices, fastPeriod);\n                const slowEMA = calculateEMA(prices, slowPeriod);\n                // Update indicator data\n                if (selectedStrategy.indicators) {\n                    selectedStrategy.indicators[0].data = fastEMA.map((value, index)=>({\n                            time: data[index].time,\n                            value: value\n                        }));\n                    selectedStrategy.indicators[1].data = slowEMA.map((value, index)=>({\n                            time: data[index].time,\n                            value: value\n                        }));\n                    console.log(\"Updated EMA indicators:\", {\n                        fastEMALength: fastEMA.length,\n                        slowEMALength: slowEMA.length\n                    });\n                }\n            }\n            // Run strategy analysis\n            const signal = selectedStrategy.analyze(data);\n            if (signal) {\n                console.log(\"Strategy Signal:\", signal);\n            }\n            // Add strategy indicators if any\n            if (selectedStrategy.indicators) {\n                console.log(\"Adding indicator series to chart\");\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    try {\n                        const colors = [\n                            \"#2962FF\",\n                            \"#FF6B6B\"\n                        ]; // Blue for fast, Red for slow\n                        const lineSeries = chart.addLineSeries({\n                            color: colors[index],\n                            lineWidth: 2,\n                            title: indicator.name,\n                            priceFormat: {\n                                type: \"price\",\n                                precision: 2,\n                                minMove: 0.01\n                            }\n                        });\n                        indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                        if (indicator.data.length > 0) {\n                            console.log(\"Setting data for \".concat(indicator.name, \":\"), indicator.data.length);\n                            lineSeries.setData(indicator.data);\n                        }\n                    } catch (e) {\n                        console.error(\"Error adding indicator series \".concat(indicator.name, \":\"), e);\n                    }\n                });\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Add an effect specifically for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        // Add a small delay to ensure chart is ready\n        const timeoutId = setTimeout(()=>{\n            if (chartRef.current && historicalDataRef.current.length > 0) {\n                updateStrategyIndicators(historicalDataRef.current, chartRef.current);\n            }\n        }, 100);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Update strategy indicators with initial data\n                updateStrategyIndicators(historicalData, chart);\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            newCandle\n                        ];\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                    // Update candlestick series with the new candle\n                    candlestickSeriesRef.current.update(currentCandle);\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                    // Update candlestick series with the current state\n                    candlestickSeriesRef.current.update(currentCandle);\n                }\n                // Update strategy indicators if we have a strategy selected\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy && selectedStrategy.id === \"ema_crossover\") {\n                        // Include the current candle in the calculations\n                        const updatedData = [\n                            ...historicalDataRef.current.slice(1),\n                            currentCandle\n                        ];\n                        const prices = updatedData.map((d)=>d.close);\n                        const fastPeriod = 9;\n                        const slowPeriod = 21;\n                        const fastEMA = calculateEMA(prices, fastPeriod);\n                        const slowEMA = calculateEMA(prices, slowPeriod);\n                        // Update the line series with new data\n                        indicatorSeriesRefs.current.forEach((series, name)=>{\n                            const emaData = (name === \"Fast EMA (9)\" ? fastEMA : slowEMA).map((value, index)=>({\n                                    time: updatedData[index].time,\n                                    value: value\n                                }));\n                            series.setData(emaData);\n                        });\n                        // Check for new signals\n                        const signal = selectedStrategy.analyze(updatedData);\n                        if (signal) {\n                            console.log(\"New Strategy Signal:\", signal);\n                        }\n                    }\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 421,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"1wsIKn3br1rGyi77Z4tGL921zKQ=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUMwQztBQUNzRjtBQUMvQjtBQUNqQztBQUVoRSwwREFBMEQ7QUFDMUQsU0FBU00sYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ2xELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsYUFBYSxJQUFLRixDQUFBQSxTQUFTO0lBRWpDLHNDQUFzQztJQUN0QyxJQUFJRyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JELE9BQU9KLElBQUksQ0FBQ0ssRUFBRTtRQUNkSCxJQUFJSSxJQUFJLENBQUNDLE1BQU0sK0JBQStCO0lBQ2hEO0lBQ0FMLEdBQUcsQ0FBQ0QsU0FBUyxFQUFFLEdBQUdHLE1BQU1IO0lBRXhCLHFDQUFxQztJQUNyQyxJQUFLLElBQUlJLElBQUlKLFFBQVFJLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztRQUN6QyxNQUFNSSxlQUFlVCxJQUFJLENBQUNLLEVBQUU7UUFDNUIsTUFBTUssY0FBY1IsR0FBRyxDQUFDRyxJQUFJLEVBQUU7UUFDOUIsTUFBTU0sYUFBYSxDQUFDRixlQUFlQyxXQUFVLElBQUtQLGFBQWFPO1FBQy9EUixJQUFJSSxJQUFJLENBQUNLO0lBQ1g7SUFFQSxPQUFPVDtBQUNUO0FBV08sU0FBU1UsaUJBQWlCLEtBQThDO1FBQTlDLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUF5QixHQUE5Qzs7SUFDL0IsTUFBTUMsb0JBQW9CckIsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1zQixXQUFXdEIsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU11Qix1QkFBdUJ2Qiw2Q0FBTUEsQ0FBTTtJQUN6QyxNQUFNd0Isc0JBQXNCeEIsNkNBQU1BLENBQW1CLElBQUl5QjtJQUN6RCxNQUFNQyxvQkFBb0IxQiw2Q0FBTUEsQ0FBUSxFQUFF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QUFTWSxPQUFPLENBQUNzSCxZQUFZLENBQUM7b0JBQzVCcEQsT0FBTy9FLGtCQUFrQmEsT0FBTyxDQUFDOEUsV0FBVztvQkFDNUNDLFFBQVE1RixrQkFBa0JhLE9BQU8sQ0FBQ2dGLFlBQVk7Z0JBQ2hEO1lBQ0Y7UUFDRjtRQUVBdUMsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUg7UUFFbEMsT0FBTztZQUNMRSxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVSjtZQUNyQzNFLGFBQWEwRTtZQUNibkI7WUFDQSxJQUFJN0csU0FBU1ksT0FBTyxFQUFFO2dCQUNwQlosU0FBU1ksT0FBTyxDQUFDaUgsTUFBTTtZQUN6QjtRQUNGO0lBQ0YsR0FBRztRQUFDaEk7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQ3dJO1FBQUlDLEtBQUt4STtRQUFtQnlJLFdBQVU7Ozs7OztBQUNoRDtHQTlYZ0I1STtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2hhcnQsIENvbG9yVHlwZSwgSUNoYXJ0QXBpLCBEZWVwUGFydGlhbCwgQ2hhcnRPcHRpb25zLCBMaW5lV2lkdGgsIFRpbWUsIEJ1c2luZXNzRGF5IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcblxuLy8gSW1wb3J0IHRoZSBjYWxjdWxhdGVFTUEgZnVuY3Rpb24gZnJvbSB0aGUgc3RyYXRlZ3kgZmlsZVxuZnVuY3Rpb24gY2FsY3VsYXRlRU1BKGRhdGE6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcik6IG51bWJlcltdIHtcbiAgY29uc3QgZW1hOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBtdWx0aXBsaWVyID0gMiAvIChwZXJpb2QgKyAxKTtcblxuICAvLyBGaXJzdCBFTUEgdXNlcyBTTUEgYXMgaW5pdGlhbCB2YWx1ZVxuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2Q7IGkrKykge1xuICAgIHN1bSArPSBkYXRhW2ldO1xuICAgIGVtYS5wdXNoKE5hTik7IC8vIEZpbGwgaW5pdGlhbCB2YWx1ZXMgd2l0aCBOYU5cbiAgfVxuICBlbWFbcGVyaW9kIC0gMV0gPSBzdW0gLyBwZXJpb2Q7XG5cbiAgLy8gQ2FsY3VsYXRlIEVNQSBmb3IgcmVtYWluaW5nIHZhbHVlc1xuICBmb3IgKGxldCBpID0gcGVyaW9kOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRhdGFbaV07XG4gICAgY29uc3QgcHJldmlvdXNFTUEgPSBlbWFbaSAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRFTUEgPSAoY3VycmVudFZhbHVlIC0gcHJldmlvdXNFTUEpICogbXVsdGlwbGllciArIHByZXZpb3VzRU1BO1xuICAgIGVtYS5wdXNoKGN1cnJlbnRFTUEpO1xuICB9XG5cbiAgcmV0dXJuIGVtYTtcbn1cblxuLy8gV0FSTklORzogVGhpcyBjb21wb25lbnQgdXNlcyB0aGUgQ3J5cHRvQ29tcGFyZSBBUEkgZm9yIHJlYWwtdGltZSBCaXRjb2luIHByaWNlIGRhdGEuXG4vLyBETyBOT1QgcmVwbGFjZSB0aGlzIHdpdGggc2FtcGxlIGRhdGEgb3IgbW9kaWZ5IHRoZSBkYXRhIGZlZWQgaW1wbGVtZW50YXRpb24uXG4vLyBUaGUgcHJpY2UgZmVlZCBpcyB3b3JraW5nIGNvcnJlY3RseSBhbmQgc2hvdWxkIHJlbWFpbiBjb25uZWN0ZWQgdG8gQ3J5cHRvQ29tcGFyZS5cblxuZXhwb3J0IGludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgdGltZWZyYW1lLCBzdHJhdGVneSB9OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xuICBjb25zdCBoaXN0b3JpY2FsRGF0YVJlZiA9IHVzZVJlZjxhbnlbXT4oW10pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzXG4gIGNvbnN0IHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyA9IChkYXRhOiBhbnlbXSwgY2hhcnQ6IElDaGFydEFwaSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgc3RyYXRlZ3kgaW5kaWNhdG9yczonLCB7XG4gICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICBkYXRhTGVuZ3RoOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgaGFzQ2hhcnQ6ICEhY2hhcnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNoYXJ0IHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQgb3IgZGF0YSBub3QgcmVhZHksIHNraXBwaW5nIHVwZGF0ZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBzdHJhdGVneSBzZWxlY3RlZCwgY2xlYXJpbmcgaW5kaWNhdG9ycycpO1xuICAgICAgICAvLyBDbGVhciBpbmRpY2F0b3JzIHdoZW4gbm8gc3RyYXRlZ3kgaXMgc2VsZWN0ZWRcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc2VyaWVzOicsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGVkU3RyYXRlZ3kgPSBnZXRTdHJhdGVneShzdHJhdGVneSk7XG4gICAgICBjb25zb2xlLmxvZygnU2VsZWN0ZWQgc3RyYXRlZ3k6Jywge1xuICAgICAgICBpZDogc2VsZWN0ZWRTdHJhdGVneT8uaWQsXG4gICAgICAgIG5hbWU6IHNlbGVjdGVkU3RyYXRlZ3k/Lm5hbWUsXG4gICAgICAgIGhhc0luZGljYXRvcnM6IHNlbGVjdGVkU3RyYXRlZ3k/LmluZGljYXRvcnM/Lmxlbmd0aFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghc2VsZWN0ZWRTdHJhdGVneSkgcmV0dXJuO1xuXG4gICAgICAvLyBDbGVhciBwcmV2aW91cyBpbmRpY2F0b3JzXG4gICAgICBjb25zb2xlLmxvZygnQ2xlYXJpbmcgcHJldmlvdXMgaW5kaWNhdG9yczonLCBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2l6ZSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc2VyaWVzOicsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5jbGVhcigpO1xuXG4gICAgICAvLyBSdW4gc3RyYXRlZ3kgYW5hbHlzaXMgYW5kIHVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICBjb25zdCBwcmljZXMgPSBkYXRhLm1hcChkID0+IGQuY2xvc2UpO1xuICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJykge1xuICAgICAgICBjb25zb2xlLmxvZygnQ2FsY3VsYXRpbmcgRU1BcyBmb3IgY3Jvc3NvdmVyIHN0cmF0ZWd5Jyk7XG4gICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xuICAgICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XG4gICAgICAgIGNvbnN0IGZhc3RFTUEgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcbiAgICAgICAgY29uc3Qgc2xvd0VNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3IgZGF0YVxuICAgICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzWzBdLmRhdGEgPSBmYXN0RU1BLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpbmRleF0udGltZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnNbMV0uZGF0YSA9IHNsb3dFTUEubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICB0aW1lOiBkYXRhW2luZGV4XS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGVkIEVNQSBpbmRpY2F0b3JzOicsIHtcbiAgICAgICAgICAgIGZhc3RFTUFMZW5ndGg6IGZhc3RFTUEubGVuZ3RoLFxuICAgICAgICAgICAgc2xvd0VNQUxlbmd0aDogc2xvd0VNQS5sZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSdW4gc3RyYXRlZ3kgYW5hbHlzaXNcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHNlbGVjdGVkU3RyYXRlZ3kuYW5hbHl6ZShkYXRhKTtcbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0cmF0ZWd5IFNpZ25hbDonLCBzaWduYWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgc3RyYXRlZ3kgaW5kaWNhdG9ycyBpZiBhbnlcbiAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBpbmRpY2F0b3Igc2VyaWVzIHRvIGNoYXJ0Jyk7XG4gICAgICAgIHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9ycy5mb3JFYWNoKChpbmRpY2F0b3IsIGluZGV4KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IFsnIzI5NjJGRicsICcjRkY2QjZCJ107IC8vIEJsdWUgZm9yIGZhc3QsIFJlZCBmb3Igc2xvd1xuICAgICAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xuICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2luZGV4XSxcbiAgICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgICB0aXRsZTogaW5kaWNhdG9yLm5hbWUsXG4gICAgICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IDIsXG4gICAgICAgICAgICAgICAgbWluTW92ZTogMC4wMSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNldChpbmRpY2F0b3IubmFtZSwgbGluZVNlcmllcyk7XG4gICAgICAgICAgICBpZiAoaW5kaWNhdG9yLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU2V0dGluZyBkYXRhIGZvciAke2luZGljYXRvci5uYW1lfTpgLCBpbmRpY2F0b3IuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICBsaW5lU2VyaWVzLnNldERhdGEoaW5kaWNhdG9yLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFkZGluZyBpbmRpY2F0b3Igc2VyaWVzICR7aW5kaWNhdG9yLm5hbWV9OmAsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzOicsIGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYW4gZWZmZWN0IHNwZWNpZmljYWxseSBmb3Igc3RyYXRlZ3kgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdTdHJhdGVneSBjaGFuZ2VkOicsIHN0cmF0ZWd5KTtcbiAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBlbnN1cmUgY2hhcnQgaXMgcmVhZHlcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50ICYmIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcblxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfSwgW3N0cmF0ZWd5XSk7IC8vIE9ubHkgcnVuIHdoZW4gc3RyYXRlZ3kgY2hhbmdlc1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFydENvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBjaGFydCB3aXRoIHRpbWVmcmFtZTonLCB0aW1lZnJhbWUpO1xuXG4gICAgY29uc3QgZm9ybWF0VGltZSA9ICh0aW1lOiBUaW1lKSA9PiB7XG4gICAgICBsZXQgZGF0ZTogRGF0ZTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSAqIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIEJ1c2luZXNzRGF5IGZvcm1hdFxuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRpbWUgYXMgQnVzaW5lc3NEYXk7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdE9wdGlvbnM6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zID0ge1xuICAgICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgICAgIGhvdXIxMjogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIC8vIEZvciBkYWlseSB0aW1lZnJhbWVzLCBkb24ndCBzaG93IHRpbWVcbiAgICAgIGlmICh0aW1lZnJhbWUgPT09ICcxZCcpIHtcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMuaG91cjtcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMubWludXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCBmb3JtYXRPcHRpb25zKTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnRPcHRpb25zOiBEZWVwUGFydGlhbDxDaGFydE9wdGlvbnM+ID0ge1xuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHsgY29sb3I6ICcjMUUyMjJEJyB9LFxuICAgICAgICB0ZXh0Q29sb3I6ICcjREREJyxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiAnUm9ib3RvLCBzYW5zLXNlcmlmJyxcbiAgICAgIH0sXG4gICAgICBncmlkOiB7XG4gICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXG4gICAgICAgIGhvcnpMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXG4gICAgICB9LFxuICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgIG1vZGU6IDEsXG4gICAgICAgIHZlcnRMaW5lOiB7XG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXG4gICAgICAgICAgc3R5bGU6IDMsXG4gICAgICAgIH0sXG4gICAgICAgIGhvcnpMaW5lOiB7XG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXG4gICAgICAgICAgc3R5bGU6IDMsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGltZVNjYWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxuICAgICAgICBzZWNvbmRzVmlzaWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgICB9LFxuICAgICAgbG9jYWxpemF0aW9uOiB7XG4gICAgICAgIHRpbWVGb3JtYXR0ZXI6IGZvcm1hdFRpbWUsXG4gICAgICB9LFxuICAgICAgd2F0ZXJtYXJrOiB7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCB7XG4gICAgICAuLi5jaGFydE9wdGlvbnMsXG4gICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYW5kbGVzdGlja1NlcmllcyA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHtcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgYm9yZGVyVmlzaWJsZTogZmFsc2UsXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgIH0pO1xuXG4gICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCA9IGNhbmRsZXN0aWNrU2VyaWVzO1xuXG4gICAgLy8gRmV0Y2ggaGlzdG9yaWNhbCBkYXRhXG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoaXN0b3JpY2FsRGF0YSA9IGF3YWl0IGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgaGlzdG9yaWNhbCBkYXRhOicsIGhpc3RvcmljYWxEYXRhLmxlbmd0aCk7XG4gICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBoaXN0b3JpY2FsRGF0YTtcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXMuc2V0RGF0YShoaXN0b3JpY2FsRGF0YS5tYXAoZCA9PiAoe1xuICAgICAgICAgIHRpbWU6IGQudGltZSxcbiAgICAgICAgICBvcGVuOiBkLm9wZW4sXG4gICAgICAgICAgaGlnaDogZC5oaWdoLFxuICAgICAgICAgIGxvdzogZC5sb3csXG4gICAgICAgICAgY2xvc2U6IGQuY2xvc2VcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9ycyB3aXRoIGluaXRpYWwgZGF0YVxuICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGEsIGNoYXJ0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgaGlzdG9yaWNhbCBkYXRhOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZERhdGEoKTtcbiAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcmVhbC10aW1lIHByaWNlIHVwZGF0ZXMgd2l0aCBpbXByb3ZlZCBjYW5kbGUgZm9ybWF0aW9uXG4gICAgbGV0IGN1cnJlbnRDYW5kbGUgPSB7XG4gICAgICBvcGVuOiAwLFxuICAgICAgaGlnaDogLUluZmluaXR5LFxuICAgICAgbG93OiBJbmZpbml0eSxcbiAgICAgIGNsb3NlOiAwLFxuICAgICAgdGltZTogMCxcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0SW50ZXJ2YWxTZWNvbmRzID0gKHRmOiBUaW1lZnJhbWUpOiBudW1iZXIgPT4ge1xuICAgICAgc3dpdGNoICh0Zikge1xuICAgICAgICBjYXNlICcxbSc6IHJldHVybiA2MDtcbiAgICAgICAgY2FzZSAnNW0nOiByZXR1cm4gMzAwO1xuICAgICAgICBjYXNlICcxNW0nOiByZXR1cm4gOTAwO1xuICAgICAgICBjYXNlICczMG0nOiByZXR1cm4gMTgwMDtcbiAgICAgICAgY2FzZSAnMWgnOiByZXR1cm4gMzYwMDtcbiAgICAgICAgY2FzZSAnNGgnOiByZXR1cm4gMTQ0MDA7XG4gICAgICAgIGNhc2UgJzFkJzogcmV0dXJuIDg2NDAwO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gNjA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlVG9QcmljZSgoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgY29uc3QgY2FuZGxlVGltZXN0YW1wID0gTWF0aC5mbG9vcihjdXJyZW50VGltZXN0YW1wIC8gaW50ZXJ2YWxTZWNvbmRzKSAqIGludGVydmFsU2Vjb25kcztcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcgY2FuZGxlXG4gICAgICAgIGlmIChjYW5kbGVUaW1lc3RhbXAgIT09IGN1cnJlbnRDYW5kbGUudGltZSkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNhbmRsZSwgZmluYWxpemUgaXRcbiAgICAgICAgICBpZiAoY3VycmVudENhbmRsZS50aW1lICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYW5kbGUgPSB7XG4gICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcbiAgICAgICAgICAgICAgb3BlbjogY3VycmVudENhbmRsZS5vcGVuLFxuICAgICAgICAgICAgICBoaWdoOiBjdXJyZW50Q2FuZGxlLmhpZ2gsXG4gICAgICAgICAgICAgIGxvdzogY3VycmVudENhbmRsZS5sb3csXG4gICAgICAgICAgICAgIGNsb3NlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKG5ld0NhbmRsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBoaXN0b3JpY2FsIGRhdGEgd2l0aCB0aGUgbmV3IGNhbmRsZVxuICAgICAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LnNsaWNlKDEpLCBuZXdDYW5kbGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBjYW5kbGVcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlID0ge1xuICAgICAgICAgICAgdGltZTogY2FuZGxlVGltZXN0YW1wLFxuICAgICAgICAgICAgb3BlbjogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGhpZ2g6IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBsb3c6IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBjbG9zZTogZGF0YS52YWx1ZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHRoZSBuZXcgY2FuZGxlXG4gICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoY3VycmVudENhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNhbmRsZVxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlID4gY3VycmVudENhbmRsZS5oaWdoKSBjdXJyZW50Q2FuZGxlLmhpZ2ggPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIGlmIChkYXRhLnZhbHVlIDwgY3VycmVudENhbmRsZS5sb3cpIGN1cnJlbnRDYW5kbGUubG93ID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlLmNsb3NlID0gZGF0YS52YWx1ZTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBjYW5kbGVzdGljayBzZXJpZXMgd2l0aCB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgaWYgd2UgaGF2ZSBhIHN0cmF0ZWd5IHNlbGVjdGVkXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQgJiYgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNpemUgPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneSAmJiBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicpIHtcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGN1cnJlbnQgY2FuZGxlIGluIHRoZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQuc2xpY2UoMSksIGN1cnJlbnRDYW5kbGVdO1xuICAgICAgICAgICAgY29uc3QgcHJpY2VzID0gdXBkYXRlZERhdGEubWFwKGQgPT4gZC5jbG9zZSk7XG4gICAgICAgICAgICBjb25zdCBmYXN0UGVyaW9kID0gOTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3dQZXJpb2QgPSAyMTtcbiAgICAgICAgICAgIGNvbnN0IGZhc3RFTUEgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3dFTUEgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCBzbG93UGVyaW9kKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsaW5lIHNlcmllcyB3aXRoIG5ldyBkYXRhXG4gICAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaCgoc2VyaWVzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYURhdGEgPSAobmFtZSA9PT0gJ0Zhc3QgRU1BICg5KScgPyBmYXN0RU1BIDogc2xvd0VNQSkubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgdGltZTogdXBkYXRlZERhdGFbaW5kZXhdLnRpbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnNldERhdGEoZW1hRGF0YSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5ldyBzaWduYWxzXG4gICAgICAgICAgICBjb25zdCBzaWduYWwgPSBzZWxlY3RlZFN0cmF0ZWd5LmFuYWx5emUodXBkYXRlZERhdGEpO1xuICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTmV3IFN0cmF0ZWd5IFNpZ25hbDonLCBzaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRpbWVmcmFtZSk7XG5cbiAgICAvLyBSZW1vdmUgVHJhZGluZ1ZpZXcgbG9nbyBlbGVtZW50cyBpZiB0aGV5IGV4aXN0XG4gICAgY29uc3QgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvID0gKCkgPT4ge1xuICAgICAgY29uc3QgbG9nb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHYtYXR0ci1sb2dvJyk7XG4gICAgICBpZiAobG9nb0VsZW1lbnQpIHtcbiAgICAgICAgbG9nb0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlYWRlckxvZ28gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHYtaGVhZGVyX19saW5rJyk7XG4gICAgICBpZiAoaGVhZGVyTG9nbykge1xuICAgICAgICBoZWFkZXJMb2dvLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSdW4gbG9nbyByZW1vdmFsIGFmdGVyIGNoYXJ0IGlzIGNyZWF0ZWRcbiAgICByZW1vdmVUcmFkaW5nVmlld0xvZ28oKTtcbiAgICAvLyBBbHNvIHJ1biBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGNhdGNoIGR5bmFtaWNhbGx5IGFkZGVkIGVsZW1lbnRzXG4gICAgY29uc3QgbG9nb1RpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVtb3ZlVHJhZGluZ1ZpZXdMb2dvLCAxMDApO1xuXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LmFwcGx5T3B0aW9ucyh7XG4gICAgICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KGxvZ29UaW1lb3V0SWQpO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3RpbWVmcmFtZSwgc3RyYXRlZ3ldKTtcblxuICByZXR1cm4gPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgLz47XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiY2FsY3VsYXRlRU1BIiwiZGF0YSIsInBlcmlvZCIsImVtYSIsIm11bHRpcGxpZXIiLCJzdW0iLCJpIiwicHVzaCIsIk5hTiIsImxlbmd0aCIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzRU1BIiwiY3VycmVudEVNQSIsIkNhbmRsZXN0aWNrQ2hhcnQiLCJ0aW1lZnJhbWUiLCJzdHJhdGVneSIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJoaXN0b3JpY2FsRGF0YVJlZiIsInVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyIsImNoYXJ0Iiwic2VsZWN0ZWRTdHJhdGVneSIsImNvbnNvbGUiLCJsb2ciLCJkYXRhTGVuZ3RoIiwiaGFzQ2hhcnQiLCJjdXJyZW50IiwiZm9yRWFjaCIsInNlcmllcyIsInJlbW92ZVNlcmllcyIsImUiLCJlcnJvciIsImNsZWFyIiwiaWQiLCJuYW1lIiwiaGFzSW5kaWNhdG9ycyIsImluZGljYXRvcnMiLCJzaXplIiwicHJpY2VzIiwibWFwIiwiZCIsImNsb3NlIiwiZmFzdFBlcmlvZCIsInNsb3dQZXJpb2QiLCJmYXN0RU1BIiwic2xvd0VNQSIsInZhbHVlIiwiaW5kZXgiLCJ0aW1lIiwiZmFzdEVNQUxlbmd0aCIsInNsb3dFTUFMZW5ndGgiLCJzaWduYWwiLCJhbmFseXplIiwiaW5kaWNhdG9yIiwiY29sb3JzIiwibGluZVNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJjb2xvciIsImxpbmVXaWR0aCIsInRpdGxlIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsInNldCIsInNldERhdGEiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZm9ybWF0VGltZSIsImRhdGUiLCJEYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJ0b0xvY2FsZVN0cmluZyIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJ0ZXh0Q29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJncmlkIiwidmVydExpbmVzIiwiaG9yekxpbmVzIiwiY3Jvc3NoYWlyIiwibW9kZSIsInZlcnRMaW5lIiwid2lkdGgiLCJzdHlsZSIsImhvcnpMaW5lIiwidGltZVNjYWxlIiwiYm9yZGVyQ29sb3IiLCJ0aW1lVmlzaWJsZSIsInNlY29uZHNWaXNpYmxlIiwicmlnaHRQcmljZVNjYWxlIiwibG9jYWxpemF0aW9uIiwidGltZUZvcm1hdHRlciIsIndhdGVybWFyayIsInZpc2libGUiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNhbmRsZXN0aWNrU2VyaWVzIiwiYWRkQ2FuZGxlc3RpY2tTZXJpZXMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsImxvYWREYXRhIiwiaGlzdG9yaWNhbERhdGEiLCJvcGVuIiwiaGlnaCIsImxvdyIsImN1cnJlbnRDYW5kbGUiLCJJbmZpbml0eSIsImdldEludGVydmFsU2Vjb25kcyIsInRmIiwidW5zdWJzY3JpYmUiLCJpbnRlcnZhbFNlY29uZHMiLCJjdXJyZW50VGltZXN0YW1wIiwiTWF0aCIsImZsb29yIiwibm93IiwiY2FuZGxlVGltZXN0YW1wIiwibmV3Q2FuZGxlIiwidXBkYXRlIiwic2xpY2UiLCJ1cGRhdGVkRGF0YSIsImVtYURhdGEiLCJyZW1vdmVUcmFkaW5nVmlld0xvZ28iLCJsb2dvRWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyZW1vdmUiLCJoZWFkZXJMb2dvIiwicXVlcnlTZWxlY3RvciIsImxvZ29UaW1lb3V0SWQiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
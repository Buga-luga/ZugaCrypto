"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/moving-averages */ \"(app-pages-browser)/./src/services/strategies/moving-averages.ts\");\n/* harmony import */ var _TickerHeader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TickerHeader */ \"(app-pages-browser)/./src/components/Chart/TickerHeader.tsx\");\n/* harmony import */ var _utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/priceFormat */ \"(app-pages-browser)/./src/utils/priceFormat.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Function to get interval in seconds\nconst getIntervalSeconds = (tf)=>{\n    switch(tf){\n        case \"1m\":\n            return 60;\n        case \"5m\":\n            return 300;\n        case \"15m\":\n            return 900;\n        case \"30m\":\n            return 1800;\n        case \"1h\":\n            return 3600;\n        case \"4h\":\n            return 14400;\n        case \"1d\":\n            return 86400;\n        default:\n            return 60;\n    }\n};\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token = \"BTC\", baseToken = \"USDT\", exchange = \"CryptoCompare\", onPairChange = ()=>{}, signals = [] } = param;\n    _s();\n    const [selectedExchange, setSelectedExchange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(exchange);\n    const [currentBaseToken, setCurrentBaseToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(baseToken);\n    const [currentPrice, setCurrentPrice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken));\n    const [priceStats, setPriceStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>({\n            change1h: \"0.00\",\n            change24h: \"0.00\",\n            change7d: \"0.00\",\n            high24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken),\n            low24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken)\n        }));\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const currentCandleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastSignalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Handle trading pair change\n    const handlePairChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((newToken, newBaseToken)=>{\n        onPairChange(newToken, newBaseToken);\n        setCurrentBaseToken(newBaseToken);\n    }, [\n        onPairChange\n    ]);\n    // Function to update price stats\n    const updatePriceStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((data)=>{\n        if (data.length < 2) return;\n        const currentPrice = data[data.length - 1].close;\n        // Calculate different time period changes\n        const last1h = data.slice(-1); // Last hour\n        const last24h = data.slice(-24); // Last 24 hours\n        const last7d = data.slice(-168); // Last 7 days (24 * 7)\n        const high24h = Math.max(...last24h.map((d)=>d.high));\n        const low24h = Math.min(...last24h.map((d)=>d.low));\n        // Calculate percentage changes\n        const getPercentChange = (periodData)=>{\n            if (periodData.length < 2) return 0;\n            const oldPrice = periodData[0].close;\n            return (currentPrice - oldPrice) / oldPrice * 100;\n        };\n        const change1h = getPercentChange(last1h);\n        const change24h = getPercentChange(last24h);\n        const change7d = getPercentChange(last7d);\n        // Format prices using the price format utility\n        const formattedCurrentPrice = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(currentPrice, currentBaseToken);\n        const formattedHigh = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(high24h, currentBaseToken);\n        const formattedLow = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(low24h, currentBaseToken);\n        setCurrentPrice(formattedCurrentPrice);\n        setPriceStats({\n            change1h: change1h.toFixed(2),\n            change24h: change24h.toFixed(2),\n            change7d: change7d.toFixed(2),\n            high24h: formattedHigh,\n            low24h: formattedLow\n        });\n    }, [\n        currentBaseToken\n    ]);\n    // Function to add strategy indicators\n    const addStrategyIndicators = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chart, data)=>{\n        if (!chart) {\n            console.error(\"Chart is not initialized\");\n            return;\n        }\n        try {\n            // Clear any existing indicators\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    if (series && chart) {\n                        chart.removeSeries(series);\n                    }\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            if (markerSeriesRef.current) {\n                try {\n                    chart.removeSeries(markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            if (strategy === \"none\") return;\n            // Calculate indicators based on strategy\n            const prices = data.map((d)=>d.close);\n            let fastLine = [];\n            let slowLine = [];\n            switch(strategy){\n                case \"ema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 21);\n                    break;\n                case \"sma_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 21);\n                    break;\n                case \"tema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 7);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 21);\n                    break;\n                case \"golden_cross\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 50);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 200);\n                    break;\n                case \"hull_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 21);\n                    break;\n                case \"ema_5_13\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 5);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 13);\n                    break;\n            }\n            // Add indicator lines\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy) return;\n            const colors = [\n                \"#2962FF\",\n                \"#FF6B6B\"\n            ];\n            selectedStrategy.indicators.forEach((indicator, index)=>{\n                const lineSeries = chart.addLineSeries({\n                    color: colors[index],\n                    lineWidth: 2,\n                    title: indicator.name,\n                    priceFormat: {\n                        type: \"price\",\n                        precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                        minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n                    }\n                });\n                indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                lineSeries.setData(lineData);\n            });\n            // Add crossover signals with a separate series\n            const markerSeries = chart.addLineSeries({\n                lastPriceAnimation: 0,\n                priceFormat: {\n                    type: \"price\",\n                    precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                    minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n                }\n            });\n            markerSeriesRef.current = markerSeries;\n            // Detect crossovers and create markers\n            const markers = [];\n            for(let i = 1; i < data.length; i++){\n                const prevFast = fastLine[i - 1];\n                const prevSlow = slowLine[i - 1];\n                const currFast = fastLine[i];\n                const currSlow = slowLine[i];\n                // Check for crossover\n                if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                    // Bullish crossover (fast crosses above slow)\n                    if (prevFast <= prevSlow && currFast > currSlow) {\n                        markers.push({\n                            time: data[i].time,\n                            position: \"belowBar\",\n                            color: \"#26a69a\",\n                            shape: \"triangle\",\n                            size: 2\n                        });\n                        markerSeries.update({\n                            time: data[i].time,\n                            value: data[i].low\n                        });\n                    } else if (prevFast >= prevSlow && currFast < currSlow) {\n                        markers.push({\n                            time: data[i].time,\n                            position: \"aboveBar\",\n                            color: \"#ef5350\",\n                            shape: \"triangle\",\n                            size: 2\n                        });\n                        markerSeries.update({\n                            time: data[i].time,\n                            value: data[i].high\n                        });\n                    }\n                }\n            }\n            markerSeries.setMarkers(markers);\n        } catch (error) {\n            console.error(\"Error adding strategy indicators:\", error);\n        }\n    }, [\n        strategy,\n        currentBaseToken\n    ]);\n    // Effect for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartRef.current || historicalDataRef.current.length === 0) {\n            return;\n        }\n        try {\n            addStrategyIndicators(chartRef.current, historicalDataRef.current);\n        } catch (error) {\n            console.error(\"Error in strategy change effect:\", error);\n        }\n    }, [\n        strategy,\n        addStrategyIndicators\n    ]);\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\",\n                visible: true,\n                scaleMargins: {\n                    top: 0.1,\n                    bottom: 0.4\n                },\n                autoScale: true,\n                mode: 0,\n                alignLabels: true,\n                borderVisible: true,\n                entireTextOnly: true,\n                ticksVisible: true\n            },\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight,\n            localization: {\n                priceFormatter: (price)=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(price, currentBaseToken)\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, chartOptions);\n        // Create candlestick series with price format\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\",\n            priceFormat: {\n                type: \"price\",\n                precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n            }\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        chartRef.current = chart;\n        // Load initial data\n        const loadData = async ()=>{\n            try {\n                const data = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe, token, currentBaseToken);\n                historicalDataRef.current = data;\n                candlestickSeries.setData(data);\n                updatePriceStats(data);\n                if (strategy !== \"none\") {\n                    addStrategyIndicators(chart, data);\n                }\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            }\n        };\n        loadData();\n        // Real-time updates\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (!candlestickSeriesRef.current) return;\n            const intervalSeconds = getIntervalSeconds(timeframe);\n            const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n            // If this is a new candle\n            if (!currentCandleRef.current || candleTimestamp !== currentCandleRef.current.time) {\n                // If we had a previous candle, add it to historical data and check for signals\n                if (currentCandleRef.current) {\n                    historicalDataRef.current = [\n                        ...historicalDataRef.current,\n                        currentCandleRef.current\n                    ];\n                    // Update strategies with the new historical data\n                    if (strategy !== \"none\" && chartRef.current) {\n                        addStrategyIndicators(chartRef.current, historicalDataRef.current);\n                    }\n                }\n                // Start new candle\n                currentCandleRef.current = {\n                    time: candleTimestamp,\n                    open: data.value,\n                    high: data.value,\n                    low: data.value,\n                    close: data.value\n                };\n            } else {\n                // Update current candle\n                currentCandleRef.current.high = Math.max(currentCandleRef.current.high, data.value);\n                currentCandleRef.current.low = Math.min(currentCandleRef.current.low, data.value);\n                currentCandleRef.current.close = data.value;\n            }\n            // Update the chart with current candle\n            candlestickSeriesRef.current.update(currentCandleRef.current);\n            // Update price stats with the latest data\n            if (historicalDataRef.current.length > 0) {\n                updatePriceStats([\n                    ...historicalDataRef.current,\n                    currentCandleRef.current\n                ]);\n            }\n        }, timeframe, token, currentBaseToken);\n        // Handle window resize\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            unsubscribe();\n            // Clean up indicator series\n            if (chartRef.current) {\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    try {\n                        var _chartRef_current;\n                        (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.removeSeries(series);\n                    } catch (e) {\n                        console.error(\"Error removing indicator series during cleanup:\", e);\n                    }\n                });\n                indicatorSeriesRefs.current.clear();\n                if (markerSeriesRef.current) {\n                    try {\n                        chartRef.current.removeSeries(markerSeriesRef.current);\n                    } catch (e) {\n                        console.error(\"Error removing marker series during cleanup:\", e);\n                    }\n                    markerSeriesRef.current = null;\n                }\n                chart.remove();\n            }\n        };\n    }, [\n        timeframe,\n        currentBaseToken,\n        strategy,\n        token,\n        updatePriceStats,\n        addStrategyIndicators\n    ]);\n    const renderMarkers = (candlestickSeries, signals)=>{\n        const markers = signals.map((signal)=>({\n                time: signal.time,\n                position: \"aboveBar\",\n                color: signal.type === \"buy\" ? \"green\" : \"red\",\n                shape: \"triangle\",\n                text: signal.message\n            }));\n        candlestickSeries.setMarkers(markers);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (candlestickSeriesRef.current && signals) {\n            renderMarkers(candlestickSeriesRef.current, signals);\n        }\n    }, [\n        signals\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col w-full h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TickerHeader__WEBPACK_IMPORTED_MODULE_6__.TickerHeader, {\n                token: token,\n                baseToken: baseToken,\n                exchange: exchange,\n                currentPrice: currentPrice,\n                priceStats: priceStats,\n                onExchangeChange: setSelectedExchange,\n                onPairChange: handlePairChange\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 472,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"flex-1\"\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 481,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 471,\n        columnNumber: 5\n    }, this);\n}\n_s(CandlestickChart, \"X/2PR85ZyF09U/+WSBIrlQi9Pb4=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVpRTtBQUNoQjtBQUNnRDtBQUNqQztBQU9qQjtBQUNEO0FBUWpCO0FBb0I3QixzQ0FBc0M7QUFDdEMsTUFBTWUscUJBQXFCLENBQUNDO0lBQzFCLE9BQVFBO1FBQ04sS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFPLE9BQU87UUFDbkIsS0FBSztZQUFPLE9BQU87UUFDbkIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEI7WUFBUyxPQUFPO0lBQ2xCO0FBQ0Y7QUFFTyxTQUFTQyxpQkFBaUIsS0FRVDtRQVJTLEVBQy9CQyxTQUFTLEVBQ1RDLFFBQVEsRUFDUkMsUUFBUSxLQUFLLEVBQ2JDLFlBQVksTUFBTSxFQUNsQkMsV0FBVyxlQUFlLEVBQzFCQyxlQUFlLEtBQU8sQ0FBQyxFQUN2QkMsVUFBVSxFQUFFLEVBQ1UsR0FSUzs7SUFTL0IsTUFBTSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHeEIsK0NBQVFBLENBQUNvQjtJQUN6RCxNQUFNLENBQUNLLGtCQUFrQkMsb0JBQW9CLEdBQUcxQiwrQ0FBUUEsQ0FBQ21CO0lBQ3pELE1BQU0sQ0FBQ1EsY0FBY0MsZ0JBQWdCLEdBQUc1QiwrQ0FBUUEsQ0FBUyxJQUFNVywrREFBV0EsQ0FBQyxHQUFHUTtJQUM5RSxNQUFNLENBQUNVLFlBQVlDLGNBQWMsR0FBRzlCLCtDQUFRQSxDQUFDLElBQU87WUFDbEQrQixVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxTQUFTdkIsK0RBQVdBLENBQUMsR0FBR1E7WUFDeEJnQixRQUFReEIsK0RBQVdBLENBQUMsR0FBR1E7UUFDekI7SUFFQSxNQUFNaUIsb0JBQW9CckMsNkNBQU1BLENBQWlCO0lB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QVFvQyxHQUFHLENBQUM2RyxDQUFBQSxTQUFXO2dCQUNyQ2pFLE1BQU1pRSxPQUFPakUsSUFBSTtnQkFDakJhLFVBQVU7Z0JBQ1Z6QixPQUFPNkUsT0FBT3hFLElBQUksS0FBSyxRQUFRLFVBQVU7Z0JBQ3pDcUIsT0FBTztnQkFDUG9ELE1BQU1ELE9BQU9FLE9BQU87WUFDdEI7UUFDQXJCLGtCQUFrQjdCLFVBQVUsQ0FBQ1g7SUFDL0I7SUFFQTlHLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSXdDLHFCQUFxQm9DLE9BQU8sSUFBSXBELFNBQVM7WUFDM0NnSixjQUFjaEkscUJBQXFCb0MsT0FBTyxFQUFFcEQ7UUFDOUM7SUFDRixHQUFHO1FBQUNBO0tBQVE7SUFFWixxQkFDRSw4REFBQ29KO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDakssdURBQVlBO2dCQUNYUSxPQUFPQTtnQkFDUEMsV0FBV0E7Z0JBQ1hDLFVBQVVBO2dCQUNWTyxjQUFjQTtnQkFDZEUsWUFBWUE7Z0JBQ1orSSxrQkFBa0JwSjtnQkFDbEJILGNBQWN3Qjs7Ozs7OzBCQUVoQiw4REFBQzZIO2dCQUFJRyxLQUFLekk7Z0JBQW1CdUksV0FBVTs7Ozs7Ozs7Ozs7O0FBRzdDO0dBNWFnQjVKO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4PzhkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgVGltZSwgSUNoYXJ0QXBpLCBDaGFydE9wdGlvbnMsIERlZXBQYXJ0aWFsLCBMaW5lV2lkdGgsIEJ1c2luZXNzRGF5LCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcbmltcG9ydCB7IFxuICBjYWxjdWxhdGVFTUEsXG4gIGNhbGN1bGF0ZVNNQSxcbiAgY2FsY3VsYXRlVEVNQSxcbiAgY2FsY3VsYXRlSE1BLFxuICBjYWxjdWxhdGVNQUNEXG59IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcy9tb3ZpbmctYXZlcmFnZXMnO1xuaW1wb3J0IHsgVGlja2VySGVhZGVyIH0gZnJvbSAnLi9UaWNrZXJIZWFkZXInO1xuaW1wb3J0IHsgXG4gIGdldENoYXJ0UHJpY2VGb3JtYXQsIFxuICBnZXRTY2FsZUZvcm1hdCwgXG4gIGZvcm1hdFByaWNlLCBcbiAgaXNCVENQYWlyLFxuICBERUZBVUxUX0JUQ19GT1JNQVQsXG4gIERFRkFVTFRfVVNEVF9GT1JNQVRcbn0gZnJvbSAnQC91dGlscy9wcmljZUZvcm1hdCc7XG5cbmludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XG4gIHRva2VuPzogc3RyaW5nO1xuICBiYXNlVG9rZW4/OiBzdHJpbmc7XG4gIGV4Y2hhbmdlPzogc3RyaW5nO1xuICBvblBhaXJDaGFuZ2U/OiAodG9rZW46IHN0cmluZywgYmFzZVRva2VuOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNpZ25hbHM/OiBTdHJhdGVneVNpZ25hbFtdO1xufVxuXG5pbnRlcmZhY2UgQ2FuZGxlIHtcbiAgdGltZTogVGltZTtcbiAgb3BlbjogbnVtYmVyO1xuICBoaWdoOiBudW1iZXI7XG4gIGxvdzogbnVtYmVyO1xuICBjbG9zZTogbnVtYmVyO1xufVxuXG4vLyBGdW5jdGlvbiB0byBnZXQgaW50ZXJ2YWwgaW4gc2Vjb25kc1xuY29uc3QgZ2V0SW50ZXJ2YWxTZWNvbmRzID0gKHRmOiBUaW1lZnJhbWUpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKHRmKSB7XG4gICAgY2FzZSAnMW0nOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnNW0nOiByZXR1cm4gMzAwO1xuICAgIGNhc2UgJzE1bSc6IHJldHVybiA5MDA7XG4gICAgY2FzZSAnMzBtJzogcmV0dXJuIDE4MDA7XG4gICAgY2FzZSAnMWgnOiByZXR1cm4gMzYwMDtcbiAgICBjYXNlICc0aCc6IHJldHVybiAxNDQwMDtcbiAgICBjYXNlICcxZCc6IHJldHVybiA4NjQwMDtcbiAgICBkZWZhdWx0OiByZXR1cm4gNjA7XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgXG4gIHRpbWVmcmFtZSwgXG4gIHN0cmF0ZWd5LCBcbiAgdG9rZW4gPSAnQlRDJywgXG4gIGJhc2VUb2tlbiA9ICdVU0RUJyxcbiAgZXhjaGFuZ2UgPSAnQ3J5cHRvQ29tcGFyZScsXG4gIG9uUGFpckNoYW5nZSA9ICgpID0+IHt9LFxuICBzaWduYWxzID0gW11cbn06IENhbmRsZXN0aWNrQ2hhcnRQcm9wcykge1xuICBjb25zdCBbc2VsZWN0ZWRFeGNoYW5nZSwgc2V0U2VsZWN0ZWRFeGNoYW5nZV0gPSB1c2VTdGF0ZShleGNoYW5nZSk7XG4gIGNvbnN0IFtjdXJyZW50QmFzZVRva2VuLCBzZXRDdXJyZW50QmFzZVRva2VuXSA9IHVzZVN0YXRlKGJhc2VUb2tlbik7XG4gIGNvbnN0IFtjdXJyZW50UHJpY2UsIHNldEN1cnJlbnRQcmljZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KCgpID0+IGZvcm1hdFByaWNlKDAsIGJhc2VUb2tlbikpO1xuICBjb25zdCBbcHJpY2VTdGF0cywgc2V0UHJpY2VTdGF0c10gPSB1c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGNoYW5nZTFoOiAnMC4wMCcsXG4gICAgY2hhbmdlMjRoOiAnMC4wMCcsXG4gICAgY2hhbmdlN2Q6ICcwLjAwJyxcbiAgICBoaWdoMjRoOiBmb3JtYXRQcmljZSgwLCBiYXNlVG9rZW4pLFxuICAgIGxvdzI0aDogZm9ybWF0UHJpY2UoMCwgYmFzZVRva2VuKVxuICB9KSk7XG5cbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xuICBjb25zdCBtYXJrZXJTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaGlzdG9yaWNhbERhdGFSZWYgPSB1c2VSZWY8YW55W10+KFtdKTtcbiAgY29uc3QgY3VycmVudENhbmRsZVJlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuICBjb25zdCBsYXN0U2lnbmFsUmVmID0gdXNlUmVmPHsgdGltZTogbnVtYmVyLCB0eXBlOiAnYnV5JyB8ICdzZWxsJyB9IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gSGFuZGxlIHRyYWRpbmcgcGFpciBjaGFuZ2VcbiAgY29uc3QgaGFuZGxlUGFpckNoYW5nZSA9IHVzZUNhbGxiYWNrKChuZXdUb2tlbjogc3RyaW5nLCBuZXdCYXNlVG9rZW46IHN0cmluZykgPT4ge1xuICAgIG9uUGFpckNoYW5nZShuZXdUb2tlbiwgbmV3QmFzZVRva2VuKTtcbiAgICBzZXRDdXJyZW50QmFzZVRva2VuKG5ld0Jhc2VUb2tlbik7XG4gIH0sIFtvblBhaXJDaGFuZ2VdKTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgcHJpY2Ugc3RhdHNcbiAgY29uc3QgdXBkYXRlUHJpY2VTdGF0cyA9IHVzZUNhbGxiYWNrKChkYXRhOiBhbnlbXSkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRQcmljZSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5jbG9zZTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlmZmVyZW50IHRpbWUgcGVyaW9kIGNoYW5nZXNcbiAgICBjb25zdCBsYXN0MWggPSBkYXRhLnNsaWNlKC0xKTsgLy8gTGFzdCBob3VyXG4gICAgY29uc3QgbGFzdDI0aCA9IGRhdGEuc2xpY2UoLTI0KTsgLy8gTGFzdCAyNCBob3Vyc1xuICAgIGNvbnN0IGxhc3Q3ZCA9IGRhdGEuc2xpY2UoLTE2OCk7IC8vIExhc3QgNyBkYXlzICgyNCAqIDcpXG4gICAgXG4gICAgY29uc3QgaGlnaDI0aCA9IE1hdGgubWF4KC4uLmxhc3QyNGgubWFwKGQgPT4gZC5oaWdoKSk7XG4gICAgY29uc3QgbG93MjRoID0gTWF0aC5taW4oLi4ubGFzdDI0aC5tYXAoZCA9PiBkLmxvdykpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIGNoYW5nZXNcbiAgICBjb25zdCBnZXRQZXJjZW50Q2hhbmdlID0gKHBlcmlvZERhdGE6IGFueVtdKSA9PiB7XG4gICAgICBpZiAocGVyaW9kRGF0YS5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgICAgIGNvbnN0IG9sZFByaWNlID0gcGVyaW9kRGF0YVswXS5jbG9zZTtcbiAgICAgIHJldHVybiAoKGN1cnJlbnRQcmljZSAtIG9sZFByaWNlKSAvIG9sZFByaWNlKSAqIDEwMDtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhbmdlMWggPSBnZXRQZXJjZW50Q2hhbmdlKGxhc3QxaCk7XG4gICAgY29uc3QgY2hhbmdlMjRoID0gZ2V0UGVyY2VudENoYW5nZShsYXN0MjRoKTtcbiAgICBjb25zdCBjaGFuZ2U3ZCA9IGdldFBlcmNlbnRDaGFuZ2UobGFzdDdkKTtcbiAgICBcbiAgICAvLyBGb3JtYXQgcHJpY2VzIHVzaW5nIHRoZSBwcmljZSBmb3JtYXQgdXRpbGl0eVxuICAgIGNvbnN0IGZvcm1hdHRlZEN1cnJlbnRQcmljZSA9IGZvcm1hdFByaWNlKGN1cnJlbnRQcmljZSwgY3VycmVudEJhc2VUb2tlbik7XG4gICAgY29uc3QgZm9ybWF0dGVkSGlnaCA9IGZvcm1hdFByaWNlKGhpZ2gyNGgsIGN1cnJlbnRCYXNlVG9rZW4pO1xuICAgIGNvbnN0IGZvcm1hdHRlZExvdyA9IGZvcm1hdFByaWNlKGxvdzI0aCwgY3VycmVudEJhc2VUb2tlbik7XG5cbiAgICBzZXRDdXJyZW50UHJpY2UoZm9ybWF0dGVkQ3VycmVudFByaWNlKTtcbiAgICBzZXRQcmljZVN0YXRzKHtcbiAgICAgIGNoYW5nZTFoOiBjaGFuZ2UxaC50b0ZpeGVkKDIpLFxuICAgICAgY2hhbmdlMjRoOiBjaGFuZ2UyNGgudG9GaXhlZCgyKSxcbiAgICAgIGNoYW5nZTdkOiBjaGFuZ2U3ZC50b0ZpeGVkKDIpLFxuICAgICAgaGlnaDI0aDogZm9ybWF0dGVkSGlnaCxcbiAgICAgIGxvdzI0aDogZm9ybWF0dGVkTG93XG4gICAgfSk7XG4gIH0sIFtjdXJyZW50QmFzZVRva2VuXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIHN0cmF0ZWd5IGluZGljYXRvcnNcbiAgY29uc3QgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzID0gdXNlQ2FsbGJhY2soKGNoYXJ0OiBJQ2hhcnRBcGksIGRhdGE6IGFueVtdKSA9PiB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgY29uc29sZS5lcnJvcignQ2hhcnQgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbmRpY2F0b3JzXG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZXJpZXMgJiYgY2hhcnQpIHtcbiAgICAgICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNlcmllczonLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIG1hcmtlciBzZXJpZXM6JywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdub25lJykgcmV0dXJuO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5kaWNhdG9ycyBiYXNlZCBvbiBzdHJhdGVneVxuICAgICAgY29uc3QgcHJpY2VzID0gZGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgIGxldCBmYXN0TGluZTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBzbG93TGluZTogbnVtYmVyW10gPSBbXTtcblxuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdlbWFfY3Jvc3NvdmVyJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDkpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlRU1BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzbWFfY3Jvc3NvdmVyJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDkpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlU01BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0ZW1hX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVURU1BKHByaWNlcywgNyk7XG4gICAgICAgICAgc2xvd0xpbmUgPSBjYWxjdWxhdGVURU1BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb2xkZW5fY3Jvc3MnOlxuICAgICAgICAgIGZhc3RMaW5lID0gY2FsY3VsYXRlU01BKHByaWNlcywgNTApO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlU01BKHByaWNlcywgMjAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHVsbF9jcm9zc292ZXInOlxuICAgICAgICAgIGZhc3RMaW5lID0gY2FsY3VsYXRlSE1BKHByaWNlcywgOSk7XG4gICAgICAgICAgc2xvd0xpbmUgPSBjYWxjdWxhdGVITUEocHJpY2VzLCAyMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VtYV81XzEzJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDUpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlRU1BKHByaWNlcywgMTMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgaW5kaWNhdG9yIGxpbmVzXG4gICAgICBjb25zdCBzZWxlY3RlZFN0cmF0ZWd5ID0gZ2V0U3RyYXRlZ3koc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxlY3RlZFN0cmF0ZWd5KSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGNvbG9ycyA9IFsnIzI5NjJGRicsICcjRkY2QjZCJ107XG4gICAgICBzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnMuZm9yRWFjaCgoaW5kaWNhdG9yLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgY29sb3I6IGNvbG9yc1tpbmRleF0sXG4gICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgIHRpdGxlOiBpbmRpY2F0b3IubmFtZSxcbiAgICAgICAgICBwcmljZUZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgICAgIHByZWNpc2lvbjogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gOCA6IDIsXG4gICAgICAgICAgICBtaW5Nb3ZlOiBpc0JUQ1BhaXIoY3VycmVudEJhc2VUb2tlbikgPyAwLjAwMDAwMDAxIDogMC4wMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNldChpbmRpY2F0b3IubmFtZSwgbGluZVNlcmllcyk7XG5cbiAgICAgICAgY29uc3QgbGluZURhdGEgPSAoaW5kZXggPT09IDAgPyBmYXN0TGluZSA6IHNsb3dMaW5lKVxuICAgICAgICAgIC5tYXAoKHZhbHVlLCBpZHgpID0+ICh7XG4gICAgICAgICAgICB0aW1lOiBkYXRhW2lkeF0udGltZSxcbiAgICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7XG5cbiAgICAgICAgbGluZVNlcmllcy5zZXREYXRhKGxpbmVEYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgY3Jvc3NvdmVyIHNpZ25hbHMgd2l0aCBhIHNlcGFyYXRlIHNlcmllc1xuICAgICAgY29uc3QgbWFya2VyU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgIGxhc3RQcmljZUFuaW1hdGlvbjogMCxcbiAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICAgIHByZWNpc2lvbjogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gOCA6IDIsXG4gICAgICAgICAgbWluTW92ZTogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gMC4wMDAwMDAwMSA6IDAuMDEsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbWFya2VyU2VyaWVzO1xuXG4gICAgICAvLyBEZXRlY3QgY3Jvc3NvdmVycyBhbmQgY3JlYXRlIG1hcmtlcnNcbiAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2RmFzdCA9IGZhc3RMaW5lW2kgLSAxXTtcbiAgICAgICAgY29uc3QgcHJldlNsb3cgPSBzbG93TGluZVtpIC0gMV07XG4gICAgICAgIGNvbnN0IGN1cnJGYXN0ID0gZmFzdExpbmVbaV07XG4gICAgICAgIGNvbnN0IGN1cnJTbG93ID0gc2xvd0xpbmVbaV07XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNyb3Nzb3ZlclxuICAgICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xuICAgICAgICAgIC8vIEJ1bGxpc2ggY3Jvc3NvdmVyIChmYXN0IGNyb3NzZXMgYWJvdmUgc2xvdylcbiAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xuICAgICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICAgICAgc2hhcGU6ICd0cmlhbmdsZScsXG4gICAgICAgICAgICAgIHNpemU6IDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFya2VyU2VyaWVzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRhdGFbaV0ubG93LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJlYXJpc2ggY3Jvc3NvdmVyIChmYXN0IGNyb3NzZXMgYmVsb3cgc2xvdylcbiAgICAgICAgICBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XG4gICAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgICBzaGFwZTogJ3RyaWFuZ2xlJyxcbiAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYXJrZXJTZXJpZXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogZGF0YVtpXS5oaWdoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcmtlclNlcmllcy5zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgc3RyYXRlZ3kgaW5kaWNhdG9yczonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbc3RyYXRlZ3ksIGN1cnJlbnRCYXNlVG9rZW5dKTtcblxuICAvLyBFZmZlY3QgZm9yIHN0cmF0ZWd5IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0UmVmLmN1cnJlbnQgfHwgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGFkZFN0cmF0ZWd5SW5kaWNhdG9ycyhjaGFydFJlZi5jdXJyZW50LCBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc3RyYXRlZ3kgY2hhbmdlIGVmZmVjdDonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbc3RyYXRlZ3ksIGFkZFN0cmF0ZWd5SW5kaWNhdG9yc10pO1xuXG4gIC8vIE1haW4gY2hhcnQgaW5pdGlhbGl6YXRpb24gZWZmZWN0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFydENvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBjaGFydE9wdGlvbnM6IERlZXBQYXJ0aWFsPENoYXJ0T3B0aW9ucz4gPSB7XG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgYmFja2dyb3VuZDogeyBjb2xvcjogJyMxRTIyMkQnIH0sXG4gICAgICAgIHRleHRDb2xvcjogJyNEREQnLFxuICAgICAgfSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgdmVydExpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcbiAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcbiAgICAgIH0sXG4gICAgICB0aW1lU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgICAgdGltZVZpc2libGU6IHRydWUsXG4gICAgICB9LFxuICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIHNjYWxlTWFyZ2luczoge1xuICAgICAgICAgIHRvcDogMC4xLFxuICAgICAgICAgIGJvdHRvbTogMC40LFxuICAgICAgICB9LFxuICAgICAgICBhdXRvU2NhbGU6IHRydWUsXG4gICAgICAgIG1vZGU6IDAsXG4gICAgICAgIGFsaWduTGFiZWxzOiB0cnVlLFxuICAgICAgICBib3JkZXJWaXNpYmxlOiB0cnVlLFxuICAgICAgICBlbnRpcmVUZXh0T25seTogdHJ1ZSxcbiAgICAgICAgdGlja3NWaXNpYmxlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICAgIGxvY2FsaXphdGlvbjoge1xuICAgICAgICBwcmljZUZvcm1hdHRlcjogKHByaWNlOiBudW1iZXIpID0+IGZvcm1hdFByaWNlKHByaWNlLCBjdXJyZW50QmFzZVRva2VuKSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwgY2hhcnRPcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSBjYW5kbGVzdGljayBzZXJpZXMgd2l0aCBwcmljZSBmb3JtYXRcbiAgICBjb25zdCBjYW5kbGVzdGlja1NlcmllcyA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHtcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgYm9yZGVyVmlzaWJsZTogZmFsc2UsXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgcHJlY2lzaW9uOiBpc0JUQ1BhaXIoY3VycmVudEJhc2VUb2tlbikgPyA4IDogMixcbiAgICAgICAgbWluTW92ZTogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gMC4wMDAwMDAwMSA6IDAuMDEsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCA9IGNhbmRsZXN0aWNrU2VyaWVzO1xuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcblxuICAgIC8vIExvYWQgaW5pdGlhbCBkYXRhXG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0SGlzdG9yaWNhbERhdGEodGltZWZyYW1lLCB0b2tlbiwgY3VycmVudEJhc2VUb2tlbik7XG4gICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgICAgICBcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXMuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgdXBkYXRlUHJpY2VTdGF0cyhkYXRhKTtcblxuICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJykge1xuICAgICAgICAgIGFkZFN0cmF0ZWd5SW5kaWNhdG9ycyhjaGFydCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGF0YTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxvYWREYXRhKCk7XG5cbiAgICAvLyBSZWFsLXRpbWUgdXBkYXRlc1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlVG9QcmljZSgoZGF0YSkgPT4ge1xuICAgICAgaWYgKCFjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGludGVydmFsU2Vjb25kcyA9IGdldEludGVydmFsU2Vjb25kcyh0aW1lZnJhbWUpO1xuICAgICAgY29uc3QgY2FuZGxlVGltZXN0YW1wID0gTWF0aC5mbG9vcihkYXRhLnRpbWUgLyBpbnRlcnZhbFNlY29uZHMpICogaW50ZXJ2YWxTZWNvbmRzO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3IGNhbmRsZVxuICAgICAgaWYgKCFjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQgfHwgY2FuZGxlVGltZXN0YW1wICE9PSBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQudGltZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYWQgYSBwcmV2aW91cyBjYW5kbGUsIGFkZCBpdCB0byBoaXN0b3JpY2FsIGRhdGEgYW5kIGNoZWNrIGZvciBzaWduYWxzXG4gICAgICAgIGlmIChjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWdpZXMgd2l0aCB0aGUgbmV3IGhpc3RvcmljYWwgZGF0YVxuICAgICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGFkZFN0cmF0ZWd5SW5kaWNhdG9ycyhjaGFydFJlZi5jdXJyZW50LCBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCBuZXcgY2FuZGxlXG4gICAgICAgIGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICB0aW1lOiBjYW5kbGVUaW1lc3RhbXAsXG4gICAgICAgICAgb3BlbjogZGF0YS52YWx1ZSxcbiAgICAgICAgICBoaWdoOiBkYXRhLnZhbHVlLFxuICAgICAgICAgIGxvdzogZGF0YS52YWx1ZSxcbiAgICAgICAgICBjbG9zZTogZGF0YS52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgY2FuZGxlXG4gICAgICAgIGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5oaWdoID0gTWF0aC5tYXgoY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmhpZ2gsIGRhdGEudmFsdWUpO1xuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQubG93ID0gTWF0aC5taW4oY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmxvdywgZGF0YS52YWx1ZSk7XG4gICAgICAgIGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5jbG9zZSA9IGRhdGEudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY2hhcnQgd2l0aCBjdXJyZW50IGNhbmRsZVxuICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoY3VycmVudENhbmRsZVJlZi5jdXJyZW50KTtcblxuICAgICAgLy8gVXBkYXRlIHByaWNlIHN0YXRzIHdpdGggdGhlIGxhdGVzdCBkYXRhXG4gICAgICBpZiAoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVwZGF0ZVByaWNlU3RhdHMoWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudF0pO1xuICAgICAgfVxuICAgIH0sIHRpbWVmcmFtZSwgdG9rZW4sIGN1cnJlbnRCYXNlVG9rZW4pO1xuXG4gICAgLy8gSGFuZGxlIHdpbmRvdyByZXNpemVcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQuYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBpbmRpY2F0b3Igc2VyaWVzXG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFydFJlZi5jdXJyZW50Py5yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBpbmRpY2F0b3Igc2VyaWVzIGR1cmluZyBjbGVhbnVwOicsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlU2VyaWVzKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBtYXJrZXIgc2VyaWVzIGR1cmluZyBjbGVhbnVwOicsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNoYXJ0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt0aW1lZnJhbWUsIGN1cnJlbnRCYXNlVG9rZW4sIHN0cmF0ZWd5LCB0b2tlbiwgdXBkYXRlUHJpY2VTdGF0cywgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzXSk7XG5cbiAgY29uc3QgcmVuZGVyTWFya2VycyA9IChjYW5kbGVzdGlja1NlcmllczogYW55LCBzaWduYWxzOiBTdHJhdGVneVNpZ25hbFtdKSA9PiB7XG4gICAgY29uc3QgbWFya2VycyA9IHNpZ25hbHMubWFwKHNpZ25hbCA9PiAoe1xuICAgICAgdGltZTogc2lnbmFsLnRpbWUgYXMgVVRDVGltZXN0YW1wLFxuICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXG4gICAgICBjb2xvcjogc2lnbmFsLnR5cGUgPT09ICdidXknID8gJ2dyZWVuJyA6ICdyZWQnLFxuICAgICAgc2hhcGU6ICd0cmlhbmdsZScsXG4gICAgICB0ZXh0OiBzaWduYWwubWVzc2FnZSxcbiAgICB9KSk7XG4gICAgY2FuZGxlc3RpY2tTZXJpZXMuc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ICYmIHNpZ25hbHMpIHtcbiAgICAgIHJlbmRlck1hcmtlcnMoY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCwgc2lnbmFscyk7XG4gICAgfVxuICB9LCBbc2lnbmFsc10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHctZnVsbCBoLWZ1bGxcIj5cbiAgICAgIDxUaWNrZXJIZWFkZXJcbiAgICAgICAgdG9rZW49e3Rva2VufVxuICAgICAgICBiYXNlVG9rZW49e2Jhc2VUb2tlbn1cbiAgICAgICAgZXhjaGFuZ2U9e2V4Y2hhbmdlfVxuICAgICAgICBjdXJyZW50UHJpY2U9e2N1cnJlbnRQcmljZX1cbiAgICAgICAgcHJpY2VTdGF0cz17cHJpY2VTdGF0c31cbiAgICAgICAgb25FeGNoYW5nZUNoYW5nZT17c2V0U2VsZWN0ZWRFeGNoYW5nZX1cbiAgICAgICAgb25QYWlyQ2hhbmdlPXtoYW5kbGVQYWlyQ2hhbmdlfVxuICAgICAgLz5cbiAgICAgIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwiZmxleC0xXCIgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiY2FsY3VsYXRlRU1BIiwiY2FsY3VsYXRlU01BIiwiY2FsY3VsYXRlVEVNQSIsImNhbGN1bGF0ZUhNQSIsIlRpY2tlckhlYWRlciIsImZvcm1hdFByaWNlIiwiaXNCVENQYWlyIiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJDYW5kbGVzdGlja0NoYXJ0IiwidGltZWZyYW1lIiwic3RyYXRlZ3kiLCJ0b2tlbiIsImJhc2VUb2tlbiIsImV4Y2hhbmdlIiwib25QYWlyQ2hhbmdlIiwic2lnbmFscyIsInNlbGVjdGVkRXhjaGFuZ2UiLCJzZXRTZWxlY3RlZEV4Y2hhbmdlIiwiY3VycmVudEJhc2VUb2tlbiIsInNldEN1cnJlbnRCYXNlVG9rZW4iLCJjdXJyZW50UHJpY2UiLCJzZXRDdXJyZW50UHJpY2UiLCJwcmljZVN0YXRzIiwic2V0UHJpY2VTdGF0cyIsImNoYW5nZTFoIiwiY2hhbmdlMjRoIiwiY2hhbmdlN2QiLCJoaWdoMjRoIiwibG93MjRoIiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZXN0aWNrU2VyaWVzUmVmIiwiaW5kaWNhdG9yU2VyaWVzUmVmcyIsIk1hcCIsIm1hcmtlclNlcmllc1JlZiIsImhpc3RvcmljYWxEYXRhUmVmIiwiY3VycmVudENhbmRsZVJlZiIsImxhc3RTaWduYWxSZWYiLCJoYW5kbGVQYWlyQ2hhbmdlIiwibmV3VG9rZW4iLCJuZXdCYXNlVG9rZW4iLCJ1cGRhdGVQcmljZVN0YXRzIiwiZGF0YSIsImxlbmd0aCIsImNsb3NlIiwibGFzdDFoIiwic2xpY2UiLCJsYXN0MjRoIiwibGFzdDdkIiwiTWF0aCIsIm1heCIsIm1hcCIsImQiLCJoaWdoIiwibWluIiwibG93IiwiZ2V0UGVyY2VudENoYW5nZSIsInBlcmlvZERhdGEiLCJvbGRQcmljZSIsImZvcm1hdHRlZEN1cnJlbnRQcmljZSIsImZvcm1hdHRlZEhpZ2giLCJmb3JtYXR0ZWRMb3ciLCJ0b0ZpeGVkIiwiYWRkU3RyYXRlZ3lJbmRpY2F0b3JzIiwiY2hhcnQiLCJjb25zb2xlIiwiZXJyb3IiLCJjdXJyZW50IiwiZm9yRWFjaCIsInNlcmllcyIsInJlbW92ZVNlcmllcyIsImUiLCJjbGVhciIsInByaWNlcyIsImZhc3RMaW5lIiwic2xvd0xpbmUiLCJzZWxlY3RlZFN0cmF0ZWd5IiwiY29sb3JzIiwiaW5kaWNhdG9ycyIsImluZGljYXRvciIsImluZGV4IiwibGluZVNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJjb2xvciIsImxpbmVXaWR0aCIsInRpdGxlIiwibmFtZSIsInByaWNlRm9ybWF0IiwidHlwZSIsInByZWNpc2lvbiIsIm1pbk1vdmUiLCJzZXQiLCJsaW5lRGF0YSIsInZhbHVlIiwiaWR4IiwidGltZSIsImlzTmFOIiwiZmlsdGVyIiwic2V0RGF0YSIsIm1hcmtlclNlcmllcyIsImxhc3RQcmljZUFuaW1hdGlvbiIsIm1hcmtlcnMiLCJpIiwicHJldkZhc3QiLCJwcmV2U2xvdyIsImN1cnJGYXN0IiwiY3VyclNsb3ciLCJwdXNoIiwicG9zaXRpb24iLCJzaGFwZSIsInNpemUiLCJ1cGRhdGUiLCJzZXRNYXJrZXJzIiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwicmlnaHRQcmljZVNjYWxlIiwidmlzaWJsZSIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsImF1dG9TY2FsZSIsIm1vZGUiLCJhbGlnbkxhYmVscyIsImJvcmRlclZpc2libGUiLCJlbnRpcmVUZXh0T25seSIsInRpY2tzVmlzaWJsZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJsb2NhbGl6YXRpb24iLCJwcmljZUZvcm1hdHRlciIsInByaWNlIiwiY2FuZGxlc3RpY2tTZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsInVwQ29sb3IiLCJkb3duQ29sb3IiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJsb2FkRGF0YSIsInVuc3Vic2NyaWJlIiwiaW50ZXJ2YWxTZWNvbmRzIiwiY2FuZGxlVGltZXN0YW1wIiwiZmxvb3IiLCJvcGVuIiwiaGFuZGxlUmVzaXplIiwiYXBwbHlPcHRpb25zIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmUiLCJyZW5kZXJNYXJrZXJzIiwic2lnbmFsIiwidGV4dCIsIm1lc3NhZ2UiLCJkaXYiLCJjbGFzc05hbWUiLCJvbkV4Y2hhbmdlQ2hhbmdlIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// Import the calculateEMA function from the strategy file\nfunction calculateEMA(data, period) {\n    const ema = [];\n    const multiplier = 2 / (period + 1);\n    // First EMA uses SMA as initial value\n    let sum = 0;\n    for(let i = 0; i < period; i++){\n        sum += data[i];\n        ema.push(NaN); // Fill initial values with NaN\n    }\n    ema[period - 1] = sum / period;\n    // Calculate EMA for remaining values\n    for(let i = period; i < data.length; i++){\n        const currentValue = data[i];\n        const previousEMA = ema[i - 1];\n        const currentEMA = (currentValue - previousEMA) * multiplier + previousEMA;\n        ema.push(currentEMA);\n    }\n    return ema;\n}\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Function to detect signals from EMA data\n    const detectEMASignals = (data, fastEMA, slowEMA)=>{\n        const markers = [];\n        for(let i = 1; i < data.length; i++){\n            const prevFast = fastEMA[i - 1];\n            const prevSlow = slowEMA[i - 1];\n            const currFast = fastEMA[i];\n            const currSlow = slowEMA[i];\n            if (prevFast <= prevSlow && currFast > currSlow) {\n                // Buy signal\n                markers.push({\n                    time: data[i].time,\n                    position: \"belowBar\",\n                    color: \"#26a69a\",\n                    shape: \"arrowUp\",\n                    text: \"BUY\",\n                    size: 3\n                });\n            } else if (prevFast >= prevSlow && currFast < currSlow) {\n                // Sell signal\n                markers.push({\n                    time: data[i].time,\n                    position: \"aboveBar\",\n                    color: \"#ef5350\",\n                    shape: \"arrowDown\",\n                    text: \"SELL\",\n                    size: 3\n                });\n            }\n        }\n        return markers;\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = (data, chart)=>{\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            // Clear existing markers and indicators\n            if (markerSeriesRef.current) {\n                chart.removeSeries(markerSeriesRef.current);\n                markerSeriesRef.current = null;\n            }\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    chart.removeSeries(series);\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            if (strategy === \"none\") return;\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!(selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.indicators)) return;\n            // Create marker series for signals\n            markerSeriesRef.current = chart.addCandlestickSeries({\n                upColor: \"rgba(0, 0, 0, 0)\",\n                downColor: \"rgba(0, 0, 0, 0)\",\n                borderVisible: false,\n                wickVisible: false\n            });\n            // Run strategy analysis and update indicators\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\") {\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastEMA = calculateEMA(prices, fastPeriod);\n                const slowEMA = calculateEMA(prices, slowPeriod);\n                // Update indicator data\n                selectedStrategy.indicators[0].data = fastEMA.map((value, index)=>({\n                        time: data[index].time,\n                        value: value\n                    }));\n                selectedStrategy.indicators[1].data = slowEMA.map((value, index)=>({\n                        time: data[index].time,\n                        value: value\n                    }));\n                // Add EMA lines\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    const colors = [\n                        \"#2962FF\",\n                        \"#FF6B6B\"\n                    ]; // Blue for fast, Red for slow\n                    const lineSeries = chart.addLineSeries({\n                        color: colors[index],\n                        lineWidth: 2,\n                        title: indicator.name,\n                        priceFormat: {\n                            type: \"price\",\n                            precision: 2,\n                            minMove: 0.01\n                        }\n                    });\n                    indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                    lineSeries.setData(indicator.data);\n                });\n                // Get historical signals\n                const markers = detectEMASignals(data, fastEMA, slowEMA);\n                if (markers.length > 0) {\n                    markerSeriesRef.current.setMarkers(markers);\n                    console.log(\"Historical signals detected:\", markers.length);\n                }\n                // Add signal indicator at the bottom\n                const signalSeries = chart.addHistogramSeries({\n                    color: \"#26a69a\",\n                    priceFormat: {\n                        type: \"price\",\n                        precision: 0,\n                        minMove: 1\n                    },\n                    priceScaleId: \"signal\",\n                    scaleMargins: {\n                        top: 0.8,\n                        bottom: 0\n                    }\n                });\n                // Create signal indicator data\n                const signalData = data.map((candle, i)=>{\n                    if (i === 0) return {\n                        time: candle.time,\n                        value: 0,\n                        color: \"rgba(0,0,0,0)\"\n                    };\n                    const prevFast = fastEMA[i - 1];\n                    const prevSlow = slowEMA[i - 1];\n                    const currFast = fastEMA[i];\n                    const currSlow = slowEMA[i];\n                    if (prevFast <= prevSlow && currFast > currSlow) {\n                        return {\n                            time: candle.time,\n                            value: 1,\n                            color: \"#26a69a\"\n                        }; // Buy signal\n                    } else if (prevFast >= prevSlow && currFast < currSlow) {\n                        return {\n                            time: candle.time,\n                            value: -1,\n                            color: \"#ef5350\"\n                        }; // Sell signal\n                    }\n                    return {\n                        time: candle.time,\n                        value: 0,\n                        color: \"rgba(0,0,0,0)\"\n                    };\n                });\n                signalSeries.setData(signalData);\n                indicatorSeriesRefs.current.set(\"signal\", signalSeries);\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Add an effect specifically for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        // Add a small delay to ensure chart is ready\n        const timeoutId = setTimeout(()=>{\n            if (chartRef.current && historicalDataRef.current.length > 0) {\n                updateStrategyIndicators(historicalDataRef.current, chartRef.current);\n            }\n        }, 100);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Update strategy indicators with initial data\n                updateStrategyIndicators(historicalData, chart);\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            newCandle\n                        ];\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                    // Update candlestick series with the new candle\n                    candlestickSeriesRef.current.update(currentCandle);\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                    // Update candlestick series with the current state\n                    candlestickSeriesRef.current.update(currentCandle);\n                }\n                // Update strategy indicators if we have a strategy selected\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy && selectedStrategy.id === \"ema_crossover\") {\n                        // Include the current candle in the calculations\n                        const updatedData = [\n                            ...historicalDataRef.current.slice(1),\n                            currentCandle\n                        ];\n                        const prices = updatedData.map((d)=>d.close);\n                        const fastPeriod = 9;\n                        const slowPeriod = 21;\n                        const fastEMA = calculateEMA(prices, fastPeriod);\n                        const slowEMA = calculateEMA(prices, slowPeriod);\n                        // Update the line series with new data\n                        indicatorSeriesRefs.current.forEach((series, name)=>{\n                            const emaData = (name === \"Fast EMA (9)\" ? fastEMA : slowEMA).map((value, index)=>({\n                                    time: updatedData[index].time,\n                                    value: value\n                                }));\n                            series.setData(emaData);\n                        });\n                        // Check for new signals using the same detection function\n                        const newSignals = detectEMASignals(updatedData.slice(-2), fastEMA.slice(-2), slowEMA.slice(-2));\n                        // If we have a new signal, add it to existing markers\n                        if (newSignals.length > 0 && markerSeriesRef.current) {\n                            const currentMarkers = markerSeriesRef.current.markers() || [];\n                            const lastSignal = newSignals[newSignals.length - 1];\n                            // Log the signal with price information\n                            if (lastSignal.text === \"BUY\") {\n                                console.log(\"\\uD83D\\uDFE2 Buy Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString()\n                                });\n                            } else {\n                                console.log(\"\\uD83D\\uDD34 Sell Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString()\n                                });\n                            }\n                            markerSeriesRef.current.setMarkers([\n                                ...currentMarkers,\n                                lastSignal\n                            ]);\n                        }\n                    }\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 481,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"79wJC2kgSopMt/NxaIK+M+7bdVo=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUMwQztBQUNzRjtBQUMvQjtBQUNqQztBQUVoRSwwREFBMEQ7QUFDMUQsU0FBU00sYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ2xELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsYUFBYSxJQUFLRixDQUFBQSxTQUFTO0lBRWpDLHNDQUFzQztJQUN0QyxJQUFJRyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JELE9BQU9KLElBQUksQ0FBQ0ssRUFBRTtRQUNkSCxJQUFJSSxJQUFJLENBQUNDLE1BQU0sK0JBQStCO0lBQ2hEO0lBQ0FMLEdBQUcsQ0FBQ0QsU0FBUyxFQUFFLEdBQUdHLE1BQU1IO0lBRXhCLHFDQUFxQztJQUNyQyxJQUFLLElBQUlJLElBQUlKLFFBQVFJLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztRQUN6QyxNQUFNSSxlQUFlVCxJQUFJLENBQUNLLEVBQUU7UUFDNUIsTUFBTUssY0FBY1IsR0FBRyxDQUFDRyxJQUFJLEVBQUU7UUFDOUIsTUFBTU0sYUFBYSxDQUFDRixlQUFlQyxXQUFVLElBQUtQLGFBQWFPO1FBQy9EUixJQUFJSSxJQUFJLENBQUNLO0lBQ1g7SUFFQSxPQUFPVDtBQUNUO0FBV08sU0FBU1UsaUJBQWlCLEtBQThDO1FBQTlDLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUF5QixHQUE5Qzs7SUFDL0IsTUFBTUMsb0JBQW9CckIsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1zQixXQUFXdEIsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU11Qix1QkFBdUJ2Qiw2Q0FBTUEsQ0FBTTtJQUN6QyxNQUFNd0Isc0JBQXNCeEIsNkNBQU1BLENBQW1CLElBQUl5QjtJQUN6RCxNQUFNQyxvQkFBb0IxQiw2Q0FBTUEsQ0FBUSxFQUFF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Q0YsR0FBRztRQUFDako7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQ3lKO1FBQUlDLEtBQUt6SjtRQUFtQjBKLFdBQVU7Ozs7OztBQUNoRDtHQTFiZ0I3SjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2hhcnQsIENvbG9yVHlwZSwgSUNoYXJ0QXBpLCBEZWVwUGFydGlhbCwgQ2hhcnRPcHRpb25zLCBMaW5lV2lkdGgsIFRpbWUsIEJ1c2luZXNzRGF5IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcblxuLy8gSW1wb3J0IHRoZSBjYWxjdWxhdGVFTUEgZnVuY3Rpb24gZnJvbSB0aGUgc3RyYXRlZ3kgZmlsZVxuZnVuY3Rpb24gY2FsY3VsYXRlRU1BKGRhdGE6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcik6IG51bWJlcltdIHtcbiAgY29uc3QgZW1hOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBtdWx0aXBsaWVyID0gMiAvIChwZXJpb2QgKyAxKTtcblxuICAvLyBGaXJzdCBFTUEgdXNlcyBTTUEgYXMgaW5pdGlhbCB2YWx1ZVxuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2Q7IGkrKykge1xuICAgIHN1bSArPSBkYXRhW2ldO1xuICAgIGVtYS5wdXNoKE5hTik7IC8vIEZpbGwgaW5pdGlhbCB2YWx1ZXMgd2l0aCBOYU5cbiAgfVxuICBlbWFbcGVyaW9kIC0gMV0gPSBzdW0gLyBwZXJpb2Q7XG5cbiAgLy8gQ2FsY3VsYXRlIEVNQSBmb3IgcmVtYWluaW5nIHZhbHVlc1xuICBmb3IgKGxldCBpID0gcGVyaW9kOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRhdGFbaV07XG4gICAgY29uc3QgcHJldmlvdXNFTUEgPSBlbWFbaSAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRFTUEgPSAoY3VycmVudFZhbHVlIC0gcHJldmlvdXNFTUEpICogbXVsdGlwbGllciArIHByZXZpb3VzRU1BO1xuICAgIGVtYS5wdXNoKGN1cnJlbnRFTUEpO1xuICB9XG5cbiAgcmV0dXJuIGVtYTtcbn1cblxuLy8gV0FSTklORzogVGhpcyBjb21wb25lbnQgdXNlcyB0aGUgQ3J5cHRvQ29tcGFyZSBBUEkgZm9yIHJlYWwtdGltZSBCaXRjb2luIHByaWNlIGRhdGEuXG4vLyBETyBOT1QgcmVwbGFjZSB0aGlzIHdpdGggc2FtcGxlIGRhdGEgb3IgbW9kaWZ5IHRoZSBkYXRhIGZlZWQgaW1wbGVtZW50YXRpb24uXG4vLyBUaGUgcHJpY2UgZmVlZCBpcyB3b3JraW5nIGNvcnJlY3RseSBhbmQgc2hvdWxkIHJlbWFpbiBjb25uZWN0ZWQgdG8gQ3J5cHRvQ29tcGFyZS5cblxuZXhwb3J0IGludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgdGltZWZyYW1lLCBzdHJhdGVneSB9OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xuICBjb25zdCBoaXN0b3JpY2FsRGF0YVJlZiA9IHVzZVJlZjxhbnlbXT4oW10pO1xuICBjb25zdCBtYXJrZXJTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcblxuICAvLyBGdW5jdGlvbiB0byBkZXRlY3Qgc2lnbmFscyBmcm9tIEVNQSBkYXRhXG4gIGNvbnN0IGRldGVjdEVNQVNpZ25hbHMgPSAoZGF0YTogYW55W10sIGZhc3RFTUE6IG51bWJlcltdLCBzbG93RU1BOiBudW1iZXJbXSk6IGFueVtdID0+IHtcbiAgICBjb25zdCBtYXJrZXJzOiBhbnlbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJldkZhc3QgPSBmYXN0RU1BW2kgLSAxXTtcbiAgICAgIGNvbnN0IHByZXZTbG93ID0gc2xvd0VNQVtpIC0gMV07XG4gICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RFTUFbaV07XG4gICAgICBjb25zdCBjdXJyU2xvdyA9IHNsb3dFTUFbaV07XG5cbiAgICAgIGlmIChwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93KSB7XG4gICAgICAgIC8vIEJ1eSBzaWduYWxcbiAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgcG9zaXRpb246ICdiZWxvd0JhcicsXG4gICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxuICAgICAgICAgIHRleHQ6ICdCVVknLFxuICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XG4gICAgICAgIC8vIFNlbGwgc2lnbmFsXG4gICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgIGNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICAgICAgc2hhcGU6ICdhcnJvd0Rvd24nLFxuICAgICAgICAgIHRleHQ6ICdTRUxMJyxcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcnM7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnNcbiAgY29uc3QgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzID0gKGRhdGE6IGFueVtdLCBjaGFydDogSUNoYXJ0QXBpKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY2hhcnQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGFydCBvciBkYXRhIG5vdCByZWFkeSwgc2tpcHBpbmcgdXBkYXRlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgbWFya2VycyBhbmQgaW5kaWNhdG9yc1xuICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGFydC5yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNlcmllczonLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbm9uZScpIHJldHVybjtcblxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgIGlmICghc2VsZWN0ZWRTdHJhdGVneT8uaW5kaWNhdG9ycykgcmV0dXJuO1xuXG4gICAgICAvLyBDcmVhdGUgbWFya2VyIHNlcmllcyBmb3Igc2lnbmFsc1xuICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XG4gICAgICAgIHVwQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJyxcbiAgICAgICAgZG93bkNvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsXG4gICAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxuICAgICAgICB3aWNrVmlzaWJsZTogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gUnVuIHN0cmF0ZWd5IGFuYWx5c2lzIGFuZCB1cGRhdGUgaW5kaWNhdG9yc1xuICAgICAgY29uc3QgcHJpY2VzID0gZGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicpIHtcbiAgICAgICAgY29uc3QgZmFzdFBlcmlvZCA9IDk7XG4gICAgICAgIGNvbnN0IHNsb3dQZXJpb2QgPSAyMTtcbiAgICAgICAgY29uc3QgZmFzdEVNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpO1xuICAgICAgICBjb25zdCBzbG93RU1BID0gY2FsY3VsYXRlRU1BKHByaWNlcywgc2xvd1BlcmlvZCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGluZGljYXRvciBkYXRhXG4gICAgICAgIHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9yc1swXS5kYXRhID0gZmFzdEVNQS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICB0aW1lOiBkYXRhW2luZGV4XS50aW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9yc1sxXS5kYXRhID0gc2xvd0VNQS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICB0aW1lOiBkYXRhW2luZGV4XS50aW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQWRkIEVNQSBsaW5lc1xuICAgICAgICBzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnMuZm9yRWFjaCgoaW5kaWNhdG9yLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IFsnIzI5NjJGRicsICcjRkY2QjZCJ107IC8vIEJsdWUgZm9yIGZhc3QsIFJlZCBmb3Igc2xvd1xuICAgICAgICAgIGNvbnN0IGxpbmVTZXJpZXMgPSBjaGFydC5hZGRMaW5lU2VyaWVzKHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgdGl0bGU6IGluZGljYXRvci5uYW1lLFxuICAgICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgICAgICAgcHJlY2lzaW9uOiAyLFxuICAgICAgICAgICAgICBtaW5Nb3ZlOiAwLjAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KGluZGljYXRvci5uYW1lLCBsaW5lU2VyaWVzKTtcbiAgICAgICAgICBsaW5lU2VyaWVzLnNldERhdGEoaW5kaWNhdG9yLmRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBHZXQgaGlzdG9yaWNhbCBzaWduYWxzXG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBkZXRlY3RFTUFTaWduYWxzKGRhdGEsIGZhc3RFTUEsIHNsb3dFTUEpO1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQuc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnSGlzdG9yaWNhbCBzaWduYWxzIGRldGVjdGVkOicsIG1hcmtlcnMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzaWduYWwgaW5kaWNhdG9yIGF0IHRoZSBib3R0b21cbiAgICAgICAgY29uc3Qgc2lnbmFsU2VyaWVzID0gY2hhcnQuYWRkSGlzdG9ncmFtU2VyaWVzKHtcbiAgICAgICAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiAwLFxuICAgICAgICAgICAgbWluTW92ZTogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaWNlU2NhbGVJZDogJ3NpZ25hbCcsIC8vIFNlcGFyYXRlIHNjYWxlIGZvciBzaWduYWxzXG4gICAgICAgICAgc2NhbGVNYXJnaW5zOiB7XG4gICAgICAgICAgICB0b3A6IDAuOCwgLy8gUG9zaXRpb24gYXQgdGhlIGJvdHRvbVxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBzaWduYWwgaW5kaWNhdG9yIGRhdGFcbiAgICAgICAgY29uc3Qgc2lnbmFsRGF0YSA9IGRhdGEubWFwKChjYW5kbGUsIGkpID0+IHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIHsgdGltZTogY2FuZGxlLnRpbWUsIHZhbHVlOiAwLCBjb2xvcjogJ3JnYmEoMCwwLDAsMCknIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcHJldkZhc3QgPSBmYXN0RU1BW2kgLSAxXTtcbiAgICAgICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dFTUFbaSAtIDFdO1xuICAgICAgICAgIGNvbnN0IGN1cnJGYXN0ID0gZmFzdEVNQVtpXTtcbiAgICAgICAgICBjb25zdCBjdXJyU2xvdyA9IHNsb3dFTUFbaV07XG5cbiAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdGltZTogY2FuZGxlLnRpbWUsIHZhbHVlOiAxLCBjb2xvcjogJyMyNmE2OWEnIH07IC8vIEJ1eSBzaWduYWxcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRpbWU6IGNhbmRsZS50aW1lLCB2YWx1ZTogLTEsIGNvbG9yOiAnI2VmNTM1MCcgfTsgLy8gU2VsbCBzaWduYWxcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgdGltZTogY2FuZGxlLnRpbWUsIHZhbHVlOiAwLCBjb2xvcjogJ3JnYmEoMCwwLDAsMCknIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNpZ25hbFNlcmllcy5zZXREYXRhKHNpZ25hbERhdGEpO1xuICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KCdzaWduYWwnLCBzaWduYWxTZXJpZXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9yczonLCBlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGFuIGVmZmVjdCBzcGVjaWZpY2FsbHkgZm9yIHN0cmF0ZWd5IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnU3RyYXRlZ3kgY2hhbmdlZDonLCBzdHJhdGVneSk7XG4gICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgdG8gZW5zdXJlIGNoYXJ0IGlzIHJlYWR5XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCAmJiBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGNoYXJ0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH0sIFtzdHJhdGVneV0pOyAvLyBPbmx5IHJ1biB3aGVuIHN0cmF0ZWd5IGNoYW5nZXNcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgY2hhcnQgd2l0aCB0aW1lZnJhbWU6JywgdGltZWZyYW1lKTtcblxuICAgIGNvbnN0IGZvcm1hdFRpbWUgPSAodGltZTogVGltZSkgPT4ge1xuICAgICAgbGV0IGRhdGU6IERhdGU7XG4gICAgICBcbiAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBCdXNpbmVzc0RheSBmb3JtYXRcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aW1lIGFzIEJ1c2luZXNzRGF5O1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcbiAgICAgICAgbW9udGg6ICdzaG9ydCcsXG4gICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgICAgICBob3VyMTI6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICAvLyBGb3IgZGFpbHkgdGltZWZyYW1lcywgZG9uJ3Qgc2hvdyB0aW1lXG4gICAgICBpZiAodGltZWZyYW1lID09PSAnMWQnKSB7XG4gICAgICAgIGRlbGV0ZSBmb3JtYXRPcHRpb25zLmhvdXI7XG4gICAgICAgIGRlbGV0ZSBmb3JtYXRPcHRpb25zLm1pbnV0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgZm9ybWF0T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNoYXJ0T3B0aW9uczogRGVlcFBhcnRpYWw8Q2hhcnRPcHRpb25zPiA9IHtcbiAgICAgIGxheW91dDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzFFMjIyRCcgfSxcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogJ1JvYm90bywgc2Fucy1zZXJpZicsXG4gICAgICB9LFxuICAgICAgZ3JpZDoge1xuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgICBob3J6TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgfSxcbiAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBtb2RlOiAxLFxuICAgICAgICB2ZXJ0TGluZToge1xuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxuICAgICAgICAgIHN0eWxlOiAzLFxuICAgICAgICB9LFxuICAgICAgICBob3J6TGluZToge1xuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxuICAgICAgICAgIHN0eWxlOiAzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRpbWVTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgc2Vjb25kc1Zpc2libGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgfSxcbiAgICAgIGxvY2FsaXphdGlvbjoge1xuICAgICAgICB0aW1lRm9ybWF0dGVyOiBmb3JtYXRUaW1lLFxuICAgICAgfSxcbiAgICAgIHdhdGVybWFyazoge1xuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xuICAgICAgLi4uY2hhcnRPcHRpb25zLFxuICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XG4gICAgICB1cENvbG9yOiAnIzI2YTY5YScsXG4gICAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxuICAgICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIHdpY2tEb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICB9KTtcblxuICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVzdGlja1NlcmllcztcblxuICAgIC8vIEZldGNoIGhpc3RvcmljYWwgZGF0YVxuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGlzdG9yaWNhbERhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWUpO1xuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVkIGhpc3RvcmljYWwgZGF0YTonLCBoaXN0b3JpY2FsRGF0YS5sZW5ndGgpO1xuICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gaGlzdG9yaWNhbERhdGE7XG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLnNldERhdGEoaGlzdG9yaWNhbERhdGEubWFwKGQgPT4gKHtcbiAgICAgICAgICB0aW1lOiBkLnRpbWUsXG4gICAgICAgICAgb3BlbjogZC5vcGVuLFxuICAgICAgICAgIGhpZ2g6IGQuaGlnaCxcbiAgICAgICAgICBsb3c6IGQubG93LFxuICAgICAgICAgIGNsb3NlOiBkLmNsb3NlXG4gICAgICAgIH0pKSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBpbml0aWFsIGRhdGFcbiAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhLCBjaGFydCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGhpc3RvcmljYWwgZGF0YTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxvYWREYXRhKCk7XG4gICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlYWwtdGltZSBwcmljZSB1cGRhdGVzIHdpdGggaW1wcm92ZWQgY2FuZGxlIGZvcm1hdGlvblxuICAgIGxldCBjdXJyZW50Q2FuZGxlID0ge1xuICAgICAgb3BlbjogMCxcbiAgICAgIGhpZ2g6IC1JbmZpbml0eSxcbiAgICAgIGxvdzogSW5maW5pdHksXG4gICAgICBjbG9zZTogMCxcbiAgICAgIHRpbWU6IDAsXG4gICAgfTtcblxuICAgIGNvbnN0IGdldEludGVydmFsU2Vjb25kcyA9ICh0ZjogVGltZWZyYW1lKTogbnVtYmVyID0+IHtcbiAgICAgIHN3aXRjaCAodGYpIHtcbiAgICAgICAgY2FzZSAnMW0nOiByZXR1cm4gNjA7XG4gICAgICAgIGNhc2UgJzVtJzogcmV0dXJuIDMwMDtcbiAgICAgICAgY2FzZSAnMTVtJzogcmV0dXJuIDkwMDtcbiAgICAgICAgY2FzZSAnMzBtJzogcmV0dXJuIDE4MDA7XG4gICAgICAgIGNhc2UgJzFoJzogcmV0dXJuIDM2MDA7XG4gICAgICAgIGNhc2UgJzRoJzogcmV0dXJuIDE0NDAwO1xuICAgICAgICBjYXNlICcxZCc6IHJldHVybiA4NjQwMDtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIDYwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZVRvUHJpY2UoKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsU2Vjb25kcyA9IGdldEludGVydmFsU2Vjb25kcyh0aW1lZnJhbWUpO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGNhbmRsZVRpbWVzdGFtcCA9IE1hdGguZmxvb3IoY3VycmVudFRpbWVzdGFtcCAvIGludGVydmFsU2Vjb25kcykgKiBpbnRlcnZhbFNlY29uZHM7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3IGNhbmRsZVxuICAgICAgICBpZiAoY2FuZGxlVGltZXN0YW1wICE9PSBjdXJyZW50Q2FuZGxlLnRpbWUpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBjYW5kbGUsIGZpbmFsaXplIGl0XG4gICAgICAgICAgaWYgKGN1cnJlbnRDYW5kbGUudGltZSAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FuZGxlID0ge1xuICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXG4gICAgICAgICAgICAgIG9wZW46IGN1cnJlbnRDYW5kbGUub3BlbixcbiAgICAgICAgICAgICAgaGlnaDogY3VycmVudENhbmRsZS5oaWdoLFxuICAgICAgICAgICAgICBsb3c6IGN1cnJlbnRDYW5kbGUubG93LFxuICAgICAgICAgICAgICBjbG9zZTogY3VycmVudENhbmRsZS5jbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShuZXdDYW5kbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgaGlzdG9yaWNhbCBkYXRhIHdpdGggdGhlIG5ldyBjYW5kbGVcbiAgICAgICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5zbGljZSgxKSwgbmV3Q2FuZGxlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgY2FuZGxlXG4gICAgICAgICAgY3VycmVudENhbmRsZSA9IHtcbiAgICAgICAgICAgIHRpbWU6IGNhbmRsZVRpbWVzdGFtcCxcbiAgICAgICAgICAgIG9wZW46IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBoaWdoOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBjYW5kbGVzdGljayBzZXJpZXMgd2l0aCB0aGUgbmV3IGNhbmRsZVxuICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYW5kbGVcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA+IGN1cnJlbnRDYW5kbGUuaGlnaCkgY3VycmVudENhbmRsZS5oaWdoID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA8IGN1cnJlbnRDYW5kbGUubG93KSBjdXJyZW50Q2FuZGxlLmxvdyA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgY3VycmVudENhbmRsZS5jbG9zZSA9IGRhdGEudmFsdWU7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzIGlmIHdlIGhhdmUgYSBzdHJhdGVneSBzZWxlY3RlZFxuICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJyAmJiBjaGFydFJlZi5jdXJyZW50ICYmIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zaXplID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkU3RyYXRlZ3kgPSBnZXRTdHJhdGVneShzdHJhdGVneSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kgJiYgc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInKSB7XG4gICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBjdXJyZW50IGNhbmRsZSBpbiB0aGUgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LnNsaWNlKDEpLCBjdXJyZW50Q2FuZGxlXTtcbiAgICAgICAgICAgIGNvbnN0IHByaWNlcyA9IHVwZGF0ZWREYXRhLm1hcChkID0+IGQuY2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgZmFzdFBlcmlvZCA9IDk7XG4gICAgICAgICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XG4gICAgICAgICAgICBjb25zdCBmYXN0RU1BID0gY2FsY3VsYXRlRU1BKHByaWNlcywgZmFzdFBlcmlvZCk7XG4gICAgICAgICAgICBjb25zdCBzbG93RU1BID0gY2FsY3VsYXRlRU1BKHByaWNlcywgc2xvd1BlcmlvZCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGluZSBzZXJpZXMgd2l0aCBuZXcgZGF0YVxuICAgICAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goKHNlcmllcywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBlbWFEYXRhID0gKG5hbWUgPT09ICdGYXN0IEVNQSAoOSknID8gZmFzdEVNQSA6IHNsb3dFTUEpLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIHRpbWU6IHVwZGF0ZWREYXRhW2luZGV4XS50aW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHNlcmllcy5zZXREYXRhKGVtYURhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXcgc2lnbmFscyB1c2luZyB0aGUgc2FtZSBkZXRlY3Rpb24gZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IG5ld1NpZ25hbHMgPSBkZXRlY3RFTUFTaWduYWxzKHVwZGF0ZWREYXRhLnNsaWNlKC0yKSwgZmFzdEVNQS5zbGljZSgtMiksIHNsb3dFTUEuc2xpY2UoLTIpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG5ldyBzaWduYWwsIGFkZCBpdCB0byBleGlzdGluZyBtYXJrZXJzXG4gICAgICAgICAgICBpZiAobmV3U2lnbmFscy5sZW5ndGggPiAwICYmIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrZXJzID0gbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQubWFya2VycygpIHx8IFtdO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0U2lnbmFsID0gbmV3U2lnbmFsc1tuZXdTaWduYWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gTG9nIHRoZSBzaWduYWwgd2l0aCBwcmljZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICBpZiAobGFzdFNpZ25hbC50ZXh0ID09PSAnQlVZJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5+iIEJ1eSBTaWduYWw6Jywge1xuICAgICAgICAgICAgICAgICAgcHJpY2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShjdXJyZW50Q2FuZGxlLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflLQgU2VsbCBTaWduYWw6Jywge1xuICAgICAgICAgICAgICAgICAgcHJpY2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShjdXJyZW50Q2FuZGxlLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50LnNldE1hcmtlcnMoWy4uLmN1cnJlbnRNYXJrZXJzLCBsYXN0U2lnbmFsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGltZWZyYW1lKTtcblxuICAgIC8vIFJlbW92ZSBUcmFkaW5nVmlldyBsb2dvIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3RcbiAgICBjb25zdCByZW1vdmVUcmFkaW5nVmlld0xvZ28gPSAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dvRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0di1hdHRyLWxvZ28nKTtcbiAgICAgIGlmIChsb2dvRWxlbWVudCkge1xuICAgICAgICBsb2dvRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVhZGVyTG9nbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50di1oZWFkZXJfX2xpbmsnKTtcbiAgICAgIGlmIChoZWFkZXJMb2dvKSB7XG4gICAgICAgIGhlYWRlckxvZ28ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJ1biBsb2dvIHJlbW92YWwgYWZ0ZXIgY2hhcnQgaXMgY3JlYXRlZFxuICAgIHJlbW92ZVRyYWRpbmdWaWV3TG9nbygpO1xuICAgIC8vIEFsc28gcnVuIGFmdGVyIGEgc2hvcnQgZGVsYXkgdG8gY2F0Y2ggZHluYW1pY2FsbHkgYWRkZWQgZWxlbWVudHNcbiAgICBjb25zdCBsb2dvVGltZW91dElkID0gc2V0VGltZW91dChyZW1vdmVUcmFkaW5nVmlld0xvZ28sIDEwMCk7XG5cbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQuYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQobG9nb1RpbWVvdXRJZCk7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbdGltZWZyYW1lLCBzdHJhdGVneV0pO1xuXG4gIHJldHVybiA8ZGl2IHJlZj17Y2hhcnRDb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIiAvPjtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUNoYXJ0IiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJzdWJzY3JpYmVUb1ByaWNlIiwiZ2V0U3RyYXRlZ3kiLCJjYWxjdWxhdGVFTUEiLCJkYXRhIiwicGVyaW9kIiwiZW1hIiwibXVsdGlwbGllciIsInN1bSIsImkiLCJwdXNoIiwiTmFOIiwibGVuZ3RoIiwiY3VycmVudFZhbHVlIiwicHJldmlvdXNFTUEiLCJjdXJyZW50RU1BIiwiQ2FuZGxlc3RpY2tDaGFydCIsInRpbWVmcmFtZSIsInN0cmF0ZWd5IiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZXN0aWNrU2VyaWVzUmVmIiwiaW5kaWNhdG9yU2VyaWVzUmVmcyIsIk1hcCIsImhpc3RvcmljYWxEYXRhUmVmIiwibWFya2VyU2VyaWVzUmVmIiwiZGV0ZWN0RU1BU2lnbmFscyIsImZhc3RFTUEiLCJzbG93RU1BIiwibWFya2VycyIsInByZXZGYXN0IiwicHJldlNsb3ciLCJjdXJyRmFzdCIsImN1cnJTbG93IiwidGltZSIsInBvc2l0aW9uIiwiY29sb3IiLCJzaGFwZSIsInRleHQiLCJzaXplIiwidXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzIiwiY2hhcnQiLCJjb25zb2xlIiwibG9nIiwiY3VycmVudCIsInJlbW92ZVNlcmllcyIsImZvckVhY2giLCJzZXJpZXMiLCJlIiwiZXJyb3IiLCJjbGVhciIsInNlbGVjdGVkU3RyYXRlZ3kiLCJpbmRpY2F0b3JzIiwiYWRkQ2FuZGxlc3RpY2tTZXJpZXMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIndpY2tWaXNpYmxlIiwicHJpY2VzIiwibWFwIiwiZCIsImNsb3NlIiwiaWQiLCJmYXN0UGVyaW9kIiwic2xvd1BlcmlvZCIsInZhbHVlIiwiaW5kZXgiLCJpbmRpY2F0b3IiLCJjb2xvcnMiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImxpbmVXaWR0aCIsInRpdGxlIiwibmFtZSIsInByaWNlRm9ybWF0IiwidHlwZSIsInByZWNpc2lvbiIsIm1pbk1vdmUiLCJzZXQiLCJzZXREYXRhIiwic2V0TWFya2VycyIsInNpZ25hbFNlcmllcyIsImFkZEhpc3RvZ3JhbVNlcmllcyIsInByaWNlU2NhbGVJZCIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsInNpZ25hbERhdGEiLCJjYW5kbGUiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZm9ybWF0VGltZSIsImRhdGUiLCJEYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJ0b0xvY2FsZVN0cmluZyIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJ0ZXh0Q29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJncmlkIiwidmVydExpbmVzIiwiaG9yekxpbmVzIiwiY3Jvc3NoYWlyIiwibW9kZSIsInZlcnRMaW5lIiwid2lkdGgiLCJzdHlsZSIsImhvcnpMaW5lIiwidGltZVNjYWxlIiwiYm9yZGVyQ29sb3IiLCJ0aW1lVmlzaWJsZSIsInNlY29uZHNWaXNpYmxlIiwicmlnaHRQcmljZVNjYWxlIiwibG9jYWxpemF0aW9uIiwidGltZUZvcm1hdHRlciIsIndhdGVybWFyayIsInZpc2libGUiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNhbmRsZXN0aWNrU2VyaWVzIiwid2lja1VwQ29sb3IiLCJ3aWNrRG93bkNvbG9yIiwibG9hZERhdGEiLCJoaXN0b3JpY2FsRGF0YSIsIm9wZW4iLCJoaWdoIiwibG93IiwiY3VycmVudENhbmRsZSIsIkluZmluaXR5IiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJ1bnN1YnNjcmliZSIsImludGVydmFsU2Vjb25kcyIsImN1cnJlbnRUaW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJub3ciLCJjYW5kbGVUaW1lc3RhbXAiLCJuZXdDYW5kbGUiLCJ1cGRhdGUiLCJzbGljZSIsInVwZGF0ZWREYXRhIiwiZW1hRGF0YSIsIm5ld1NpZ25hbHMiLCJjdXJyZW50TWFya2VycyIsImxhc3RTaWduYWwiLCJwcmljZSIsInJlbW92ZVRyYWRpbmdWaWV3TG9nbyIsImxvZ29FbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInJlbW92ZSIsImhlYWRlckxvZ28iLCJxdWVyeVNlbGVjdG9yIiwibG9nb1RpbWVvdXRJZCIsImhhbmRsZVJlc2l6ZSIsImFwcGx5T3B0aW9ucyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
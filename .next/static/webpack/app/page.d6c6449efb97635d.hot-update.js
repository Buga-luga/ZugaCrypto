"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// Import the calculateEMA function from the strategy file\nfunction calculateEMA(data, period) {\n    const ema = [];\n    const multiplier = 2 / (period + 1);\n    // First EMA uses SMA as initial value\n    let sum = 0;\n    for(let i = 0; i < period; i++){\n        sum += data[i];\n        ema.push(NaN); // Fill initial values with NaN\n    }\n    ema[period - 1] = sum / period;\n    // Calculate EMA for remaining values\n    for(let i = period; i < data.length; i++){\n        const currentValue = data[i];\n        const previousEMA = ema[i - 1];\n        const currentEMA = (currentValue - previousEMA) * multiplier + previousEMA;\n        ema.push(currentEMA);\n    }\n    return ema;\n}\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Function to detect signals from EMA data\n    const detectEMASignals = (data, fastEMA, slowEMA)=>{\n        const markers = [];\n        for(let i = 1; i < Math.min(data.length, fastEMA.length, slowEMA.length); i++){\n            const prevFast = fastEMA[i - 1];\n            const prevSlow = slowEMA[i - 1];\n            const currFast = fastEMA[i];\n            const currSlow = slowEMA[i];\n            // Debug crossover conditions\n            console.log(\"Checking crossover:\", {\n                time: new Date(data[i].time * 1000).toLocaleString(),\n                prevFast: prevFast === null || prevFast === void 0 ? void 0 : prevFast.toFixed(2),\n                prevSlow: prevSlow === null || prevSlow === void 0 ? void 0 : prevSlow.toFixed(2),\n                currFast: currFast === null || currFast === void 0 ? void 0 : currFast.toFixed(2),\n                currSlow: currSlow === null || currSlow === void 0 ? void 0 : currSlow.toFixed(2),\n                isBuy: prevFast <= prevSlow && currFast > currSlow,\n                isSell: prevFast >= prevSlow && currFast < currSlow\n            });\n            // Only add signals if we have valid EMA values\n            if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                // Buy signal: Fast EMA crosses above Slow EMA\n                if (prevFast <= prevSlow && currFast > currSlow) {\n                    markers.push({\n                        time: data[i].time,\n                        position: \"belowBar\",\n                        color: \"#26a69a\",\n                        shape: \"arrowUp\",\n                        text: \"BUY\\n$\".concat(data[i].close.toFixed(2)),\n                        size: 2\n                    });\n                    console.log(\"\\uD83D\\uDFE2 Buy Signal Detected:\", {\n                        price: data[i].close,\n                        time: new Date(data[i].time * 1000).toLocaleString(),\n                        fastEMA: currFast.toFixed(2),\n                        slowEMA: currSlow.toFixed(2),\n                        diff: (currFast - currSlow).toFixed(2)\n                    });\n                } else if (prevFast >= prevSlow && currFast < currSlow) {\n                    markers.push({\n                        time: data[i].time,\n                        position: \"aboveBar\",\n                        color: \"#ef5350\",\n                        shape: \"arrowDown\",\n                        text: \"SELL\\n$\".concat(data[i].close.toFixed(2)),\n                        size: 2\n                    });\n                    console.log(\"\\uD83D\\uDD34 Sell Signal Detected:\", {\n                        price: data[i].close,\n                        time: new Date(data[i].time * 1000).toLocaleString(),\n                        fastEMA: currFast.toFixed(2),\n                        slowEMA: currSlow.toFixed(2),\n                        diff: (currFast - currSlow).toFixed(2)\n                    });\n                }\n            }\n        }\n        return markers;\n    };\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = (data, chart)=>{\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            // Clear existing markers and indicators\n            safelyRemoveSeries(chart, markerSeriesRef.current);\n            markerSeriesRef.current = null;\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chart, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            if (strategy === \"none\") {\n                console.log(\"No strategy selected, clearing indicators\");\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!(selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.indicators)) {\n                console.log(\"No indicators found for strategy:\", strategy);\n                return;\n            }\n            console.log(\"Setting up strategy:\", selectedStrategy.id);\n            // Create marker series for signals\n            markerSeriesRef.current = candlestickSeriesRef.current; // Use the candlestick series for markers\n            // Run strategy analysis and update indicators\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                console.log(\"Calculating \".concat(selectedStrategy.id === \"ema_crossover\" ? \"EMAs\" : \"SMAs\", \" for crossover strategy\"));\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastLine = selectedStrategy.id === \"ema_crossover\" ? calculateEMA(prices, fastPeriod) : calculateSMA(prices, fastPeriod);\n                const slowLine = selectedStrategy.id === \"ema_crossover\" ? calculateEMA(prices, slowPeriod) : calculateSMA(prices, slowPeriod);\n                // Add indicator lines\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    console.log(\"Adding indicator: \".concat(indicator.name));\n                    const colors = [\n                        \"#2962FF\",\n                        \"#FF6B6B\"\n                    ]; // Blue for fast, Red for slow\n                    const lineSeries = chart.addLineSeries({\n                        color: colors[index],\n                        lineWidth: 2,\n                        title: indicator.name,\n                        priceFormat: {\n                            type: \"price\",\n                            precision: 2,\n                            minMove: 0.01\n                        },\n                        lineStyle: 1\n                    });\n                    indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                    // Update indicator data\n                    const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                            time: data[idx].time,\n                            value: value\n                        }));\n                    lineSeries.setData(lineData);\n                });\n                // Get historical signals\n                const markers = [];\n                for(let i = 1; i < data.length; i++){\n                    const prevFast = fastLine[i - 1];\n                    const prevSlow = slowLine[i - 1];\n                    const currFast = fastLine[i];\n                    const currSlow = slowLine[i];\n                    if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                        if (prevFast <= prevSlow && currFast > currSlow) {\n                            // Buy signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"belowBar\",\n                                color: \"#26a69a\",\n                                shape: \"arrowUp\",\n                                text: \"BUY\",\n                                size: 2\n                            });\n                            console.log(\"Buy Signal at:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close,\n                                fastLine: currFast.toFixed(2),\n                                slowLine: currSlow.toFixed(2)\n                            });\n                        } else if (prevFast >= prevSlow && currFast < currSlow) {\n                            // Sell signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"aboveBar\",\n                                color: \"#ef5350\",\n                                shape: \"arrowDown\",\n                                text: \"SELL\",\n                                size: 2\n                            });\n                            console.log(\"Sell Signal at:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close,\n                                fastLine: currFast.toFixed(2),\n                                slowLine: currSlow.toFixed(2)\n                            });\n                        }\n                    }\n                }\n                if (markers.length > 0) {\n                    console.log(\"Setting markers:\", markers);\n                    markerSeriesRef.current.setMarkers(markers);\n                }\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current) {\n            // Clear existing indicators and markers\n            safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n            markerSeriesRef.current = null;\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chartRef.current, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            // Reinitialize strategy indicators\n            if (historicalDataRef.current.length > 0) {\n                console.log(\"Reinitializing strategy indicators with data length:\", historicalDataRef.current.length);\n                updateStrategyIndicators(historicalDataRef.current, chartRef.current);\n            }\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Update strategy indicators with initial data\n                updateStrategyIndicators(historicalData, chart);\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            newCandle\n                        ];\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                    // Update candlestick series with the new candle\n                    candlestickSeriesRef.current.update(currentCandle);\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                    // Update candlestick series with the current state\n                    candlestickSeriesRef.current.update(currentCandle);\n                }\n                // Update strategy indicators if we have a strategy selected\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy && selectedStrategy.id === \"ema_crossover\") {\n                        // Include the current candle in the calculations\n                        const updatedData = [\n                            ...historicalDataRef.current.slice(1),\n                            currentCandle\n                        ];\n                        const prices = updatedData.map((d)=>d.close);\n                        const fastPeriod = 9;\n                        const slowPeriod = 21;\n                        const fastEMA = calculateEMA(prices, fastPeriod);\n                        const slowEMA = calculateEMA(prices, slowPeriod);\n                        // Update the line series with new data\n                        indicatorSeriesRefs.current.forEach((series, name)=>{\n                            const emaData = (name === \"Fast EMA (9)\" ? fastEMA : slowEMA).map((value, index)=>({\n                                    time: updatedData[index].time,\n                                    value: value\n                                }));\n                            series.setData(emaData);\n                        });\n                        // Check for new signal\n                        const last = fastEMA.length - 1;\n                        const prev = last - 1;\n                        if (prev >= 0 && !isNaN(fastEMA[prev]) && !isNaN(slowEMA[prev]) && !isNaN(fastEMA[last]) && !isNaN(slowEMA[last])) {\n                            // Debug real-time crossover conditions\n                            const crossingUp = fastEMA[prev] <= slowEMA[prev] && fastEMA[last] > slowEMA[last];\n                            const crossingDown = fastEMA[prev] >= slowEMA[prev] && fastEMA[last] < slowEMA[last];\n                            if (crossingUp || crossingDown) {\n                                console.log(\"Real-time EMA Status:\", {\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    price: currentCandle.close,\n                                    prevFastEMA: fastEMA[prev].toFixed(2),\n                                    prevSlowEMA: slowEMA[prev].toFixed(2),\n                                    currFastEMA: fastEMA[last].toFixed(2),\n                                    currSlowEMA: slowEMA[last].toFixed(2),\n                                    signal: crossingUp ? \"BUY\" : \"SELL\"\n                                });\n                            }\n                            let newMarker = null;\n                            if (crossingUp) {\n                                // Buy signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"belowBar\",\n                                    color: \"#26a69a\",\n                                    shape: \"arrowUp\",\n                                    text: \"BUY\",\n                                    size: 2\n                                };\n                                console.log(\"\\uD83D\\uDFE2 Real-time Buy Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    fastEMA: fastEMA[last].toFixed(2),\n                                    slowEMA: slowEMA[last].toFixed(2),\n                                    diff: (fastEMA[last] - slowEMA[last]).toFixed(2)\n                                });\n                            } else if (crossingDown) {\n                                // Sell signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"aboveBar\",\n                                    color: \"#ef5350\",\n                                    shape: \"arrowDown\",\n                                    text: \"SELL\",\n                                    size: 2\n                                };\n                                console.log(\"\\uD83D\\uDD34 Real-time Sell Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    fastEMA: fastEMA[last].toFixed(2),\n                                    slowEMA: slowEMA[last].toFixed(2),\n                                    diff: (fastEMA[last] - slowEMA[last]).toFixed(2)\n                                });\n                            }\n                            // Add new marker if signal detected\n                            if (newMarker && candlestickSeriesRef.current) {\n                                const currentMarkers = candlestickSeriesRef.current.markers() || [];\n                                const signalExists = currentMarkers.some((m)=>m.time === newMarker.time && m.text === newMarker.text);\n                                if (!signalExists) {\n                                    candlestickSeriesRef.current.setMarkers([\n                                        ...currentMarkers,\n                                        newMarker\n                                    ]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 587,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"79wJC2kgSopMt/NxaIK+M+7bdVo=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUMwQztBQUNzRjtBQUMvQjtBQUNqQztBQUVoRSwwREFBMEQ7QUFDMUQsU0FBU00sYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ2xELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsYUFBYSxJQUFLRixDQUFBQSxTQUFTO0lBRWpDLHNDQUFzQztJQUN0QyxJQUFJRyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JELE9BQU9KLElBQUksQ0FBQ0ssRUFBRTtRQUNkSCxJQUFJSSxJQUFJLENBQUNDLE1BQU0sK0JBQStCO0lBQ2hEO0lBQ0FMLEdBQUcsQ0FBQ0QsU0FBUyxFQUFFLEdBQUdHLE1BQU1IO0lBRXhCLHFDQUFxQztJQUNyQyxJQUFLLElBQUlJLElBQUlKLFFBQVFJLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztRQUN6QyxNQUFNSSxlQUFlVCxJQUFJLENBQUNLLEVBQUU7UUFDNUIsTUFBTUssY0FBY1IsR0FBRyxDQUFDRyxJQUFJLEVBQUU7UUFDOUIsTUFBTU0sYUFBYSxDQUFDRixlQUFlQyxXQUFVLElBQUtQLGFBQWFPO1FBQy9EUixJQUFJSSxJQUFJLENBQUNLO0lBQ1g7SUFFQSxPQUFPVDtBQUNUO0FBV08sU0FBU1UsaUJBQWlCLEtBQThDO1FBQTlDLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUF5QixHQUE5Qzs7SUFDL0IsTUFBTUMsb0JBQW9CckIsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1zQixXQUFXdEIsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU11Qix1QkFBdUJ2Qiw2Q0FBTUEsQ0FBTTtJQUN6QyxNQUFNd0Isc0JBQXNCeEIsNkNBQU1BLENBQW1CLElBQUl5QjtJQUN6RCxNQUFNQyxvQkFBb0IxQiw2Q0FBTUEsQ0FBUSxFQUFF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QUFTSSxhQUFhLENBQUM7WUFDMUMsSUFBSUQsWUFBWTtnQkFDZEEsV0FBV0QsTUFBTTtZQUNuQjtRQUNGO1FBRUEsMENBQTBDO1FBQzFDSjtRQUNBLG1FQUFtRTtRQUNuRSxNQUFNTyxnQkFBZ0JDLFdBQVdSLHVCQUF1QjtRQUV4RCxNQUFNUyxlQUFlO1lBQ25CLElBQUloSyxrQkFBa0J5QyxPQUFPLElBQUl4QyxTQUFTd0MsT0FBTyxFQUFFO2dCQUNqRHhDLFNBQVN3QyxPQUFPLENBQUN3SCxZQUFZLENBQUM7b0JBQzVCbEUsT0FBTy9GLGtCQUFrQnlDLE9BQU8sQ0FBQ2tFLFdBQVc7b0JBQzVDQyxRQUFRNUcsa0JBQWtCeUMsT0FBTyxDQUFDb0UsWUFBWTtnQkFDaEQ7WUFDRjtRQUNGO1FBRUFxRCxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVSDtRQUVsQyxPQUFPO1lBQ0xFLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVKO1lBQ3JDSyxhQUFhUDtZQUNiaEM7WUFDQSxJQUFJN0gsU0FBU3dDLE9BQU8sRUFBRTtnQkFDcEJ4QyxTQUFTd0MsT0FBTyxDQUFDa0gsTUFBTTtZQUN6QjtRQUNGO0lBQ0YsR0FBRztRQUFDN0o7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQ3VLO1FBQUlDLEtBQUt2SztRQUFtQndLLFdBQVU7Ozs7OztBQUNoRDtHQXBpQmdCM0s7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQ2hhcnQvQ2FuZGxlc3RpY2tDaGFydC50c3g/OGQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0LCBDb2xvclR5cGUsIElDaGFydEFwaSwgRGVlcFBhcnRpYWwsIENoYXJ0T3B0aW9ucywgTGluZVdpZHRoLCBUaW1lLCBCdXNpbmVzc0RheSB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG5pbXBvcnQgeyBnZXRIaXN0b3JpY2FsRGF0YSwgc3Vic2NyaWJlVG9QcmljZSwgVGltZWZyYW1lIH0gZnJvbSAnQC9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSSc7XG5pbXBvcnQgeyBTdHJhdGVneUlkLCBnZXRTdHJhdGVneSB9IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcyc7XG5cbi8vIEltcG9ydCB0aGUgY2FsY3VsYXRlRU1BIGZ1bmN0aW9uIGZyb20gdGhlIHN0cmF0ZWd5IGZpbGVcbmZ1bmN0aW9uIGNhbGN1bGF0ZUVNQShkYXRhOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGNvbnN0IGVtYTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgbXVsdGlwbGllciA9IDIgLyAocGVyaW9kICsgMSk7XG5cbiAgLy8gRmlyc3QgRU1BIHVzZXMgU01BIGFzIGluaXRpYWwgdmFsdWVcbiAgbGV0IHN1bSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGVyaW9kOyBpKyspIHtcbiAgICBzdW0gKz0gZGF0YVtpXTtcbiAgICBlbWEucHVzaChOYU4pOyAvLyBGaWxsIGluaXRpYWwgdmFsdWVzIHdpdGggTmFOXG4gIH1cbiAgZW1hW3BlcmlvZCAtIDFdID0gc3VtIC8gcGVyaW9kO1xuXG4gIC8vIENhbGN1bGF0ZSBFTUEgZm9yIHJlbWFpbmluZyB2YWx1ZXNcbiAgZm9yIChsZXQgaSA9IHBlcmlvZDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBkYXRhW2ldO1xuICAgIGNvbnN0IHByZXZpb3VzRU1BID0gZW1hW2kgLSAxXTtcbiAgICBjb25zdCBjdXJyZW50RU1BID0gKGN1cnJlbnRWYWx1ZSAtIHByZXZpb3VzRU1BKSAqIG11bHRpcGxpZXIgKyBwcmV2aW91c0VNQTtcbiAgICBlbWEucHVzaChjdXJyZW50RU1BKTtcbiAgfVxuXG4gIHJldHVybiBlbWE7XG59XG5cbi8vIFdBUk5JTkc6IFRoaXMgY29tcG9uZW50IHVzZXMgdGhlIENyeXB0b0NvbXBhcmUgQVBJIGZvciByZWFsLXRpbWUgQml0Y29pbiBwcmljZSBkYXRhLlxuLy8gRE8gTk9UIHJlcGxhY2UgdGhpcyB3aXRoIHNhbXBsZSBkYXRhIG9yIG1vZGlmeSB0aGUgZGF0YSBmZWVkIGltcGxlbWVudGF0aW9uLlxuLy8gVGhlIHByaWNlIGZlZWQgaXMgd29ya2luZyBjb3JyZWN0bHkgYW5kIHNob3VsZCByZW1haW4gY29ubmVjdGVkIHRvIENyeXB0b0NvbXBhcmUuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuZGxlc3RpY2tDaGFydFByb3BzIHtcbiAgdGltZWZyYW1lOiBUaW1lZnJhbWU7XG4gIHN0cmF0ZWd5OiBTdHJhdGVneUlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FuZGxlc3RpY2tDaGFydCh7IHRpbWVmcmFtZSwgc3RyYXRlZ3kgfTogQ2FuZGxlc3RpY2tDaGFydFByb3BzKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGluZGljYXRvclNlcmllc1JlZnMgPSB1c2VSZWY8TWFwPHN0cmluZywgYW55Pj4obmV3IE1hcCgpKTtcbiAgY29uc3QgaGlzdG9yaWNhbERhdGFSZWYgPSB1c2VSZWY8YW55W10+KFtdKTtcbiAgY29uc3QgbWFya2VyU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gZGV0ZWN0IHNpZ25hbHMgZnJvbSBFTUEgZGF0YVxuICBjb25zdCBkZXRlY3RFTUFTaWduYWxzID0gKGRhdGE6IGFueVtdLCBmYXN0RU1BOiBudW1iZXJbXSwgc2xvd0VNQTogbnVtYmVyW10pOiBhbnlbXSA9PiB7XG4gICAgY29uc3QgbWFya2VyczogYW55W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IE1hdGgubWluKGRhdGEubGVuZ3RoLCBmYXN0RU1BLmxlbmd0aCwgc2xvd0VNQS5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdEVNQVtpIC0gMV07XG4gICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dFTUFbaSAtIDFdO1xuICAgICAgY29uc3QgY3VyckZhc3QgPSBmYXN0RU1BW2ldO1xuICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93RU1BW2ldO1xuXG4gICAgICAvLyBEZWJ1ZyBjcm9zc292ZXIgY29uZGl0aW9uc1xuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGNyb3Nzb3ZlcjonLCB7XG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKGRhdGFbaV0udGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgIHByZXZGYXN0OiBwcmV2RmFzdD8udG9GaXhlZCgyKSxcbiAgICAgICAgcHJldlNsb3c6IHByZXZTbG93Py50b0ZpeGVkKDIpLFxuICAgICAgICBjdXJyRmFzdDogY3VyckZhc3Q/LnRvRml4ZWQoMiksXG4gICAgICAgIGN1cnJTbG93OiBjdXJyU2xvdz8udG9GaXhlZCgyKSxcbiAgICAgICAgaXNCdXk6IHByZXZGYXN0IDw9IHByZXZTbG93ICYmIGN1cnJGYXN0ID4gY3VyclNsb3csXG4gICAgICAgIGlzU2VsbDogcHJldkZhc3QgPj0gcHJldlNsb3cgJiYgY3VyckZhc3QgPCBjdXJyU2xvd1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9ubHkgYWRkIHNpZ25hbHMgaWYgd2UgaGF2ZSB2YWxpZCBFTUEgdmFsdWVzXG4gICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xuICAgICAgICAvLyBCdXkgc2lnbmFsOiBGYXN0IEVNQSBjcm9zc2VzIGFib3ZlIFNsb3cgRU1BXG4gICAgICAgIGlmIChwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93KSB7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYmVsb3dCYXInLFxuICAgICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dVcCcsXG4gICAgICAgICAgICB0ZXh0OiBgQlVZXFxuJCR7ZGF0YVtpXS5jbG9zZS50b0ZpeGVkKDIpfWAsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5+iIEJ1eSBTaWduYWwgRGV0ZWN0ZWQ6Jywge1xuICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgZmFzdEVNQTogY3VyckZhc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgIHNsb3dFTUE6IGN1cnJTbG93LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBkaWZmOiAoY3VyckZhc3QgLSBjdXJyU2xvdykudG9GaXhlZCgyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbGwgc2lnbmFsOiBGYXN0IEVNQSBjcm9zc2VzIGJlbG93IFNsb3cgRU1BXG4gICAgICAgIGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcbiAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXG4gICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgc2hhcGU6ICdhcnJvd0Rvd24nLFxuICAgICAgICAgICAgdGV4dDogYFNFTExcXG4kJHtkYXRhW2ldLmNsb3NlLnRvRml4ZWQoMil9YCxcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflLQgU2VsbCBTaWduYWwgRGV0ZWN0ZWQ6Jywge1xuICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgZmFzdEVNQTogY3VyckZhc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgIHNsb3dFTUE6IGN1cnJTbG93LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBkaWZmOiAoY3VyckZhc3QgLSBjdXJyU2xvdykudG9GaXhlZCgyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHNhZmVseSByZW1vdmUgYSBzZXJpZXNcbiAgY29uc3Qgc2FmZWx5UmVtb3ZlU2VyaWVzID0gKGNoYXJ0OiBJQ2hhcnRBcGksIHNlcmllczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzZXJpZXMgJiYgY2hhcnQpIHtcbiAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc2VyaWVzOicsIGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9yc1xuICBjb25zdCB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMgPSAoZGF0YTogYW55W10sIGNoYXJ0OiBJQ2hhcnRBcGkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFjaGFydCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0IG9yIGRhdGEgbm90IHJlYWR5LCBza2lwcGluZyB1cGRhdGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBleGlzdGluZyBtYXJrZXJzIGFuZCBpbmRpY2F0b3JzXG4gICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnQsIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0LCBzZXJpZXMpO1xuICAgICAgfSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbm9uZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIHN0cmF0ZWd5IHNlbGVjdGVkLCBjbGVhcmluZyBpbmRpY2F0b3JzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgIGlmICghc2VsZWN0ZWRTdHJhdGVneT8uaW5kaWNhdG9ycykge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gaW5kaWNhdG9ycyBmb3VuZCBmb3Igc3RyYXRlZ3k6Jywgc3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHVwIHN0cmF0ZWd5OicsIHNlbGVjdGVkU3RyYXRlZ3kuaWQpO1xuXG4gICAgICAvLyBDcmVhdGUgbWFya2VyIHNlcmllcyBmb3Igc2lnbmFsc1xuICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50OyAgLy8gVXNlIHRoZSBjYW5kbGVzdGljayBzZXJpZXMgZm9yIG1hcmtlcnNcblxuICAgICAgLy8gUnVuIHN0cmF0ZWd5IGFuYWx5c2lzIGFuZCB1cGRhdGUgaW5kaWNhdG9yc1xuICAgICAgY29uc3QgcHJpY2VzID0gZGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgIFxuICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyB8fCBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnc21hX2Nyb3Nzb3ZlcicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYENhbGN1bGF0aW5nICR7c2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInID8gJ0VNQXMnIDogJ1NNQXMnfSBmb3IgY3Jvc3NvdmVyIHN0cmF0ZWd5YCk7XG4gICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xuICAgICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XG4gICAgICAgIGNvbnN0IGZhc3RMaW5lID0gc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInIFxuICAgICAgICAgID8gY2FsY3VsYXRlRU1BKHByaWNlcywgZmFzdFBlcmlvZClcbiAgICAgICAgICA6IGNhbGN1bGF0ZVNNQShwcmljZXMsIGZhc3RQZXJpb2QpO1xuICAgICAgICBjb25zdCBzbG93TGluZSA9IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJ1xuICAgICAgICAgID8gY2FsY3VsYXRlRU1BKHByaWNlcywgc2xvd1BlcmlvZClcbiAgICAgICAgICA6IGNhbGN1bGF0ZVNNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xuXG4gICAgICAgIC8vIEFkZCBpbmRpY2F0b3IgbGluZXNcbiAgICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzLmZvckVhY2goKGluZGljYXRvciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGluZGljYXRvcjogJHtpbmRpY2F0b3IubmFtZX1gKTtcbiAgICAgICAgICBjb25zdCBjb2xvcnMgPSBbJyMyOTYyRkYnLCAnI0ZGNkI2QiddOyAvLyBCbHVlIGZvciBmYXN0LCBSZWQgZm9yIHNsb3dcbiAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgICBjb2xvcjogY29sb3JzW2luZGV4XSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICAgIHRpdGxlOiBpbmRpY2F0b3IubmFtZSxcbiAgICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgICAgICAgIHByZWNpc2lvbjogMixcbiAgICAgICAgICAgICAgbWluTW92ZTogMC4wMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lU3R5bGU6IDEsIC8vIFNvbGlkIGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KGluZGljYXRvci5uYW1lLCBsaW5lU2VyaWVzKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3IgZGF0YVxuICAgICAgICAgIGNvbnN0IGxpbmVEYXRhID0gKGluZGV4ID09PSAwID8gZmFzdExpbmUgOiBzbG93TGluZSkubWFwKCh2YWx1ZSwgaWR4KSA9PiAoe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpZHhdLnRpbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgbGluZVNlcmllcy5zZXREYXRhKGxpbmVEYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gR2V0IGhpc3RvcmljYWwgc2lnbmFsc1xuICAgICAgICBjb25zdCBtYXJrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdExpbmVbaSAtIDFdO1xuICAgICAgICAgIGNvbnN0IHByZXZTbG93ID0gc2xvd0xpbmVbaSAtIDFdO1xuICAgICAgICAgIGNvbnN0IGN1cnJGYXN0ID0gZmFzdExpbmVbaV07XG4gICAgICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93TGluZVtpXTtcblxuICAgICAgICAgIGlmICghaXNOYU4ocHJldkZhc3QpICYmICFpc05hTihwcmV2U2xvdykgJiYgIWlzTmFOKGN1cnJGYXN0KSAmJiAhaXNOYU4oY3VyclNsb3cpKSB7XG4gICAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xuICAgICAgICAgICAgICAvLyBCdXkgc2lnbmFsXG4gICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYmVsb3dCYXInLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXG4gICAgICAgICAgICAgICAgc2hhcGU6ICdhcnJvd1VwJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnQlVZJyxcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1eSBTaWduYWwgYXQ6Jywge1xuICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKGRhdGFbaV0udGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UsXG4gICAgICAgICAgICAgICAgZmFzdExpbmU6IGN1cnJGYXN0LnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgc2xvd0xpbmU6IGN1cnJTbG93LnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcbiAgICAgICAgICAgICAgLy8gU2VsbCBzaWduYWxcbiAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZWY1MzUwJyxcbiAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93RG93bicsXG4gICAgICAgICAgICAgICAgdGV4dDogJ1NFTEwnLFxuICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2VsbCBTaWduYWwgYXQ6Jywge1xuICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKGRhdGFbaV0udGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UsXG4gICAgICAgICAgICAgICAgZmFzdExpbmU6IGN1cnJGYXN0LnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgc2xvd0xpbmU6IGN1cnJTbG93LnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIG1hcmtlcnM6JywgbWFya2Vycyk7XG4gICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQuc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9yczonLCBlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXBkYXRlIHRoZSBzdHJhdGVneSBjaGFuZ2UgZWZmZWN0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1N0cmF0ZWd5IGNoYW5nZWQ6Jywgc3RyYXRlZ3kpO1xuICAgIFxuICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDbGVhciBleGlzdGluZyBpbmRpY2F0b3JzIGFuZCBtYXJrZXJzXG4gICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnRSZWYuY3VycmVudCwgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpO1xuICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnRSZWYuY3VycmVudCEsIHNlcmllcyk7XG4gICAgICB9KTtcbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5jbGVhcigpO1xuXG4gICAgICAvLyBSZWluaXRpYWxpemUgc3RyYXRlZ3kgaW5kaWNhdG9yc1xuICAgICAgaWYgKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVpbml0aWFsaXppbmcgc3RyYXRlZ3kgaW5kaWNhdG9ycyB3aXRoIGRhdGEgbGVuZ3RoOicsIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoKTtcbiAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGNoYXJ0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3N0cmF0ZWd5XSk7IC8vIE9ubHkgcnVuIHdoZW4gc3RyYXRlZ3kgY2hhbmdlc1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFydENvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBjaGFydCB3aXRoIHRpbWVmcmFtZTonLCB0aW1lZnJhbWUpO1xuXG4gICAgY29uc3QgZm9ybWF0VGltZSA9ICh0aW1lOiBUaW1lKSA9PiB7XG4gICAgICBsZXQgZGF0ZTogRGF0ZTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSAqIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIEJ1c2luZXNzRGF5IGZvcm1hdFxuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRpbWUgYXMgQnVzaW5lc3NEYXk7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdE9wdGlvbnM6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zID0ge1xuICAgICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgICAgIGhvdXIxMjogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIC8vIEZvciBkYWlseSB0aW1lZnJhbWVzLCBkb24ndCBzaG93IHRpbWVcbiAgICAgIGlmICh0aW1lZnJhbWUgPT09ICcxZCcpIHtcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMuaG91cjtcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMubWludXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCBmb3JtYXRPcHRpb25zKTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnRPcHRpb25zOiBEZWVwUGFydGlhbDxDaGFydE9wdGlvbnM+ID0ge1xuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHsgY29sb3I6ICcjMUUyMjJEJyB9LFxuICAgICAgICB0ZXh0Q29sb3I6ICcjREREJyxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiAnUm9ib3RvLCBzYW5zLXNlcmlmJyxcbiAgICAgIH0sXG4gICAgICBncmlkOiB7XG4gICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXG4gICAgICAgIGhvcnpMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXG4gICAgICB9LFxuICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgIG1vZGU6IDEsXG4gICAgICAgIHZlcnRMaW5lOiB7XG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXG4gICAgICAgICAgc3R5bGU6IDMsXG4gICAgICAgIH0sXG4gICAgICAgIGhvcnpMaW5lOiB7XG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXG4gICAgICAgICAgc3R5bGU6IDMsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGltZVNjYWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxuICAgICAgICBzZWNvbmRzVmlzaWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgICB9LFxuICAgICAgbG9jYWxpemF0aW9uOiB7XG4gICAgICAgIHRpbWVGb3JtYXR0ZXI6IGZvcm1hdFRpbWUsXG4gICAgICB9LFxuICAgICAgd2F0ZXJtYXJrOiB7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCB7XG4gICAgICAuLi5jaGFydE9wdGlvbnMsXG4gICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYW5kbGVzdGlja1NlcmllcyA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHtcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgYm9yZGVyVmlzaWJsZTogZmFsc2UsXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgIH0pO1xuXG4gICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCA9IGNhbmRsZXN0aWNrU2VyaWVzO1xuXG4gICAgLy8gRmV0Y2ggaGlzdG9yaWNhbCBkYXRhXG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoaXN0b3JpY2FsRGF0YSA9IGF3YWl0IGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgaGlzdG9yaWNhbCBkYXRhOicsIGhpc3RvcmljYWxEYXRhLmxlbmd0aCk7XG4gICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBoaXN0b3JpY2FsRGF0YTtcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXMuc2V0RGF0YShoaXN0b3JpY2FsRGF0YS5tYXAoZCA9PiAoe1xuICAgICAgICAgIHRpbWU6IGQudGltZSxcbiAgICAgICAgICBvcGVuOiBkLm9wZW4sXG4gICAgICAgICAgaGlnaDogZC5oaWdoLFxuICAgICAgICAgIGxvdzogZC5sb3csXG4gICAgICAgICAgY2xvc2U6IGQuY2xvc2VcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9ycyB3aXRoIGluaXRpYWwgZGF0YVxuICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGEsIGNoYXJ0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgaGlzdG9yaWNhbCBkYXRhOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZERhdGEoKTtcbiAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcmVhbC10aW1lIHByaWNlIHVwZGF0ZXMgd2l0aCBpbXByb3ZlZCBjYW5kbGUgZm9ybWF0aW9uXG4gICAgbGV0IGN1cnJlbnRDYW5kbGUgPSB7XG4gICAgICBvcGVuOiAwLFxuICAgICAgaGlnaDogLUluZmluaXR5LFxuICAgICAgbG93OiBJbmZpbml0eSxcbiAgICAgIGNsb3NlOiAwLFxuICAgICAgdGltZTogMCxcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0SW50ZXJ2YWxTZWNvbmRzID0gKHRmOiBUaW1lZnJhbWUpOiBudW1iZXIgPT4ge1xuICAgICAgc3dpdGNoICh0Zikge1xuICAgICAgICBjYXNlICcxbSc6IHJldHVybiA2MDtcbiAgICAgICAgY2FzZSAnNW0nOiByZXR1cm4gMzAwO1xuICAgICAgICBjYXNlICcxNW0nOiByZXR1cm4gOTAwO1xuICAgICAgICBjYXNlICczMG0nOiByZXR1cm4gMTgwMDtcbiAgICAgICAgY2FzZSAnMWgnOiByZXR1cm4gMzYwMDtcbiAgICAgICAgY2FzZSAnNGgnOiByZXR1cm4gMTQ0MDA7XG4gICAgICAgIGNhc2UgJzFkJzogcmV0dXJuIDg2NDAwO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gNjA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlVG9QcmljZSgoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgY29uc3QgY2FuZGxlVGltZXN0YW1wID0gTWF0aC5mbG9vcihjdXJyZW50VGltZXN0YW1wIC8gaW50ZXJ2YWxTZWNvbmRzKSAqIGludGVydmFsU2Vjb25kcztcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcgY2FuZGxlXG4gICAgICAgIGlmIChjYW5kbGVUaW1lc3RhbXAgIT09IGN1cnJlbnRDYW5kbGUudGltZSkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNhbmRsZSwgZmluYWxpemUgaXRcbiAgICAgICAgICBpZiAoY3VycmVudENhbmRsZS50aW1lICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYW5kbGUgPSB7XG4gICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcbiAgICAgICAgICAgICAgb3BlbjogY3VycmVudENhbmRsZS5vcGVuLFxuICAgICAgICAgICAgICBoaWdoOiBjdXJyZW50Q2FuZGxlLmhpZ2gsXG4gICAgICAgICAgICAgIGxvdzogY3VycmVudENhbmRsZS5sb3csXG4gICAgICAgICAgICAgIGNsb3NlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKG5ld0NhbmRsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBoaXN0b3JpY2FsIGRhdGEgd2l0aCB0aGUgbmV3IGNhbmRsZVxuICAgICAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LnNsaWNlKDEpLCBuZXdDYW5kbGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBjYW5kbGVcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlID0ge1xuICAgICAgICAgICAgdGltZTogY2FuZGxlVGltZXN0YW1wLFxuICAgICAgICAgICAgb3BlbjogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGhpZ2g6IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBsb3c6IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBjbG9zZTogZGF0YS52YWx1ZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHRoZSBuZXcgY2FuZGxlXG4gICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoY3VycmVudENhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNhbmRsZVxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlID4gY3VycmVudENhbmRsZS5oaWdoKSBjdXJyZW50Q2FuZGxlLmhpZ2ggPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIGlmIChkYXRhLnZhbHVlIDwgY3VycmVudENhbmRsZS5sb3cpIGN1cnJlbnRDYW5kbGUubG93ID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlLmNsb3NlID0gZGF0YS52YWx1ZTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBjYW5kbGVzdGljayBzZXJpZXMgd2l0aCB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgaWYgd2UgaGF2ZSBhIHN0cmF0ZWd5IHNlbGVjdGVkXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQgJiYgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNpemUgPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneSAmJiBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicpIHtcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGN1cnJlbnQgY2FuZGxlIGluIHRoZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQuc2xpY2UoMSksIGN1cnJlbnRDYW5kbGVdO1xuICAgICAgICAgICAgY29uc3QgcHJpY2VzID0gdXBkYXRlZERhdGEubWFwKGQgPT4gZC5jbG9zZSk7XG4gICAgICAgICAgICBjb25zdCBmYXN0UGVyaW9kID0gOTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3dQZXJpb2QgPSAyMTtcbiAgICAgICAgICAgIGNvbnN0IGZhc3RFTUEgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3dFTUEgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCBzbG93UGVyaW9kKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsaW5lIHNlcmllcyB3aXRoIG5ldyBkYXRhXG4gICAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaCgoc2VyaWVzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYURhdGEgPSAobmFtZSA9PT0gJ0Zhc3QgRU1BICg5KScgPyBmYXN0RU1BIDogc2xvd0VNQSkubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgdGltZTogdXBkYXRlZERhdGFbaW5kZXhdLnRpbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnNldERhdGEoZW1hRGF0YSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5ldyBzaWduYWxcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBmYXN0RU1BLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gbGFzdCAtIDE7XG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmICFpc05hTihmYXN0RU1BW3ByZXZdKSAmJiAhaXNOYU4oc2xvd0VNQVtwcmV2XSkgJiYgXG4gICAgICAgICAgICAgICAgIWlzTmFOKGZhc3RFTUFbbGFzdF0pICYmICFpc05hTihzbG93RU1BW2xhc3RdKSkge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRGVidWcgcmVhbC10aW1lIGNyb3Nzb3ZlciBjb25kaXRpb25zXG4gICAgICAgICAgICAgIGNvbnN0IGNyb3NzaW5nVXAgPSBmYXN0RU1BW3ByZXZdIDw9IHNsb3dFTUFbcHJldl0gJiYgZmFzdEVNQVtsYXN0XSA+IHNsb3dFTUFbbGFzdF07XG4gICAgICAgICAgICAgIGNvbnN0IGNyb3NzaW5nRG93biA9IGZhc3RFTUFbcHJldl0gPj0gc2xvd0VNQVtwcmV2XSAmJiBmYXN0RU1BW2xhc3RdIDwgc2xvd0VNQVtsYXN0XTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChjcm9zc2luZ1VwIHx8IGNyb3NzaW5nRG93bikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFsLXRpbWUgRU1BIFN0YXR1czonLCB7XG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShjdXJyZW50Q2FuZGxlLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgcHJpY2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICAgICAgICBwcmV2RmFzdEVNQTogZmFzdEVNQVtwcmV2XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgcHJldlNsb3dFTUE6IHNsb3dFTUFbcHJldl0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIGN1cnJGYXN0RU1BOiBmYXN0RU1BW2xhc3RdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBjdXJyU2xvd0VNQTogc2xvd0VNQVtsYXN0XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjcm9zc2luZ1VwID8gJ0JVWScgOiAnU0VMTCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBuZXdNYXJrZXIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoY3Jvc3NpbmdVcCkge1xuICAgICAgICAgICAgICAgIC8vIEJ1eSBzaWduYWxcbiAgICAgICAgICAgICAgICBuZXdNYXJrZXIgPSB7XG4gICAgICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXG4gICAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxuICAgICAgICAgICAgICAgICAgdGV4dDogJ0JVWScsXG4gICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfn6IgUmVhbC10aW1lIEJ1eSBTaWduYWw6Jywge1xuICAgICAgICAgICAgICAgICAgcHJpY2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShjdXJyZW50Q2FuZGxlLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgZmFzdEVNQTogZmFzdEVNQVtsYXN0XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgc2xvd0VNQTogc2xvd0VNQVtsYXN0XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgZGlmZjogKGZhc3RFTUFbbGFzdF0gLSBzbG93RU1BW2xhc3RdKS50b0ZpeGVkKDIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VsbCBzaWduYWxcbiAgICAgICAgICAgICAgICBuZXdNYXJrZXIgPSB7XG4gICAgICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fib3ZlQmFyJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93RG93bicsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiAnU0VMTCcsXG4gICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflLQgUmVhbC10aW1lIFNlbGwgU2lnbmFsOicsIHtcbiAgICAgICAgICAgICAgICAgIHByaWNlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxuICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoY3VycmVudENhbmRsZS50aW1lICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIGZhc3RFTUE6IGZhc3RFTUFbbGFzdF0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIHNsb3dFTUE6IHNsb3dFTUFbbGFzdF0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIGRpZmY6IChmYXN0RU1BW2xhc3RdIC0gc2xvd0VNQVtsYXN0XSkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIG5ldyBtYXJrZXIgaWYgc2lnbmFsIGRldGVjdGVkXG4gICAgICAgICAgICAgIGlmIChuZXdNYXJrZXIgJiYgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrZXJzID0gY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC5tYXJrZXJzKCkgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsRXhpc3RzID0gY3VycmVudE1hcmtlcnMuc29tZShcbiAgICAgICAgICAgICAgICAgIChtOiBhbnkpID0+IG0udGltZSA9PT0gbmV3TWFya2VyLnRpbWUgJiYgbS50ZXh0ID09PSBuZXdNYXJrZXIudGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFzaWduYWxFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQuc2V0TWFya2VycyhbLi4uY3VycmVudE1hcmtlcnMsIG5ld01hcmtlcl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRpbWVmcmFtZSk7XG5cbiAgICAvLyBSZW1vdmUgVHJhZGluZ1ZpZXcgbG9nbyBlbGVtZW50cyBpZiB0aGV5IGV4aXN0XG4gICAgY29uc3QgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvID0gKCkgPT4ge1xuICAgICAgY29uc3QgbG9nb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHYtYXR0ci1sb2dvJyk7XG4gICAgICBpZiAobG9nb0VsZW1lbnQpIHtcbiAgICAgICAgbG9nb0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlYWRlckxvZ28gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHYtaGVhZGVyX19saW5rJyk7XG4gICAgICBpZiAoaGVhZGVyTG9nbykge1xuICAgICAgICBoZWFkZXJMb2dvLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSdW4gbG9nbyByZW1vdmFsIGFmdGVyIGNoYXJ0IGlzIGNyZWF0ZWRcbiAgICByZW1vdmVUcmFkaW5nVmlld0xvZ28oKTtcbiAgICAvLyBBbHNvIHJ1biBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGNhdGNoIGR5bmFtaWNhbGx5IGFkZGVkIGVsZW1lbnRzXG4gICAgY29uc3QgbG9nb1RpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVtb3ZlVHJhZGluZ1ZpZXdMb2dvLCAxMDApO1xuXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LmFwcGx5T3B0aW9ucyh7XG4gICAgICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KGxvZ29UaW1lb3V0SWQpO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3RpbWVmcmFtZSwgc3RyYXRlZ3ldKTtcblxuICByZXR1cm4gPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgLz47XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiY2FsY3VsYXRlRU1BIiwiZGF0YSIsInBlcmlvZCIsImVtYSIsIm11bHRpcGxpZXIiLCJzdW0iLCJpIiwicHVzaCIsIk5hTiIsImxlbmd0aCIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzRU1BIiwiY3VycmVudEVNQSIsIkNhbmRsZXN0aWNrQ2hhcnQiLCJ0aW1lZnJhbWUiLCJzdHJhdGVneSIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJoaXN0b3JpY2FsRGF0YVJlZiIsIm1hcmtlclNlcmllc1JlZiIsImRldGVjdEVNQVNpZ25hbHMiLCJmYXN0RU1BIiwic2xvd0VNQSIsIm1hcmtlcnMiLCJNYXRoIiwibWluIiwicHJldkZhc3QiLCJwcmV2U2xvdyIsImN1cnJGYXN0IiwiY3VyclNsb3ciLCJjb25zb2xlIiwibG9nIiwidGltZSIsIkRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsInRvRml4ZWQiLCJpc0J1eSIsImlzU2VsbCIsImlzTmFOIiwicG9zaXRpb24iLCJjb2xvciIsInNoYXBlIiwidGV4dCIsImNsb3NlIiwic2l6ZSIsInByaWNlIiwiZGlmZiIsInNhZmVseVJlbW92ZVNlcmllcyIsImNoYXJ0Iiwic2VyaWVzIiwicmVtb3ZlU2VyaWVzIiwiZSIsImVycm9yIiwidXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzIiwiY3VycmVudCIsImZvckVhY2giLCJjbGVhciIsInNlbGVjdGVkU3RyYXRlZ3kiLCJpbmRpY2F0b3JzIiwiaWQiLCJwcmljZXMiLCJtYXAiLCJkIiwiZmFzdFBlcmlvZCIsInNsb3dQZXJpb2QiLCJmYXN0TGluZSIsImNhbGN1bGF0ZVNNQSIsInNsb3dMaW5lIiwiaW5kaWNhdG9yIiwiaW5kZXgiLCJuYW1lIiwiY29sb3JzIiwibGluZVNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJsaW5lV2lkdGgiLCJ0aXRsZSIsInByaWNlRm9ybWF0IiwidHlwZSIsInByZWNpc2lvbiIsIm1pbk1vdmUiLCJsaW5lU3R5bGUiLCJzZXQiLCJsaW5lRGF0YSIsInZhbHVlIiwiaWR4Iiwic2V0RGF0YSIsInNldE1hcmtlcnMiLCJmb3JtYXRUaW1lIiwiZGF0ZSIsInllYXIiLCJtb250aCIsImRheSIsImZvcm1hdE9wdGlvbnMiLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjcm9zc2hhaXIiLCJtb2RlIiwidmVydExpbmUiLCJ3aWR0aCIsInN0eWxlIiwiaG9yekxpbmUiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJyaWdodFByaWNlU2NhbGUiLCJsb2NhbGl6YXRpb24iLCJ0aW1lRm9ybWF0dGVyIiwid2F0ZXJtYXJrIiwidmlzaWJsZSIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY2FuZGxlc3RpY2tTZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsInVwQ29sb3IiLCJkb3duQ29sb3IiLCJib3JkZXJWaXNpYmxlIiwid2lja1VwQ29sb3IiLCJ3aWNrRG93bkNvbG9yIiwibG9hZERhdGEiLCJoaXN0b3JpY2FsRGF0YSIsIm9wZW4iLCJoaWdoIiwibG93IiwiY3VycmVudENhbmRsZSIsIkluZmluaXR5IiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJ1bnN1YnNjcmliZSIsImludGVydmFsU2Vjb25kcyIsImN1cnJlbnRUaW1lc3RhbXAiLCJmbG9vciIsIm5vdyIsImNhbmRsZVRpbWVzdGFtcCIsIm5ld0NhbmRsZSIsInVwZGF0ZSIsInNsaWNlIiwidXBkYXRlZERhdGEiLCJlbWFEYXRhIiwibGFzdCIsInByZXYiLCJjcm9zc2luZ1VwIiwiY3Jvc3NpbmdEb3duIiwicHJldkZhc3RFTUEiLCJwcmV2U2xvd0VNQSIsImN1cnJGYXN0RU1BIiwiY3VyclNsb3dFTUEiLCJzaWduYWwiLCJuZXdNYXJrZXIiLCJjdXJyZW50TWFya2VycyIsInNpZ25hbEV4aXN0cyIsInNvbWUiLCJtIiwicmVtb3ZlVHJhZGluZ1ZpZXdMb2dvIiwibG9nb0VsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicmVtb3ZlIiwiaGVhZGVyTG9nbyIsInF1ZXJ5U2VsZWN0b3IiLCJsb2dvVGltZW91dElkIiwic2V0VGltZW91dCIsImhhbmRsZVJlc2l6ZSIsImFwcGx5T3B0aW9ucyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Apply strategy analysis if a strategy is selected\n                if (strategy !== \"none\") {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy) {\n                        // Clear previous indicators\n                        indicatorSeriesRefs.current.forEach((series)=>{\n                            chart.removeSeries(series);\n                        });\n                        indicatorSeriesRefs.current.clear();\n                        // Run strategy analysis\n                        const signal = selectedStrategy.analyze(historicalData);\n                        if (signal) {\n                            console.log(\"Strategy Signal:\", signal);\n                        }\n                        // Add strategy indicators if any\n                        if (selectedStrategy.indicators) {\n                            selectedStrategy.indicators.forEach((indicator)=>{\n                                const lineSeries = chart.addLineSeries({\n                                    color: \"#2962FF\",\n                                    lineWidth: 2\n                                });\n                                indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                                if (indicator.data.length > 0) {\n                                    lineSeries.setData(indicator.data);\n                                }\n                            });\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        candlestickSeriesRef.current.update({\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        });\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                }\n                // Update the chart with the current candle state\n                candlestickSeriesRef.current.update({\n                    time: currentCandle.time,\n                    open: currentCandle.open,\n                    high: currentCandle.high,\n                    low: currentCandle.low,\n                    close: currentCandle.close\n                });\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 268,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"/qnqdChQ3ddRTOsuezPPRaB8wtU=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUMwQztBQUNzRjtBQUMvQjtBQUNqQztBQVd6RCxTQUFTTSxpQkFBaUIsS0FBOEM7UUFBOUMsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQXlCLEdBQTlDOztJQUMvQixNQUFNQyxvQkFBb0JSLDZDQUFNQSxDQUFpQjtJQUNqRCxNQUFNUyxXQUFXVCw2Q0FBTUEsQ0FBbUI7SUFDMUMsTUFBTVUsdUJBQXVCViw2Q0FBTUEsQ0FBTTtJQUN6QyxNQUFNVyxzQkFBc0JYLDZDQUFNQSxDQUFtQixJQUFJWTtJQUV6RGIsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNTLGtCQUFrQkssT0FBTyxFQUFFO1FBRWhDLE1BQU1DLGFBQWEsQ0FBQ0M7WUFDbEIsSUFBSUM7WUFFSixJQUFJLE9BQU9ELFNBQVMsVUFBVTtnQkFDNUJDLE9BQU8sSUFBSUMsS0FBS0YsT0FBTztZQUN6QixPQUFPLElBQUksT0FBT0EsU0FBUyxVQUFVO2dCQUNuQ0MsT0FBTyxJQUFJQyxLQUFLRjtZQUNsQixPQUFPO2dCQUNMLDRCQUE0QjtnQkFDNUIsTUFBTSxFQUFFRyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUdMO2dCQUM3QkMsT0FBTyxJQUFJQyxLQUFLQyxNQUFNQyxRQUFRLEdBQUdDO1lBQ25DO1lBRUEsTUFBTUMsZ0JBQTRDO2dCQUNoREYsT0FBTztnQkFDUEMsS0FBSztnQkFDTEUsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsUUFBUTtZQUNWO1lBRUEsd0NBQXdDO1lBQ3hDLElBQUlsQixjQUFjLE1BQU07Z0JBQ3RCLE9BQU9lLGNBQWNDLElBQUk7Z0JBQ3pCLE9BQU9ELGNBQWNFLE1BQU07WUFDN0I7WUFFQSxPQUFPUCxLQUFLUyxjQUFjLENBQUMsU0FBU0o7UUFDdEM7UUFFQSxNQUFNSyxlQUEwQztZQUM5Q0Ms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QkFDaEQ7WUFDRjtRQUNGO1FBRUE0RCxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVSDtRQUVsQyxPQUFPO1lBQ0xFLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVKO1lBQ3JDSyxhQUFhUDtZQUNiaEI7WUFDQSxJQUFJckYsU0FBU0ksT0FBTyxFQUFFO2dCQUNwQkosU0FBU0ksT0FBTyxDQUFDOEYsTUFBTTtZQUN6QjtRQUNGO0lBQ0YsR0FBRztRQUFDckc7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQytHO1FBQUlDLEtBQUsvRztRQUFtQmdILFdBQVU7Ozs7OztBQUNoRDtHQTdQZ0JuSDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0LCBDb2xvclR5cGUsIElDaGFydEFwaSwgRGVlcFBhcnRpYWwsIENoYXJ0T3B0aW9ucywgTGluZVdpZHRoLCBUaW1lLCBCdXNpbmVzc0RheSB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XHJcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcclxuaW1wb3J0IHsgU3RyYXRlZ3lJZCwgZ2V0U3RyYXRlZ3kgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMnO1xyXG5cclxuLy8gV0FSTklORzogVGhpcyBjb21wb25lbnQgdXNlcyB0aGUgQ3J5cHRvQ29tcGFyZSBBUEkgZm9yIHJlYWwtdGltZSBCaXRjb2luIHByaWNlIGRhdGEuXHJcbi8vIERPIE5PVCByZXBsYWNlIHRoaXMgd2l0aCBzYW1wbGUgZGF0YSBvciBtb2RpZnkgdGhlIGRhdGEgZmVlZCBpbXBsZW1lbnRhdGlvbi5cclxuLy8gVGhlIHByaWNlIGZlZWQgaXMgd29ya2luZyBjb3JyZWN0bHkgYW5kIHNob3VsZCByZW1haW4gY29ubmVjdGVkIHRvIENyeXB0b0NvbXBhcmUuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhbmRsZXN0aWNrQ2hhcnRQcm9wcyB7XHJcbiAgdGltZWZyYW1lOiBUaW1lZnJhbWU7XHJcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgdGltZWZyYW1lLCBzdHJhdGVneSB9OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcclxuICBjb25zdCBjaGFydENvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcclxuICBjb25zdCBpbmRpY2F0b3JTZXJpZXNSZWZzID0gdXNlUmVmPE1hcDxzdHJpbmcsIGFueT4+KG5ldyBNYXAoKSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBmb3JtYXRUaW1lID0gKHRpbWU6IFRpbWUpID0+IHtcclxuICAgICAgbGV0IGRhdGU6IERhdGU7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIEJ1c2luZXNzRGF5IGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGltZSBhcyBCdXNpbmVzc0RheTtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcclxuICAgICAgICBtb250aDogJ3Nob3J0JyxcclxuICAgICAgICBkYXk6ICdudW1lcmljJyxcclxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgaG91cjEyOiBmYWxzZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gRm9yIGRhaWx5IHRpbWVmcmFtZXMsIGRvbid0IHNob3cgdGltZVxyXG4gICAgICBpZiAodGltZWZyYW1lID09PSAnMWQnKSB7XHJcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMuaG91cjtcclxuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5taW51dGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIGZvcm1hdE9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjaGFydE9wdGlvbnM6IERlZXBQYXJ0aWFsPENoYXJ0T3B0aW9ucz4gPSB7XHJcbiAgICAgIGxheW91dDoge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHsgY29sb3I6ICcjMUUyMjJEJyB9LFxyXG4gICAgICAgIHRleHRDb2xvcjogJyNEREQnLFxyXG4gICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICBmb250RmFtaWx5OiAnUm9ib3RvLCBzYW5zLXNlcmlmJyxcclxuICAgICAgfSxcclxuICAgICAgZ3JpZDoge1xyXG4gICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXHJcbiAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcclxuICAgICAgfSxcclxuICAgICAgY3Jvc3NoYWlyOiB7XHJcbiAgICAgICAgbW9kZTogMSxcclxuICAgICAgICB2ZXJ0TGluZToge1xyXG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxyXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcclxuICAgICAgICAgIHN0eWxlOiAzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9yekxpbmU6IHtcclxuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcclxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXHJcbiAgICAgICAgICBzdHlsZTogMyxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB0aW1lU2NhbGU6IHtcclxuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxyXG4gICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgIHNlY29uZHNWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XHJcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcclxuICAgICAgfSxcclxuICAgICAgbG9jYWxpemF0aW9uOiB7XHJcbiAgICAgICAgdGltZUZvcm1hdHRlcjogZm9ybWF0VGltZSxcclxuICAgICAgfSxcclxuICAgICAgd2F0ZXJtYXJrOiB7XHJcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xyXG4gICAgICAuLi5jaGFydE9wdGlvbnMsXHJcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XHJcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcclxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxyXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxyXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XHJcblxyXG4gICAgLy8gRmV0Y2ggaGlzdG9yaWNhbCBkYXRhXHJcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoaXN0b3JpY2FsRGF0YSA9IGF3YWl0IGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSk7XHJcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXMuc2V0RGF0YShoaXN0b3JpY2FsRGF0YS5tYXAoZCA9PiAoe1xyXG4gICAgICAgICAgdGltZTogZC50aW1lLFxyXG4gICAgICAgICAgb3BlbjogZC5vcGVuLFxyXG4gICAgICAgICAgaGlnaDogZC5oaWdoLFxyXG4gICAgICAgICAgbG93OiBkLmxvdyxcclxuICAgICAgICAgIGNsb3NlOiBkLmNsb3NlXHJcbiAgICAgICAgfSkpKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgc3RyYXRlZ3kgYW5hbHlzaXMgaWYgYSBzdHJhdGVneSBpcyBzZWxlY3RlZFxyXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFN0cmF0ZWd5ID0gZ2V0U3RyYXRlZ3koc3RyYXRlZ3kpO1xyXG4gICAgICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgaW5kaWNhdG9yc1xyXG4gICAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xyXG4gICAgICAgICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSdW4gc3RyYXRlZ3kgYW5hbHlzaXNcclxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gc2VsZWN0ZWRTdHJhdGVneS5hbmFseXplKGhpc3RvcmljYWxEYXRhKTtcclxuICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdHJhdGVneSBTaWduYWw6Jywgc2lnbmFsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHN0cmF0ZWd5IGluZGljYXRvcnMgaWYgYW55XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnMpIHtcclxuICAgICAgICAgICAgICBzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnMuZm9yRWFjaChpbmRpY2F0b3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xyXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJyMyOTYyRkYnLFxyXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQoaW5kaWNhdG9yLm5hbWUsIGxpbmVTZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGljYXRvci5kYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgbGluZVNlcmllcy5zZXREYXRhKGluZGljYXRvci5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGhpc3RvcmljYWwgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbG9hZERhdGEoKTtcclxuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gcmVhbC10aW1lIHByaWNlIHVwZGF0ZXMgd2l0aCBpbXByb3ZlZCBjYW5kbGUgZm9ybWF0aW9uXHJcbiAgICBsZXQgY3VycmVudENhbmRsZSA9IHtcclxuICAgICAgb3BlbjogMCxcclxuICAgICAgaGlnaDogLUluZmluaXR5LFxyXG4gICAgICBsb3c6IEluZmluaXR5LFxyXG4gICAgICBjbG9zZTogMCxcclxuICAgICAgdGltZTogMCxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZ2V0SW50ZXJ2YWxTZWNvbmRzID0gKHRmOiBUaW1lZnJhbWUpOiBudW1iZXIgPT4ge1xyXG4gICAgICBzd2l0Y2ggKHRmKSB7XHJcbiAgICAgICAgY2FzZSAnMW0nOiByZXR1cm4gNjA7XHJcbiAgICAgICAgY2FzZSAnNW0nOiByZXR1cm4gMzAwO1xyXG4gICAgICAgIGNhc2UgJzE1bSc6IHJldHVybiA5MDA7XHJcbiAgICAgICAgY2FzZSAnMzBtJzogcmV0dXJuIDE4MDA7XHJcbiAgICAgICAgY2FzZSAnMWgnOiByZXR1cm4gMzYwMDtcclxuICAgICAgICBjYXNlICc0aCc6IHJldHVybiAxNDQwMDtcclxuICAgICAgICBjYXNlICcxZCc6IHJldHVybiA4NjQwMDtcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gNjA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1ByaWNlKChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xyXG4gICAgICAgIGNvbnN0IGNhbmRsZVRpbWVzdGFtcCA9IE1hdGguZmxvb3IoY3VycmVudFRpbWVzdGFtcCAvIGludGVydmFsU2Vjb25kcykgKiBpbnRlcnZhbFNlY29uZHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBjYW5kbGVcclxuICAgICAgICBpZiAoY2FuZGxlVGltZXN0YW1wICE9PSBjdXJyZW50Q2FuZGxlLnRpbWUpIHtcclxuICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNhbmRsZSwgZmluYWxpemUgaXRcclxuICAgICAgICAgIGlmIChjdXJyZW50Q2FuZGxlLnRpbWUgIT09IDApIHtcclxuICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoe1xyXG4gICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcclxuICAgICAgICAgICAgICBvcGVuOiBjdXJyZW50Q2FuZGxlLm9wZW4sXHJcbiAgICAgICAgICAgICAgaGlnaDogY3VycmVudENhbmRsZS5oaWdoLFxyXG4gICAgICAgICAgICAgIGxvdzogY3VycmVudENhbmRsZS5sb3csXHJcbiAgICAgICAgICAgICAgY2xvc2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBjYW5kbGVcclxuICAgICAgICAgIGN1cnJlbnRDYW5kbGUgPSB7XHJcbiAgICAgICAgICAgIHRpbWU6IGNhbmRsZVRpbWVzdGFtcCxcclxuICAgICAgICAgICAgb3BlbjogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICBjbG9zZTogZGF0YS52YWx1ZSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYW5kbGVcclxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlID4gY3VycmVudENhbmRsZS5oaWdoKSBjdXJyZW50Q2FuZGxlLmhpZ2ggPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPCBjdXJyZW50Q2FuZGxlLmxvdykgY3VycmVudENhbmRsZS5sb3cgPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgY3VycmVudENhbmRsZS5jbG9zZSA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNoYXJ0IHdpdGggdGhlIGN1cnJlbnQgY2FuZGxlIHN0YXRlXHJcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoe1xyXG4gICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lLFxyXG4gICAgICAgICAgb3BlbjogY3VycmVudENhbmRsZS5vcGVuLFxyXG4gICAgICAgICAgaGlnaDogY3VycmVudENhbmRsZS5oaWdoLFxyXG4gICAgICAgICAgbG93OiBjdXJyZW50Q2FuZGxlLmxvdyxcclxuICAgICAgICAgIGNsb3NlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aW1lZnJhbWUpO1xyXG5cclxuICAgIC8vIFJlbW92ZSBUcmFkaW5nVmlldyBsb2dvIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3RcclxuICAgIGNvbnN0IHJlbW92ZVRyYWRpbmdWaWV3TG9nbyA9ICgpID0+IHtcclxuICAgICAgY29uc3QgbG9nb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHYtYXR0ci1sb2dvJyk7XHJcbiAgICAgIGlmIChsb2dvRWxlbWVudCkge1xyXG4gICAgICAgIGxvZ29FbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBoZWFkZXJMb2dvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnR2LWhlYWRlcl9fbGluaycpO1xyXG4gICAgICBpZiAoaGVhZGVyTG9nbykge1xyXG4gICAgICAgIGhlYWRlckxvZ28ucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUnVuIGxvZ28gcmVtb3ZhbCBhZnRlciBjaGFydCBpcyBjcmVhdGVkXHJcbiAgICByZW1vdmVUcmFkaW5nVmlld0xvZ28oKTtcclxuICAgIC8vIEFsc28gcnVuIGFmdGVyIGEgc2hvcnQgZGVsYXkgdG8gY2F0Y2ggZHluYW1pY2FsbHkgYWRkZWQgZWxlbWVudHNcclxuICAgIGNvbnN0IGxvZ29UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlbW92ZVRyYWRpbmdWaWV3TG9nbywgMTAwKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjaGFydFJlZi5jdXJyZW50LmFwcGx5T3B0aW9ucyh7XHJcbiAgICAgICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcclxuICAgICAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgIGNsZWFyVGltZW91dChsb2dvVGltZW91dElkKTtcclxuICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFt0aW1lZnJhbWUsIHN0cmF0ZWd5XSk7XHJcblxyXG4gIHJldHVybiA8ZGl2IHJlZj17Y2hhcnRDb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIiAvPjtcclxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiQ2FuZGxlc3RpY2tDaGFydCIsInRpbWVmcmFtZSIsInN0cmF0ZWd5IiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZXN0aWNrU2VyaWVzUmVmIiwiaW5kaWNhdG9yU2VyaWVzUmVmcyIsIk1hcCIsImN1cnJlbnQiLCJmb3JtYXRUaW1lIiwidGltZSIsImRhdGUiLCJEYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJ0b0xvY2FsZVN0cmluZyIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRDb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjcm9zc2hhaXIiLCJtb2RlIiwidmVydExpbmUiLCJ3aWR0aCIsInN0eWxlIiwiaG9yekxpbmUiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJyaWdodFByaWNlU2NhbGUiLCJsb2NhbGl6YXRpb24iLCJ0aW1lRm9ybWF0dGVyIiwid2F0ZXJtYXJrIiwidmlzaWJsZSIsImNoYXJ0IiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJsb2FkRGF0YSIsImhpc3RvcmljYWxEYXRhIiwic2V0RGF0YSIsIm1hcCIsImQiLCJvcGVuIiwiaGlnaCIsImxvdyIsImNsb3NlIiwic2VsZWN0ZWRTdHJhdGVneSIsImZvckVhY2giLCJzZXJpZXMiLCJyZW1vdmVTZXJpZXMiLCJjbGVhciIsInNpZ25hbCIsImFuYWx5emUiLCJjb25zb2xlIiwibG9nIiwiaW5kaWNhdG9ycyIsImluZGljYXRvciIsImxpbmVTZXJpZXMiLCJhZGRMaW5lU2VyaWVzIiwibGluZVdpZHRoIiwic2V0IiwibmFtZSIsImRhdGEiLCJsZW5ndGgiLCJlcnJvciIsImN1cnJlbnRDYW5kbGUiLCJJbmZpbml0eSIsImdldEludGVydmFsU2Vjb25kcyIsInRmIiwidW5zdWJzY3JpYmUiLCJpbnRlcnZhbFNlY29uZHMiLCJjdXJyZW50VGltZXN0YW1wIiwiTWF0aCIsImZsb29yIiwibm93IiwiY2FuZGxlVGltZXN0YW1wIiwidXBkYXRlIiwidmFsdWUiLCJyZW1vdmVUcmFkaW5nVmlld0xvZ28iLCJsb2dvRWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyZW1vdmUiLCJoZWFkZXJMb2dvIiwicXVlcnlTZWxlY3RvciIsImxvZ29UaW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiaGFuZGxlUmVzaXplIiwiYXBwbHlPcHRpb25zIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhclRpbWVvdXQiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts":
/*!**********************************************!*\
  !*** ./src/services/api/cryptoCompareAPI.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentPrice: function() { return /* binding */ getCurrentPrice; },\n/* harmony export */   getHistoricalData: function() { return /* binding */ getHistoricalData; },\n/* harmony export */   subscribeToPrice: function() { return /* binding */ subscribeToPrice; },\n/* harmony export */   subscribeToTrades: function() { return /* binding */ subscribeToTrades; }\n/* harmony export */ });\nconst TIMEFRAME_CONFIG = {\n    \"1m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 60\n    },\n    \"5m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 300\n    },\n    \"15m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 900\n    },\n    \"30m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 1800\n    },\n    \"1h\": {\n        endpoint: \"histohour\",\n        limit: 720,\n        interval: 3600\n    },\n    \"4h\": {\n        endpoint: \"histohour\",\n        limit: 720,\n        interval: 14400\n    },\n    \"1d\": {\n        endpoint: \"histoday\",\n        limit: 365,\n        interval: 86400\n    },\n    \"1w\": {\n        endpoint: \"histoday\",\n        limit: 365,\n        interval: 604800\n    }\n};\nlet socket = null;\nlet priceUpdateCallbacks = [];\nlet tradeUpdateCallbacks = [];\nlet pendingSubscription = false;\nlet lastPrice = 0;\nlet reconnectAttempts = 0;\nlet currentTimeframe = \"1m\";\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 2000;\n// Fallback to REST API when WebSocket fails\nasync function fetchPriceUpdate() {\n    try {\n        const response = await fetch(\"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\");\n        const data = await response.json();\n        const price = data.USD;\n        const timestamp = Math.floor(Date.now() / 1000);\n        if (price && !isNaN(price) && price !== lastPrice) {\n            lastPrice = price;\n            priceUpdateCallbacks.forEach((callback)=>callback({\n                    time: timestamp,\n                    value: price\n                }));\n        }\n    } catch (error) {\n        console.error(\"Error fetching price via REST:\", error);\n    }\n}\nfunction sendSubscription(ws) {\n    const subscribeMsg = {\n        \"action\": \"SubAdd\",\n        \"subs\": [\n            \"5~CCCAGG~BTC~USD\",\n            \"2~Coinbase~BTC~USD\",\n            \"11~BTC~USD\" // Direct price feed\n        ]\n    };\n    try {\n        ws.send(JSON.stringify(subscribeMsg));\n        console.log(\"Subscribed to price feeds\");\n        pendingSubscription = false;\n    } catch (error) {\n        console.error(\"Error sending subscription:\", error);\n        pendingSubscription = true;\n    }\n}\n// Update the WebSocket message handler to respect timeframes\nfunction handlePriceUpdate(price, timestamp, timeframe) {\n    const config = TIMEFRAME_CONFIG[timeframe];\n    const interval = config.interval;\n    // Align timestamp to the current timeframe interval\n    const alignedTimestamp = Math.floor(timestamp / interval) * interval;\n    if (price && !isNaN(price) && price !== lastPrice) {\n        lastPrice = price;\n        priceUpdateCallbacks.forEach((callback)=>callback({\n                time: alignedTimestamp,\n                value: price\n            }));\n        if (tradeUpdateCallbacks.length > 0) {\n            tradeUpdateCallbacks.forEach((callback)=>callback({\n                    time: alignedTimestamp,\n                    price: price,\n                    volume24h: 0 // Volume will be updated separately\n                }));\n        }\n    }\n}\nfunction connectWebSocket() {\n    if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n        if (pendingSubscription) {\n            sendSubscription(socket);\n        }\n        return;\n    }\n    // Don't try to reconnect too many times\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n        console.log(\"Max reconnection attempts reached, falling back to REST API\");\n        // Set up periodic REST API polling as fallback\n        const pollInterval = setInterval(fetchPriceUpdate, 5000);\n        return;\n    }\n    try {\n        // Close existing socket if any\n        if (socket) {\n            socket.close();\n            socket = null;\n        }\n        socket = new WebSocket(\"wss://streamer.cryptocompare.com/v2\");\n        socket.onopen = ()=>{\n            console.log(\"Connected to CryptoCompare WebSocket\");\n            reconnectAttempts = 0; // Reset attempts on successful connection\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                sendSubscription(socket);\n            } else {\n                pendingSubscription = true;\n            }\n        };\n        socket.onmessage = (event)=>{\n            try {\n                const data = JSON.parse(event.data);\n                if (data.TYPE === \"20\" && data.MESSAGE === \"SUBSCRIBECOMPLETE\") {\n                    console.log(\"Successfully subscribed to feeds\");\n                    return;\n                }\n                const timestamp = Math.floor(Date.now() / 1000);\n                let price = null;\n                if (data.TYPE === \"11\" || data.TYPE === \"2\" || data.TYPE === \"5\") {\n                    price = parseFloat(data.PRICE);\n                    if (price && !isNaN(price)) {\n                        handlePriceUpdate(price, timestamp, currentTimeframe);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error processing message:\", error);\n            }\n        };\n        socket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            reconnectAttempts++;\n            reconnect();\n        };\n        socket.onclose = (event)=>{\n            console.log(\"WebSocket closed with code \".concat(event.code, \", reason: \").concat(event.reason));\n            reconnect();\n        };\n        // Ping every 15 seconds to keep connection alive\n        const pingInterval = setInterval(()=>{\n            if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n                try {\n                    socket.send(JSON.stringify({\n                        \"action\": \"PING\"\n                    }));\n                } catch (error) {\n                    console.error(\"Error sending ping:\", error);\n                    reconnect();\n                }\n            }\n        }, 15000);\n        // Clean up ping interval on socket close\n        socket.addEventListener(\"close\", ()=>clearInterval(pingInterval));\n    } catch (error) {\n        console.error(\"Error creating WebSocket:\", error);\n        reconnectAttempts++;\n        setTimeout(connectWebSocket, RECONNECT_DELAY);\n    }\n}\nfunction reconnect() {\n    if (socket) {\n        try {\n            socket.close();\n        } catch (error) {\n            console.error(\"Error closing socket:\", error);\n        }\n        socket = null;\n    }\n    setTimeout(connectWebSocket, RECONNECT_DELAY * Math.min(reconnectAttempts, 5));\n}\nfunction subscribeToPrice(callback) {\n    let timeframe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"1m\";\n    currentTimeframe = timeframe;\n    priceUpdateCallbacks.push(callback);\n    // Immediately get current price via REST API\n    getCurrentPrice().then((price)=>{\n        const timestamp = Math.floor(Date.now() / 1000);\n        callback({\n            time: timestamp,\n            value: price\n        });\n    }).catch(console.error);\n    // If this is the first subscriber, connect to WebSocket\n    if (priceUpdateCallbacks.length === 1) {\n        connectWebSocket();\n    }\n    return ()=>{\n        priceUpdateCallbacks = priceUpdateCallbacks.filter((cb)=>cb !== callback);\n        if (priceUpdateCallbacks.length === 0 && tradeUpdateCallbacks.length === 0 && socket) {\n            socket.close();\n            socket = null;\n        }\n    };\n}\nfunction subscribeToTrades(callback) {\n    tradeUpdateCallbacks.push(callback);\n    // If this is the first subscriber, connect to WebSocket\n    if (tradeUpdateCallbacks.length === 1 && priceUpdateCallbacks.length === 0) {\n        connectWebSocket();\n    }\n    return ()=>{\n        tradeUpdateCallbacks = tradeUpdateCallbacks.filter((cb)=>cb !== callback);\n        if (priceUpdateCallbacks.length === 0 && tradeUpdateCallbacks.length === 0 && socket) {\n            socket.close();\n            socket = null;\n        }\n    };\n}\nasync function getCurrentPrice() {\n    try {\n        const response = await fetch(\"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\");\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.USD;\n    } catch (error) {\n        console.error(\"Error fetching price:\", error);\n        throw error;\n    }\n}\nasync function getHistoricalData() {\n    let timeframe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1m\";\n    try {\n        var _data_Data;\n        const config = TIMEFRAME_CONFIG[timeframe];\n        const endTime = Math.floor(Date.now() / 1000);\n        // Calculate the appropriate aggregate parameter based on timeframe\n        let aggregate = 1;\n        if (config.endpoint === \"histominute\") {\n            aggregate = config.interval / 60;\n        } else if (config.endpoint === \"histohour\") {\n            aggregate = config.interval / 3600;\n        } else if (config.endpoint === \"histoday\") {\n            aggregate = config.interval / 86400;\n        }\n        const url = \"https://min-api.cryptocompare.com/data/v2/\".concat(config.endpoint, \"?fsym=BTC&tsym=USD&limit=\").concat(config.limit, \"&toTs=\").concat(endTime, \"&aggregate=\").concat(aggregate);\n        console.log(\"Fetching historical data for \".concat(timeframe, \" timeframe...\"));\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!((_data_Data = data.Data) === null || _data_Data === void 0 ? void 0 : _data_Data.Data)) {\n            throw new Error(\"Invalid data format received from API\");\n        }\n        return data.Data.Data;\n    } catch (error) {\n        console.error(\"Error fetching historical data:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBMEJBLE1BQU1BLG1CQUF1RDtJQUMzRCxNQUFNO1FBQUVDLFVBQVU7UUFBZUMsT0FBTztRQUFNQyxVQUFVO0lBQUc7SUFDM0QsTUFBTTtRQUFFRixVQUFVO1FBQWVDLE9BQU87UUFBTUMsVUFBVTtJQUFJO0lBQzVELE9BQU87UUFBRUYsVUFBVTtRQUFlQyxPQUFPO1FBQU1DLFVBQVU7SUFBSTtJQUM3RCxPQUFPO1FBQUVGLFVBQVU7UUFBZUMsT0FBTztRQUFNQyxVQUFVO0lBQUs7SUFDOUQsTUFBTTtRQUFFRixVQUFVO1FBQWFDLE9BQU87UUFBS0MsVUFBVTtJQUFLO0lBQzFELE1BQU07UUFBRUYsVUFBVTtRQUFhQyxPQUFPO1FBQUtDLFVBQVU7SUFBTTtJQUMzRCxNQUFNO1FBQUVGLFVBQVU7UUFBWUMsT0FBTztRQUFLQyxVQUFVO0lBQU07SUFDMUQsTUFBTTtRQUFFRixVQUFVO1FBQVlDLE9BQU87UUFBS0MsVUFBVTtJQUFPO0FBQzdEO0FBRUEsSUFBSUMsU0FBMkI7QUFDL0IsSUFBSUMsdUJBQXNELEVBQUU7QUFDNUQsSUFBSUMsdUJBQXNELEVBQUU7QUFDNUQsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLG1CQUE4QjtBQUNsQyxNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMsa0JBQWtCO0FBRXhCLDRDQUE0QztBQUM1QyxlQUFlQztJQUNiLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU07UUFDN0IsTUFBTUMsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1FBQ2hDLE1BQU1DLFFBQVFGLEtBQUtHLEdBQUc7UUFDdEIsTUFBTUMsWUFBWUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7UUFFMUMsSUFBSU4sU0FBUyxDQUFDTyxNQUFNUCxV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aEIsTUFBTSxJQUFJQyxNQUFNLHVCQUF1QyxPQUFoQmpFLFNBQVNrRSxNQUFNO1FBQ3hEO1FBRUEsTUFBTWhFLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtRQUNoQyxJQUFJLEdBQUNELGFBQUFBLEtBQUtxRSxJQUFJLGNBQVRyRSxpQ0FBQUEsV0FBV3FFLElBQUksR0FBRTtZQUNwQixNQUFNLElBQUlOLE1BQU07UUFDbEI7UUFFQSxPQUFPL0QsS0FBS3FFLElBQUksQ0FBQ0EsSUFBSTtJQUN2QixFQUFFLE9BQU92RCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEkudHM/NTNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUaW1lLCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5cclxuLy8gV0FSTklORzogVGhpcyBpcyB0aGUgcHJvZHVjdGlvbiBCaXRjb2luIHByaWNlIGZlZWQgaW1wbGVtZW50YXRpb24uXHJcbi8vIFRoaXMgZmlsZSBjb250YWlucyBjcml0aWNhbCByZWFsLXRpbWUgZGF0YSBmdW5jdGlvbmFsaXR5LlxyXG4vLyBETyBOT1QgbW9kaWZ5IHRoaXMgaW1wbGVtZW50YXRpb24gb3IgcmVwbGFjZSBpdCB3aXRoIHNhbXBsZSBkYXRhLlxyXG4vLyBUaGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYW5kIGhpc3RvcmljYWwgZGF0YSBmZXRjaGluZyBhcmUgd29ya2luZyBjb3JyZWN0bHkuXHJcblxyXG5pbnRlcmZhY2UgUHJpY2VEYXRhIHtcclxuICB0aW1lOiBVVENUaW1lc3RhbXA7XHJcbiAgdmFsdWU6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYWRlRGF0YSB7XHJcbiAgdGltZTogVVRDVGltZXN0YW1wO1xyXG4gIHByaWNlOiBudW1iZXI7XHJcbiAgdm9sdW1lMjRoOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRpbWVmcmFtZUNvbmZpZyA9IHtcclxuICBlbmRwb2ludDogc3RyaW5nO1xyXG4gIGxpbWl0OiBudW1iZXI7XHJcbiAgaW50ZXJ2YWw6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVGltZWZyYW1lID0gJzFtJyB8ICc1bScgfCAnMTVtJyB8ICczMG0nIHwgJzFoJyB8ICc0aCcgfCAnMWQnIHwgJzF3JztcclxuXHJcbmNvbnN0IFRJTUVGUkFNRV9DT05GSUc6IFJlY29yZDxUaW1lZnJhbWUsIFRpbWVmcmFtZUNvbmZpZz4gPSB7XHJcbiAgJzFtJzogeyBlbmRwb2ludDogJ2hpc3RvbWludXRlJywgbGltaXQ6IDE0NDAsIGludGVydmFsOiA2MCB9LFxyXG4gICc1bSc6IHsgZW5kcG9pbnQ6ICdoaXN0b21pbnV0ZScsIGxpbWl0OiAxNDQwLCBpbnRlcnZhbDogMzAwIH0sXHJcbiAgJzE1bSc6IHsgZW5kcG9pbnQ6ICdoaXN0b21pbnV0ZScsIGxpbWl0OiAxNDQwLCBpbnRlcnZhbDogOTAwIH0sXHJcbiAgJzMwbSc6IHsgZW5kcG9pbnQ6ICdoaXN0b21pbnV0ZScsIGxpbWl0OiAxNDQwLCBpbnRlcnZhbDogMTgwMCB9LFxyXG4gICcxaCc6IHsgZW5kcG9pbnQ6ICdoaXN0b2hvdXInLCBsaW1pdDogNzIwLCBpbnRlcnZhbDogMzYwMCB9LFxyXG4gICc0aCc6IHsgZW5kcG9pbnQ6ICdoaXN0b2hvdXInLCBsaW1pdDogNzIwLCBpbnRlcnZhbDogMTQ0MDAgfSxcclxuICAnMWQnOiB7IGVuZHBvaW50OiAnaGlzdG9kYXknLCBsaW1pdDogMzY1LCBpbnRlcnZhbDogODY0MDAgfSxcclxuICAnMXcnOiB7IGVuZHBvaW50OiAnaGlzdG9kYXknLCBsaW1pdDogMzY1LCBpbnRlcnZhbDogNjA0ODAwIH1cclxufTtcclxuXHJcbmxldCBzb2NrZXQ6IFdlYlNvY2tldCB8IG51bGwgPSBudWxsO1xyXG5sZXQgcHJpY2VVcGRhdGVDYWxsYmFja3M6ICgoZGF0YTogUHJpY2VEYXRhKSA9PiB2b2lkKVtdID0gW107XHJcbmxldCB0cmFkZVVwZGF0ZUNhbGxiYWNrczogKChkYXRhOiBUcmFkZURhdGEpID0+IHZvaWQpW10gPSBbXTtcclxubGV0IHBlbmRpbmdTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxubGV0IGxhc3RQcmljZSA9IDA7XHJcbmxldCByZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbmxldCBjdXJyZW50VGltZWZyYW1lOiBUaW1lZnJhbWUgPSAnMW0nO1xyXG5jb25zdCBNQVhfUkVDT05ORUNUX0FUVEVNUFRTID0gNTtcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZID0gMjAwMDtcclxuXHJcbi8vIEZhbGxiYWNrIHRvIFJFU1QgQVBJIHdoZW4gV2ViU29ja2V0IGZhaWxzXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUHJpY2VVcGRhdGUoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vbWluLWFwaS5jcnlwdG9jb21wYXJlLmNvbS9kYXRhL3ByaWNlP2ZzeW09QlRDJnRzeW1zPVVTRCcpO1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnN0IHByaWNlID0gZGF0YS5VU0Q7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSBhcyBVVENUaW1lc3RhbXA7XHJcblxyXG4gICAgaWYgKHByaWNlICYmICFpc05hTihwcmljZSkgJiYgcHJpY2UgIT09IGxhc3RQcmljZSkge1xyXG4gICAgICBsYXN0UHJpY2UgPSBwcmljZTtcclxuICAgICAgcHJpY2VVcGRhdGVDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh7XHJcbiAgICAgICAgdGltZTogdGltZXN0YW1wLFxyXG4gICAgICAgIHZhbHVlOiBwcmljZVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByaWNlIHZpYSBSRVNUOicsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbmRTdWJzY3JpcHRpb24od3M6IFdlYlNvY2tldCkge1xyXG4gIGNvbnN0IHN1YnNjcmliZU1zZyA9IHtcclxuICAgIFwiYWN0aW9uXCI6IFwiU3ViQWRkXCIsXHJcbiAgICBcInN1YnNcIjogW1xyXG4gICAgICBcIjV+Q0NDQUdHfkJUQ35VU0RcIiwgICAgICAgLy8gQWdncmVnYXRlIGluZGV4IChtb3N0IGZyZXF1ZW50KVxyXG4gICAgICBcIjJ+Q29pbmJhc2V+QlRDflVTRFwiLCAgICAgLy8gQ29pbmJhc2UgdGlja2VyXHJcbiAgICAgIFwiMTF+QlRDflVTRFwiICAgICAgICAgICAgICAvLyBEaXJlY3QgcHJpY2UgZmVlZFxyXG4gICAgXVxyXG4gIH07XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoc3Vic2NyaWJlTXNnKSk7XHJcbiAgICBjb25zb2xlLmxvZygnU3Vic2NyaWJlZCB0byBwcmljZSBmZWVkcycpO1xyXG4gICAgcGVuZGluZ1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIHN1YnNjcmlwdGlvbjonLCBlcnJvcik7XHJcbiAgICBwZW5kaW5nU3Vic2NyaXB0aW9uID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFVwZGF0ZSB0aGUgV2ViU29ja2V0IG1lc3NhZ2UgaGFuZGxlciB0byByZXNwZWN0IHRpbWVmcmFtZXNcclxuZnVuY3Rpb24gaGFuZGxlUHJpY2VVcGRhdGUocHJpY2U6IG51bWJlciwgdGltZXN0YW1wOiBVVENUaW1lc3RhbXAsIHRpbWVmcmFtZTogVGltZWZyYW1lKSB7XHJcbiAgY29uc3QgY29uZmlnID0gVElNRUZSQU1FX0NPTkZJR1t0aW1lZnJhbWVdO1xyXG4gIGNvbnN0IGludGVydmFsID0gY29uZmlnLmludGVydmFsO1xyXG4gIFxyXG4gIC8vIEFsaWduIHRpbWVzdGFtcCB0byB0aGUgY3VycmVudCB0aW1lZnJhbWUgaW50ZXJ2YWxcclxuICBjb25zdCBhbGlnbmVkVGltZXN0YW1wID0gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCBhcyBVVENUaW1lc3RhbXA7XHJcbiAgXHJcbiAgaWYgKHByaWNlICYmICFpc05hTihwcmljZSkgJiYgcHJpY2UgIT09IGxhc3RQcmljZSkge1xyXG4gICAgbGFzdFByaWNlID0gcHJpY2U7XHJcbiAgICBcclxuICAgIHByaWNlVXBkYXRlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soe1xyXG4gICAgICB0aW1lOiBhbGlnbmVkVGltZXN0YW1wLFxyXG4gICAgICB2YWx1ZTogcHJpY2VcclxuICAgIH0pKTtcclxuXHJcbiAgICBpZiAodHJhZGVVcGRhdGVDYWxsYmFja3MubGVuZ3RoID4gMCkge1xyXG4gICAgICB0cmFkZVVwZGF0ZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHtcclxuICAgICAgICB0aW1lOiBhbGlnbmVkVGltZXN0YW1wLFxyXG4gICAgICAgIHByaWNlOiBwcmljZSxcclxuICAgICAgICB2b2x1bWUyNGg6IDAgLy8gVm9sdW1lIHdpbGwgYmUgdXBkYXRlZCBzZXBhcmF0ZWx5XHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbm5lY3RXZWJTb2NrZXQoKSB7XHJcbiAgaWYgKHNvY2tldD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgIGlmIChwZW5kaW5nU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgIHNlbmRTdWJzY3JpcHRpb24oc29ja2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIERvbid0IHRyeSB0byByZWNvbm5lY3QgdG9vIG1hbnkgdGltZXNcclxuICBpZiAocmVjb25uZWN0QXR0ZW1wdHMgPj0gTUFYX1JFQ09OTkVDVF9BVFRFTVBUUykge1xyXG4gICAgY29uc29sZS5sb2coJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCwgZmFsbGluZyBiYWNrIHRvIFJFU1QgQVBJJyk7XHJcbiAgICAvLyBTZXQgdXAgcGVyaW9kaWMgUkVTVCBBUEkgcG9sbGluZyBhcyBmYWxsYmFja1xyXG4gICAgY29uc3QgcG9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoZmV0Y2hQcmljZVVwZGF0ZSwgNTAwMCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gQ2xvc2UgZXhpc3Rpbmcgc29ja2V0IGlmIGFueVxyXG4gICAgaWYgKHNvY2tldCkge1xyXG4gICAgICBzb2NrZXQuY2xvc2UoKTtcclxuICAgICAgc29ja2V0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KCd3c3M6Ly9zdHJlYW1lci5jcnlwdG9jb21wYXJlLmNvbS92MicpO1xyXG5cclxuICAgIHNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gQ3J5cHRvQ29tcGFyZSBXZWJTb2NrZXQnKTtcclxuICAgICAgcmVjb25uZWN0QXR0ZW1wdHMgPSAwOyAvLyBSZXNldCBhdHRlbXB0cyBvbiBzdWNjZXNzZnVsIGNvbm5lY3Rpb25cclxuICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICBzZW5kU3Vic2NyaXB0aW9uKHNvY2tldCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGVuZGluZ1N1YnNjcmlwdGlvbiA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc29ja2V0Lm9ubWVzc2FnZSA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGEuVFlQRSA9PT0gXCIyMFwiICYmIGRhdGEuTUVTU0FHRSA9PT0gXCJTVUJTQ1JJQkVDT01QTEVURVwiKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gZmVlZHMnKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIGFzIFVUQ1RpbWVzdGFtcDtcclxuICAgICAgICBsZXQgcHJpY2U6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZGF0YS5UWVBFID09PSBcIjExXCIgfHwgZGF0YS5UWVBFID09PSBcIjJcIiB8fCBkYXRhLlRZUEUgPT09IFwiNVwiKSB7XHJcbiAgICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQoZGF0YS5QUklDRSk7XHJcbiAgICAgICAgICBpZiAocHJpY2UgJiYgIWlzTmFOKHByaWNlKSkge1xyXG4gICAgICAgICAgICBoYW5kbGVQcmljZVVwZGF0ZShwcmljZSwgdGltZXN0YW1wLCBjdXJyZW50VGltZWZyYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBtZXNzYWdlOicsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICByZWNvbm5lY3RBdHRlbXB0cysrO1xyXG4gICAgICByZWNvbm5lY3QoKTtcclxuICAgIH07XHJcblxyXG4gICAgc29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coYFdlYlNvY2tldCBjbG9zZWQgd2l0aCBjb2RlICR7ZXZlbnQuY29kZX0sIHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XHJcbiAgICAgIHJlY29ubmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQaW5nIGV2ZXJ5IDE1IHNlY29uZHMgdG8ga2VlcCBjb25uZWN0aW9uIGFsaXZlXHJcbiAgICBjb25zdCBwaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGlmIChzb2NrZXQ/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHsgXCJhY3Rpb25cIjogXCJQSU5HXCIgfSkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIHBpbmc6JywgZXJyb3IpO1xyXG4gICAgICAgICAgcmVjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCAxNTAwMCk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXAgcGluZyBpbnRlcnZhbCBvbiBzb2NrZXQgY2xvc2VcclxuICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IGNsZWFySW50ZXJ2YWwocGluZ0ludGVydmFsKSk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBXZWJTb2NrZXQ6JywgZXJyb3IpO1xyXG4gICAgcmVjb25uZWN0QXR0ZW1wdHMrKztcclxuICAgIHNldFRpbWVvdXQoY29ubmVjdFdlYlNvY2tldCwgUkVDT05ORUNUX0RFTEFZKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcclxuICBpZiAoc29ja2V0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzb2NrZXQuY2xvc2UoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsb3Npbmcgc29ja2V0OicsIGVycm9yKTtcclxuICAgIH1cclxuICAgIHNvY2tldCA9IG51bGw7XHJcbiAgfVxyXG4gIHNldFRpbWVvdXQoY29ubmVjdFdlYlNvY2tldCwgUkVDT05ORUNUX0RFTEFZICogTWF0aC5taW4ocmVjb25uZWN0QXR0ZW1wdHMsIDUpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZVRvUHJpY2UoY2FsbGJhY2s6IChkYXRhOiBQcmljZURhdGEpID0+IHZvaWQsIHRpbWVmcmFtZTogVGltZWZyYW1lID0gJzFtJykge1xyXG4gIGN1cnJlbnRUaW1lZnJhbWUgPSB0aW1lZnJhbWU7XHJcbiAgcHJpY2VVcGRhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgXHJcbiAgLy8gSW1tZWRpYXRlbHkgZ2V0IGN1cnJlbnQgcHJpY2UgdmlhIFJFU1QgQVBJXHJcbiAgZ2V0Q3VycmVudFByaWNlKCkudGhlbihwcmljZSA9PiB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSBhcyBVVENUaW1lc3RhbXA7XHJcbiAgICBjYWxsYmFjayh7XHJcbiAgICAgIHRpbWU6IHRpbWVzdGFtcCxcclxuICAgICAgdmFsdWU6IHByaWNlXHJcbiAgICB9KTtcclxuICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICBcclxuICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBzdWJzY3JpYmVyLCBjb25uZWN0IHRvIFdlYlNvY2tldFxyXG4gIGlmIChwcmljZVVwZGF0ZUNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcclxuICAgIGNvbm5lY3RXZWJTb2NrZXQoKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIHByaWNlVXBkYXRlQ2FsbGJhY2tzID0gcHJpY2VVcGRhdGVDYWxsYmFja3MuZmlsdGVyKGNiID0+IGNiICE9PSBjYWxsYmFjayk7XHJcbiAgICBpZiAocHJpY2VVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAwICYmIHRyYWRlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCAmJiBzb2NrZXQpIHtcclxuICAgICAgc29ja2V0LmNsb3NlKCk7XHJcbiAgICAgIHNvY2tldCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZVRvVHJhZGVzKGNhbGxiYWNrOiAoZGF0YTogVHJhZGVEYXRhKSA9PiB2b2lkKSB7XHJcbiAgdHJhZGVVcGRhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgXHJcbiAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3Qgc3Vic2NyaWJlciwgY29ubmVjdCB0byBXZWJTb2NrZXRcclxuICBpZiAodHJhZGVVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAxICYmIHByaWNlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29ubmVjdFdlYlNvY2tldCgpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgdHJhZGVVcGRhdGVDYWxsYmFja3MgPSB0cmFkZVVwZGF0ZUNhbGxiYWNrcy5maWx0ZXIoY2IgPT4gY2IgIT09IGNhbGxiYWNrKTtcclxuICAgIGlmIChwcmljZVVwZGF0ZUNhbGxiYWNrcy5sZW5ndGggPT09IDAgJiYgdHJhZGVVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAwICYmIHNvY2tldCkge1xyXG4gICAgICBzb2NrZXQuY2xvc2UoKTtcclxuICAgICAgc29ja2V0ID0gbnVsbDtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFByaWNlKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vbWluLWFwaS5jcnlwdG9jb21wYXJlLmNvbS9kYXRhL3ByaWNlP2ZzeW09QlRDJnRzeW1zPVVTRCcpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgcmV0dXJuIGRhdGEuVVNEO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcmljZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWU6IFRpbWVmcmFtZSA9ICcxbScpOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IFRJTUVGUkFNRV9DT05GSUdbdGltZWZyYW1lXTtcclxuICAgIGNvbnN0IGVuZFRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhcHByb3ByaWF0ZSBhZ2dyZWdhdGUgcGFyYW1ldGVyIGJhc2VkIG9uIHRpbWVmcmFtZVxyXG4gICAgbGV0IGFnZ3JlZ2F0ZSA9IDE7XHJcbiAgICBpZiAoY29uZmlnLmVuZHBvaW50ID09PSAnaGlzdG9taW51dGUnKSB7XHJcbiAgICAgIGFnZ3JlZ2F0ZSA9IGNvbmZpZy5pbnRlcnZhbCAvIDYwO1xyXG4gICAgfSBlbHNlIGlmIChjb25maWcuZW5kcG9pbnQgPT09ICdoaXN0b2hvdXInKSB7XHJcbiAgICAgIGFnZ3JlZ2F0ZSA9IGNvbmZpZy5pbnRlcnZhbCAvIDM2MDA7XHJcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5lbmRwb2ludCA9PT0gJ2hpc3RvZGF5Jykge1xyXG4gICAgICBhZ2dyZWdhdGUgPSBjb25maWcuaW50ZXJ2YWwgLyA4NjQwMDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9taW4tYXBpLmNyeXB0b2NvbXBhcmUuY29tL2RhdGEvdjIvJHtjb25maWcuZW5kcG9pbnR9P2ZzeW09QlRDJnRzeW09VVNEJmxpbWl0PSR7Y29uZmlnLmxpbWl0fSZ0b1RzPSR7ZW5kVGltZX0mYWdncmVnYXRlPSR7YWdncmVnYXRlfWA7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBoaXN0b3JpY2FsIGRhdGEgZm9yICR7dGltZWZyYW1lfSB0aW1lZnJhbWUuLi5gKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBpZiAoIWRhdGEuRGF0YT8uRGF0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSBmb3JtYXQgcmVjZWl2ZWQgZnJvbSBBUEknKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YS5EYXRhLkRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGhpc3RvcmljYWwgZGF0YTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn0gIl0sIm5hbWVzIjpbIlRJTUVGUkFNRV9DT05GSUciLCJlbmRwb2ludCIsImxpbWl0IiwiaW50ZXJ2YWwiLCJzb2NrZXQiLCJwcmljZVVwZGF0ZUNhbGxiYWNrcyIsInRyYWRlVXBkYXRlQ2FsbGJhY2tzIiwicGVuZGluZ1N1YnNjcmlwdGlvbiIsImxhc3RQcmljZSIsInJlY29ubmVjdEF0dGVtcHRzIiwiY3VycmVudFRpbWVmcmFtZSIsIk1BWF9SRUNPTk5FQ1RfQVRURU1QVFMiLCJSRUNPTk5FQ1RfREVMQVkiLCJmZXRjaFByaWNlVXBkYXRlIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwicHJpY2UiLCJVU0QiLCJ0aW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiaXNOYU4iLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJ0aW1lIiwidmFsdWUiLCJlcnJvciIsImNvbnNvbGUiLCJzZW5kU3Vic2NyaXB0aW9uIiwid3MiLCJzdWJzY3JpYmVNc2ciLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZyIsImhhbmRsZVByaWNlVXBkYXRlIiwidGltZWZyYW1lIiwiY29uZmlnIiwiYWxpZ25lZFRpbWVzdGFtcCIsImxlbmd0aCIsInZvbHVtZTI0aCIsImNvbm5lY3RXZWJTb2NrZXQiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsInBvbGxJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xvc2UiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJldmVudCIsInBhcnNlIiwiVFlQRSIsIk1FU1NBR0UiLCJwYXJzZUZsb2F0IiwiUFJJQ0UiLCJvbmVycm9yIiwicmVjb25uZWN0Iiwib25jbG9zZSIsImNvZGUiLCJyZWFzb24iLCJwaW5nSW50ZXJ2YWwiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xlYXJJbnRlcnZhbCIsInNldFRpbWVvdXQiLCJtaW4iLCJzdWJzY3JpYmVUb1ByaWNlIiwicHVzaCIsImdldEN1cnJlbnRQcmljZSIsInRoZW4iLCJjYXRjaCIsImZpbHRlciIsImNiIiwic3Vic2NyaWJlVG9UcmFkZXMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJlbmRUaW1lIiwiYWdncmVnYXRlIiwidXJsIiwiRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/strategies/index.ts":
/*!******************************************!*\
  !*** ./src/services/strategies/index.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStrategies: function() { return /* binding */ getStrategies; },\n/* harmony export */   getStrategy: function() { return /* binding */ getStrategy; },\n/* harmony export */   registerStrategy: function() { return /* binding */ registerStrategy; },\n/* harmony export */   strategyRegistry: function() { return /* binding */ strategyRegistry; }\n/* harmony export */ });\n/* harmony import */ var _sma_crossover__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sma-crossover */ \"(app-pages-browser)/./src/services/strategies/sma-crossover.ts\");\nclass StrategyRegistry {\n    registerStrategy(strategy) {\n        this.strategies.set(strategy.id, strategy);\n    }\n    getStrategies() {\n        return Array.from(this.strategies.values());\n    }\n    getStrategy(id) {\n        return this.strategies.get(id);\n    }\n    constructor(){\n        this.strategies = new Map();\n    }\n}\n// Create a singleton instance\nconst strategyRegistry = new StrategyRegistry();\n// Export the registration function\nconst registerStrategy = (strategy)=>strategyRegistry.registerStrategy(strategy);\n// Export the getter functions\nconst getStrategies = ()=>strategyRegistry.getStrategies();\nconst getStrategy = (id)=>strategyRegistry.getStrategy(id);\n// Import all strategy implementations\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zdHJhdGVnaWVzL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBbUJBLE1BQU1BO0lBT0pDLGlCQUFpQkMsUUFBa0IsRUFBRTtRQUNuQyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDRixTQUFTRyxFQUFFLEVBQUVIO0lBQ25DO0lBRUFJLGdCQUE0QjtRQUMxQixPQUFPQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDTCxVQUFVLENBQUNNLE1BQU07SUFDMUM7SUFFQUMsWUFBWUwsRUFBVSxFQUF3QjtRQUM1QyxPQUFPLElBQUksQ0FBQ0YsVUFBVSxDQUFDUSxHQUFHLENBQUNOO0lBQzdCO0lBZEFPLGFBQWM7UUFDWixJQUFJLENBQUNULFVBQVUsR0FBRyxJQUFJVTtJQUN4QjtBQWFGO0FBRUEsOEJBQThCO0FBQ3ZCLE1BQU1DLG1CQUFtQixJQUFJZCxtQkFBbUI7QUFFdkQsbUNBQW1DO0FBQzVCLE1BQU1DLG1CQUFtQixDQUFDQyxXQUF1QlksaUJBQWlCYixnQkFBZ0IsQ0FBQ0MsVUFBVTtBQUVwRyw4QkFBOEI7QUFDdkIsTUFBTUksZ0JBQWdCLElBQU1RLGlCQUFpQlIsYUFBYSxHQUFHO0FBQzdELE1BQU1JLGNBQWMsQ0FBQ0wsS0FBZVMsaUJBQWlCSixXQUFXLENBQUNMLElBQUk7QUFLNUUsc0NBQXNDO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3N0cmF0ZWdpZXMvaW5kZXgudHM/YzA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW5kbGVzdGlja0RhdGEgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdHJhdGVneVNpZ25hbCB7XHJcbiAgdHlwZTogJ2J1eScgfCAnc2VsbCc7XHJcbiAgcHJpY2U6IG51bWJlcjtcclxuICB0aW1lOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RyYXRlZ3kge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgYW5hbHl6ZTogKGRhdGE6IENhbmRsZXN0aWNrRGF0YVtdKSA9PiBTdHJhdGVneVNpZ25hbCB8IG51bGw7XHJcbiAgaW5kaWNhdG9ycz86IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGRhdGE6IGFueVtdOyAgLy8gV2UnbGwgdHlwZSB0aGlzIG1vcmUgc3BlY2lmaWNhbGx5IHdoZW4gaW1wbGVtZW50aW5nIGluZGljYXRvcnNcclxuICB9W107XHJcbn1cclxuXHJcbmNsYXNzIFN0cmF0ZWd5UmVnaXN0cnkge1xyXG4gIHByaXZhdGUgc3RyYXRlZ2llczogTWFwPHN0cmluZywgU3RyYXRlZ3k+O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc3RyYXRlZ2llcyA9IG5ldyBNYXAoKTtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyU3RyYXRlZ3koc3RyYXRlZ3k6IFN0cmF0ZWd5KSB7XHJcbiAgICB0aGlzLnN0cmF0ZWdpZXMuc2V0KHN0cmF0ZWd5LmlkLCBzdHJhdGVneSk7XHJcbiAgfVxyXG5cclxuICBnZXRTdHJhdGVnaWVzKCk6IFN0cmF0ZWd5W10ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdHJhdGVnaWVzLnZhbHVlcygpKTtcclxuICB9XHJcblxyXG4gIGdldFN0cmF0ZWd5KGlkOiBzdHJpbmcpOiBTdHJhdGVneSB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHJhdGVnaWVzLmdldChpZCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDcmVhdGUgYSBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHN0cmF0ZWd5UmVnaXN0cnkgPSBuZXcgU3RyYXRlZ3lSZWdpc3RyeSgpO1xyXG5cclxuLy8gRXhwb3J0IHRoZSByZWdpc3RyYXRpb24gZnVuY3Rpb25cclxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyU3RyYXRlZ3kgPSAoc3RyYXRlZ3k6IFN0cmF0ZWd5KSA9PiBzdHJhdGVneVJlZ2lzdHJ5LnJlZ2lzdGVyU3RyYXRlZ3koc3RyYXRlZ3kpO1xyXG5cclxuLy8gRXhwb3J0IHRoZSBnZXR0ZXIgZnVuY3Rpb25zXHJcbmV4cG9ydCBjb25zdCBnZXRTdHJhdGVnaWVzID0gKCkgPT4gc3RyYXRlZ3lSZWdpc3RyeS5nZXRTdHJhdGVnaWVzKCk7XHJcbmV4cG9ydCBjb25zdCBnZXRTdHJhdGVneSA9IChpZDogc3RyaW5nKSA9PiBzdHJhdGVneVJlZ2lzdHJ5LmdldFN0cmF0ZWd5KGlkKTtcclxuXHJcbi8vIEV4cG9ydCBzdHJhdGVneSBJRHMgYXMgYSB0eXBlXHJcbmV4cG9ydCB0eXBlIFN0cmF0ZWd5SWQgPSAnbm9uZScgfCAnc21hX2Nyb3Nzb3ZlcicgfCAncnNpX2RpdmVyZ2VuY2UnIHwgJ21hY2QnO1xyXG5cclxuLy8gSW1wb3J0IGFsbCBzdHJhdGVneSBpbXBsZW1lbnRhdGlvbnNcclxuaW1wb3J0ICcuL3NtYS1jcm9zc292ZXInOyAiXSwibmFtZXMiOlsiU3RyYXRlZ3lSZWdpc3RyeSIsInJlZ2lzdGVyU3RyYXRlZ3kiLCJzdHJhdGVneSIsInN0cmF0ZWdpZXMiLCJzZXQiLCJpZCIsImdldFN0cmF0ZWdpZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJnZXRTdHJhdGVneSIsImdldCIsImNvbnN0cnVjdG9yIiwiTWFwIiwic3RyYXRlZ3lSZWdpc3RyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/strategies/index.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/strategies/sma-crossover.ts":
/*!**************************************************!*\
  !*** ./src/services/strategies/sma-crossover.ts ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n\nfunction calculateSMA(data, period) {\n    const sma = [];\n    for(let i = 0; i < data.length; i++){\n        if (i < period - 1) {\n            sma.push(NaN);\n            continue;\n        }\n        let sum = 0;\n        for(let j = 0; j < period; j++){\n            sum += data[i - j];\n        }\n        sma.push(sum / period);\n    }\n    return sma;\n}\nconst smaCrossoverStrategy = {\n    id: \"sma_crossover\",\n    name: \"SMA Crossover\",\n    description: \"Generates signals based on crossovers between short-term and long-term SMAs\",\n    analyze: (data)=>{\n        const prices = data.map((d)=>d.close);\n        const shortPeriod = 10;\n        const longPeriod = 20;\n        const shortSMA = calculateSMA(prices, shortPeriod);\n        const longSMA = calculateSMA(prices, longPeriod);\n        // Need at least two points to compare crossover\n        if (shortSMA.length < 2 || longSMA.length < 2) return null;\n        const last = shortSMA.length - 1;\n        const prev = last - 1;\n        // Check for crossover\n        const isCrossUp = shortSMA[prev] <= longSMA[prev] && shortSMA[last] > longSMA[last];\n        const isCrossDown = shortSMA[prev] >= longSMA[prev] && shortSMA[last] < longSMA[last];\n        if (isCrossUp) {\n            return {\n                type: \"buy\",\n                price: data[last].close,\n                time: data[last].time\n            };\n        }\n        if (isCrossDown) {\n            return {\n                type: \"sell\",\n                price: data[last].close,\n                time: data[last].time\n            };\n        }\n        return null;\n    },\n    indicators: [\n        {\n            name: \"Short SMA\",\n            data: []\n        },\n        {\n            name: \"Long SMA\",\n            data: []\n        }\n    ]\n};\n// Register the strategy\n(0,_index__WEBPACK_IMPORTED_MODULE_0__.registerStrategy)(smaCrossoverStrategy);\n/* harmony default export */ __webpack_exports__[\"default\"] = (smaCrossoverStrategy);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zdHJhdGVnaWVzL3NtYS1jcm9zc292ZXIudHMiLCJtYXBwaW5ncyI6Ijs7QUFDcUU7QUFFckUsU0FBU0MsYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ2xELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEtBQUtJLE1BQU0sRUFBRUQsSUFBSztRQUNwQyxJQUFJQSxJQUFJRixTQUFTLEdBQUc7WUFDbEJDLElBQUlHLElBQUksQ0FBQ0M7WUFDVDtRQUNGO1FBRUEsSUFBSUMsTUFBTTtRQUNWLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxRQUFRTyxJQUFLO1lBQy9CRCxPQUFPUCxJQUFJLENBQUNHLElBQUlLLEVBQUU7UUFDcEI7UUFDQU4sSUFBSUcsSUFBSSxDQUFDRSxNQUFNTjtJQUNqQjtJQUNBLE9BQU9DO0FBQ1Q7QUFFQSxNQUFNTyx1QkFBaUM7SUFDckNDLElBQUk7SUFDSkMsTUFBTTtJQUNOQyxhQUFhO0lBQ2JDLFNBQVMsQ0FBQ2I7UUFDUixNQUFNYyxTQUFTZCxLQUFLZSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEtBQUs7UUFDcEMsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxhQUFhO1FBRW5CLE1BQU1DLFdBQVdyQixhQUFhZSxRQUFRSTtRQUN0QyxNQUFNRyxVQUFVdEIsYUFBYWUsUUFBUUs7UUFFckMsZ0RBQWdEO1FBQ2hELElBQUlDLFNBQVNoQixNQUFNLEdBQUcsS0FBS2lCLFFBQVFqQixNQUFNLEdBQUcsR0FBRyxPQUFPO1FBRXRELE1BQU1rQixPQUFPRixTQUFTaEIsTUFBTSxHQUFHO1FBQy9CLE1BQU1tQixPQUFPRCxPQUFPO1FBRXBCLHNCQUFzQjtRQUN0QixNQUFNRSxZQUFZSixRQUFRLENBQUNHLEtBQUssSUFBSUYsT0FBTyxDQUFDRSxLQUFLLElBQUlILFFBQVEsQ0FBQ0UsS0FBSyxHQUFHRCxPQUFPLENBQUNDLEtBQUs7UUFDbkYsTUFBTUcsY0FBY0wsUUFBUSxDQUFDRyxLQUFLLElBQUlGLE9BQU8sQ0FBQ0UsS0FBSyxJQUFJSCxRQUFRLENBQUNFLEtBQUssR0FBR0QsT0FBTyxDQUFDQyxLQUFLO1FBRXJGLElBQUlFLFdBQVc7WUFDYixPQUFPO2dCQUNMRSxNQUFNO2dCQUNOQyxPQUFPM0IsSUFBSSxDQUFDc0IsS0FBSyxDQUFDTCxLQUFLO2dCQUN2QlcsTUFBTTVCLElBQUksQ0FBQ3NCLEtBQUssQ0FBQ00sSUFBSTtZQUN2QjtRQUNGO1FBRUEsSUFBSUgsYUFBYTtZQUNmLE9BQU87Z0JBQ0xDLE1BQU07Z0JBQ05DLE9BQU8zQixJQUFJLENBQUNzQixLQUFLLENBQUNMLEtBQUs7Z0JBQ3ZCVyxNQUFNNUIsSUFBSSxDQUFDc0IsS0FBSyxDQUFDTSxJQUFJO1lBQ3ZCO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFDQUMsWUFBWTtRQUNWO1lBQ0VsQixNQUFNO1lBQ05YLE1BQU0sRUFBRTtRQUNWO1FBQ0E7WUFDRVcsTUFBTTtZQUNOWCxNQUFNLEVBQUU7UUFDVjtLQUNEO0FBQ0g7QUFFQSx3QkFBd0I7QUFDeEJGLHdEQUFnQkEsQ0FBQ1c7QUFFakIsK0RBQWVBLG9CQUFvQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvc3RyYXRlZ2llcy9zbWEtY3Jvc3NvdmVyLnRzPzQ3YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FuZGxlc3RpY2tEYXRhIH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcclxuaW1wb3J0IHsgU3RyYXRlZ3ksIFN0cmF0ZWd5U2lnbmFsLCByZWdpc3RlclN0cmF0ZWd5IH0gZnJvbSAnLi9pbmRleCc7XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVTTUEoZGF0YTogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gIGNvbnN0IHNtYTogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChpIDwgcGVyaW9kIC0gMSkge1xyXG4gICAgICBzbWEucHVzaChOYU4pO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGVyaW9kOyBqKyspIHtcclxuICAgICAgc3VtICs9IGRhdGFbaSAtIGpdO1xyXG4gICAgfVxyXG4gICAgc21hLnB1c2goc3VtIC8gcGVyaW9kKTtcclxuICB9XHJcbiAgcmV0dXJuIHNtYTtcclxufVxyXG5cclxuY29uc3Qgc21hQ3Jvc3NvdmVyU3RyYXRlZ3k6IFN0cmF0ZWd5ID0ge1xyXG4gIGlkOiAnc21hX2Nyb3Nzb3ZlcicsXHJcbiAgbmFtZTogJ1NNQSBDcm9zc292ZXInLFxyXG4gIGRlc2NyaXB0aW9uOiAnR2VuZXJhdGVzIHNpZ25hbHMgYmFzZWQgb24gY3Jvc3NvdmVycyBiZXR3ZWVuIHNob3J0LXRlcm0gYW5kIGxvbmctdGVybSBTTUFzJyxcclxuICBhbmFseXplOiAoZGF0YTogQ2FuZGxlc3RpY2tEYXRhW10pID0+IHtcclxuICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XHJcbiAgICBjb25zdCBzaG9ydFBlcmlvZCA9IDEwO1xyXG4gICAgY29uc3QgbG9uZ1BlcmlvZCA9IDIwO1xyXG5cclxuICAgIGNvbnN0IHNob3J0U01BID0gY2FsY3VsYXRlU01BKHByaWNlcywgc2hvcnRQZXJpb2QpO1xyXG4gICAgY29uc3QgbG9uZ1NNQSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIGxvbmdQZXJpb2QpO1xyXG5cclxuICAgIC8vIE5lZWQgYXQgbGVhc3QgdHdvIHBvaW50cyB0byBjb21wYXJlIGNyb3Nzb3ZlclxyXG4gICAgaWYgKHNob3J0U01BLmxlbmd0aCA8IDIgfHwgbG9uZ1NNQS5sZW5ndGggPCAyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBsYXN0ID0gc2hvcnRTTUEubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IHByZXYgPSBsYXN0IC0gMTtcclxuXHJcbiAgICAvLyBDaGVjayBmb3IgY3Jvc3NvdmVyXHJcbiAgICBjb25zdCBpc0Nyb3NzVXAgPSBzaG9ydFNNQVtwcmV2XSA8PSBsb25nU01BW3ByZXZdICYmIHNob3J0U01BW2xhc3RdID4gbG9uZ1NNQVtsYXN0XTtcclxuICAgIGNvbnN0IGlzQ3Jvc3NEb3duID0gc2hvcnRTTUFbcHJldl0gPj0gbG9uZ1NNQVtwcmV2XSAmJiBzaG9ydFNNQVtsYXN0XSA8IGxvbmdTTUFbbGFzdF07XHJcblxyXG4gICAgaWYgKGlzQ3Jvc3NVcCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdidXknLFxyXG4gICAgICAgIHByaWNlOiBkYXRhW2xhc3RdLmNsb3NlLFxyXG4gICAgICAgIHRpbWU6IGRhdGFbbGFzdF0udGltZSBhcyBudW1iZXIsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ3Jvc3NEb3duKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3NlbGwnLFxyXG4gICAgICAgIHByaWNlOiBkYXRhW2xhc3RdLmNsb3NlLFxyXG4gICAgICAgIHRpbWU6IGRhdGFbbGFzdF0udGltZSBhcyBudW1iZXIsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSxcclxuICBpbmRpY2F0b3JzOiBbXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdTaG9ydCBTTUEnLFxyXG4gICAgICBkYXRhOiBbXSwgLy8gVGhpcyB3aWxsIGJlIHBvcHVsYXRlZCB3aGVuIHRoZSBzdHJhdGVneSBydW5zXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnTG9uZyBTTUEnLFxyXG4gICAgICBkYXRhOiBbXSwgLy8gVGhpcyB3aWxsIGJlIHBvcHVsYXRlZCB3aGVuIHRoZSBzdHJhdGVneSBydW5zXHJcbiAgICB9LFxyXG4gIF0sXHJcbn07XHJcblxyXG4vLyBSZWdpc3RlciB0aGUgc3RyYXRlZ3lcclxucmVnaXN0ZXJTdHJhdGVneShzbWFDcm9zc292ZXJTdHJhdGVneSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzbWFDcm9zc292ZXJTdHJhdGVneTsgIl0sIm5hbWVzIjpbInJlZ2lzdGVyU3RyYXRlZ3kiLCJjYWxjdWxhdGVTTUEiLCJkYXRhIiwicGVyaW9kIiwic21hIiwiaSIsImxlbmd0aCIsInB1c2giLCJOYU4iLCJzdW0iLCJqIiwic21hQ3Jvc3NvdmVyU3RyYXRlZ3kiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImFuYWx5emUiLCJwcmljZXMiLCJtYXAiLCJkIiwiY2xvc2UiLCJzaG9ydFBlcmlvZCIsImxvbmdQZXJpb2QiLCJzaG9ydFNNQSIsImxvbmdTTUEiLCJsYXN0IiwicHJldiIsImlzQ3Jvc3NVcCIsImlzQ3Jvc3NEb3duIiwidHlwZSIsInByaWNlIiwidGltZSIsImluZGljYXRvcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/strategies/sma-crossover.ts\n"));

/***/ })

});
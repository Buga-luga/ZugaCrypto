"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/ema-crossover */ \"(app-pages-browser)/./src/services/strategies/ema-crossover.ts\");\n/* harmony import */ var _services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/services/strategies/sma-crossover */ \"(app-pages-browser)/./src/services/strategies/sma-crossover.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token, exchange } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = function(data, chart) {\n        let isInitialSetup = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy || strategy === \"none\") {\n                console.log(\"No strategy selected or invalid strategy\");\n                return;\n            }\n            if (isInitialSetup) {\n                console.log(\"Setting up new strategy indicators\");\n                try {\n                    // Create marker series for signals using a line series\n                    markerSeriesRef.current = chart.addLineSeries({\n                        lastValueVisible: false,\n                        priceLineVisible: false,\n                        visible: false\n                    });\n                    // Create indicator series\n                    if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                        const indicators = [\n                            \"Fast MA\",\n                            \"Slow MA\"\n                        ];\n                        indicators.forEach((name, index)=>{\n                            console.log(\"Adding indicator: \".concat(name));\n                            const colors = [\n                                \"#2962FF\",\n                                \"#FF6B6B\"\n                            ]; // Blue for fast, Red for slow\n                            const lineSeries = chart.addLineSeries({\n                                color: colors[index],\n                                lineWidth: 2,\n                                title: name,\n                                priceFormat: {\n                                    type: \"price\",\n                                    precision: 2,\n                                    minMove: 0.01\n                                },\n                                lineStyle: 1,\n                                lastValueVisible: true,\n                                priceLineVisible: false\n                            });\n                            indicatorSeriesRefs.current.set(name, lineSeries);\n                        });\n                    }\n                } catch (e) {\n                    console.error(\"Error creating series:\", e);\n                    return;\n                }\n            }\n            // Calculate indicators\n            const prices = data.map((d)=>d.close);\n            const fastPeriod = 9;\n            const slowPeriod = 21;\n            const fastLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, fastPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, fastPeriod);\n            const slowLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, slowPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, slowPeriod);\n            // Update indicator lines\n            const fastSeries = indicatorSeriesRefs.current.get(\"Fast MA\");\n            const slowSeries = indicatorSeriesRefs.current.get(\"Slow MA\");\n            if (fastSeries && slowSeries) {\n                const fastData = fastLine.map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                const slowData = slowLine.map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                fastSeries.setData(fastData);\n                slowSeries.setData(slowData);\n            }\n            // Update markers\n            if (markerSeriesRef.current) {\n                const markers = [];\n                // Start from fastPeriod to ensure we have enough data for the indicators\n                for(let i = Math.max(fastPeriod, slowPeriod); i < data.length; i++){\n                    const prevFast = fastLine[i - 1];\n                    const prevSlow = slowLine[i - 1];\n                    const currFast = fastLine[i];\n                    const currSlow = slowLine[i];\n                    if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                        // Buy signal: Fast crosses above Slow\n                        if (prevFast <= prevSlow && currFast > currSlow) {\n                            markers.push({\n                                time: data[i].time,\n                                position: \"belowBar\",\n                                color: \"#26a69a\",\n                                shape: \"arrowUp\",\n                                text: \"Buy \".concat(data[i].close.toFixed(2)),\n                                size: 3\n                            });\n                            console.log(\"Buy Signal:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close.toFixed(2),\n                                fastMA: currFast.toFixed(2),\n                                slowMA: currSlow.toFixed(2)\n                            });\n                        } else if (prevFast >= prevSlow && currFast < currSlow) {\n                            markers.push({\n                                time: data[i].time,\n                                position: \"aboveBar\",\n                                color: \"#ef5350\",\n                                shape: \"arrowDown\",\n                                text: \"Sell \".concat(data[i].close.toFixed(2)),\n                                size: 3\n                            });\n                            console.log(\"Sell Signal:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close.toFixed(2),\n                                fastMA: currFast.toFixed(2),\n                                slowMA: currSlow.toFixed(2)\n                            });\n                        }\n                    }\n                }\n                if (markers.length > 0) {\n                    console.log(\"Setting \".concat(markers.length, \" markers\"));\n                    markerSeriesRef.current.setMarkers(markers);\n                }\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current && historicalDataRef.current.length > 0) {\n            console.log(\"Reinitializing strategy indicators\");\n            // Clean up old indicators and markers\n            if (markerSeriesRef.current) {\n                try {\n                    safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    safelyRemoveSeries(chartRef.current, series);\n                } catch (e) {\n                    console.error(\"Error removing indicator series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            // Initialize new strategy immediately if not none\n            if (strategy !== \"none\") {\n                try {\n                    updateStrategyIndicators(historicalDataRef.current, chartRef.current, true);\n                } catch (e) {\n                    console.error(\"Error initializing strategy:\", e);\n                }\n            }\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                var // Set candlestick data\n                _candlestickSeriesRef_current;\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                (_candlestickSeriesRef_current = candlestickSeriesRef.current) === null || _candlestickSeriesRef_current === void 0 ? void 0 : _candlestickSeriesRef_current.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Initialize strategy indicators if a strategy is selected\n                if (strategy !== \"none\") {\n                    console.log(\"Initializing strategy indicators after loading data\");\n                    updateStrategyIndicators(historicalData, chart, true);\n                }\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current,\n                            {\n                                ...newCandle,\n                                time: currentCandle.time\n                            }\n                        ];\n                        // Update strategy indicators with completed candle\n                        if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                            updateStrategyIndicators(historicalDataRef.current, chartRef.current, false);\n                        }\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: Number(candleTimestamp),\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                }\n                // Update candlestick series with the current state\n                candlestickSeriesRef.current.update(currentCandle);\n                // Update strategy indicators with current in-progress candle\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const updatedData = [\n                        ...historicalDataRef.current,\n                        currentCandle\n                    ];\n                    updateStrategyIndicators(updatedData, chartRef.current, false);\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 459,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"bet0c3GPpABv0spqAYVyx2BdTvc=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRTBDO0FBQ087QUFDZ0Q7QUFDakM7QUFDRztBQUNBO0FBaUI1RCxTQUFTUSxpQkFBaUIsS0FBK0Q7UUFBL0QsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUF5QixHQUEvRDs7SUFDL0IsTUFBTUMsb0JBQW9CWiw2Q0FBTUEsQ0FBaUI7SUFDakQsTUFBTWEsV0FBV2IsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU1jLHVCQUF1QmQsNkNBQU1BLENBQU07SUFDekMsTUFBTWUsc0JBQXNCZiw2Q0FBTUEsQ0FBbUIsSUFBSWdCO0lBQ3pELE1BQU1DLGtCQUFrQmpCLDZDQUFNQSxDQUFNO0lBQ3BDLE1BQU1rQixvQkFBb0JsQiw2Q0FBTUEsQ0FBUSxFQUFFO0lBRTFDLHFDQUFxQztJQUNyQyxNQUFNbUIscUJBQXFCLENBQUNDLE9BQWtCQztRQUM1QyxJQUFJO1lBQ0YsSUFBSUEsVUFBVUQsT0FBTztnQkFDbkJBLE1BQU1FLFlBQVksQ0FBQ0Q7WUFDckI7UUFDRixFQUFFLE9BQU9FLEdBQUc7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkY7UUFDMUM7SUFDRjtJQUVBLHlDQUF5QztJQUN6QyxNQUFNRywyQkFBMkIsU0FBQ0MsTUFBYVA7WUFBa0JRLGtGQUEwQjtRQUN6RixJQUFJO1lBQ0YsSUFBSSxDQUFDUixTQUFTLENBQUNPLEtBQUtFLE1BQU0sRUFBRTtnQkFDMUJMLFFBQVFNLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsTUFBTUMsbUJBQW1CM0IsaUVBQVdBLENBQUNLO1lBQ3JDLElBQUksQ0FBQ3NCLG9CQUFvQnRCLGFBQWEsUUFBUTtnQkFDNUNlLFFBQVFNLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsSUFBSUYsZ0JBQWdCO2dCQUNsQkosUUFBUU0sR0FB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QixPQUFPLEVBQUU7Z0JBQ3BCbkIsU0FBU21CLE9BQU8sQ0FBQzRILE1BQU07WUFDekI7UUFDRjtJQUNGLEdBQUc7UUFBQ3BKO1FBQVdDO0tBQVM7SUFFeEIscUJBQU8sOERBQUM4SjtRQUFJQyxLQUFLNUo7UUFBbUI2SixXQUFVOzs7Ozs7QUFDaEQ7R0FuYmdCbEs7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQ2hhcnQvQ2FuZGxlc3RpY2tDaGFydC50c3g/OGQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcbmltcG9ydCB7IFRpbWUsIElDaGFydEFwaSwgQ2hhcnRPcHRpb25zLCBEZWVwUGFydGlhbCwgTGluZVdpZHRoLCBCdXNpbmVzc0RheSwgVVRDVGltZXN0YW1wIH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcclxuaW1wb3J0IHsgZ2V0SGlzdG9yaWNhbERhdGEsIHN1YnNjcmliZVRvUHJpY2UsIFRpbWVmcmFtZSB9IGZyb20gJ0Avc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEknO1xyXG5pbXBvcnQgeyBTdHJhdGVneUlkLCBnZXRTdHJhdGVneSB9IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcyc7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZUVNQSB9IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcy9lbWEtY3Jvc3NvdmVyJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlU01BIH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzL3NtYS1jcm9zc292ZXInO1xyXG5cclxuaW50ZXJmYWNlIENhbmRsZXN0aWNrQ2hhcnRQcm9wcyB7XHJcbiAgdGltZWZyYW1lOiBUaW1lZnJhbWU7XHJcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XHJcbiAgdG9rZW46IHN0cmluZztcclxuICBleGNoYW5nZTogJ3VuaXN3YXAnIHwgJ3JheWRpdW0nIHwgJ2NvaW5iYXNlJztcclxufVxyXG5cclxuaW50ZXJmYWNlIENhbmRsZSB7XHJcbiAgdGltZTogVGltZTtcclxuICBvcGVuOiBudW1iZXI7XHJcbiAgaGlnaDogbnVtYmVyO1xyXG4gIGxvdzogbnVtYmVyO1xyXG4gIGNsb3NlOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgdGltZWZyYW1lLCBzdHJhdGVneSwgdG9rZW4sIGV4Y2hhbmdlIH06IENhbmRsZXN0aWNrQ2hhcnRQcm9wcykge1xyXG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBjYW5kbGVzdGlja1Nlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IGluZGljYXRvclNlcmllc1JlZnMgPSB1c2VSZWY8TWFwPHN0cmluZywgYW55Pj4obmV3IE1hcCgpKTtcclxuICBjb25zdCBtYXJrZXJTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcclxuICBjb25zdCBoaXN0b3JpY2FsRGF0YVJlZiA9IHVzZVJlZjxhbnlbXT4oW10pO1xyXG5cclxuICAvLyBGdW5jdGlvbiB0byBzYWZlbHkgcmVtb3ZlIGEgc2VyaWVzXHJcbiAgY29uc3Qgc2FmZWx5UmVtb3ZlU2VyaWVzID0gKGNoYXJ0OiBJQ2hhcnRBcGksIHNlcmllczogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoc2VyaWVzICYmIGNoYXJ0KSB7XHJcbiAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllcyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc2VyaWVzOicsIGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzXHJcbiAgY29uc3QgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzID0gKGRhdGE6IGFueVtdLCBjaGFydDogSUNoYXJ0QXBpLCBpc0luaXRpYWxTZXR1cDogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIWNoYXJ0IHx8ICFkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGFydCBvciBkYXRhIG5vdCByZWFkeSwgc2tpcHBpbmcgdXBkYXRlJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzZWxlY3RlZFN0cmF0ZWd5ID0gZ2V0U3RyYXRlZ3koc3RyYXRlZ3kpO1xyXG4gICAgICBpZiAoIXNlbGVjdGVkU3RyYXRlZ3kgfHwgc3RyYXRlZ3kgPT09ICdub25lJykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBzdHJhdGVneSBzZWxlY3RlZCBvciBpbnZhbGlkIHN0cmF0ZWd5Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNJbml0aWFsU2V0dXApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1cCBuZXcgc3RyYXRlZ3kgaW5kaWNhdG9ycycpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBDcmVhdGUgbWFya2VyIHNlcmllcyBmb3Igc2lnbmFscyB1c2luZyBhIGxpbmUgc2VyaWVzXHJcbiAgICAgICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xyXG4gICAgICAgICAgICBsYXN0VmFsdWVWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJpY2VMaW5lVmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLCAvLyBIaWRlIHRoZSBsaW5lIGl0c2VsZlxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGluZGljYXRvciBzZXJpZXNcclxuICAgICAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicgfHwgc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ3NtYV9jcm9zc292ZXInKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljYXRvcnMgPSBbJ0Zhc3QgTUEnLCAnU2xvdyBNQSddO1xyXG4gICAgICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goKG5hbWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBpbmRpY2F0b3I6ICR7bmFtZX1gKTtcclxuICAgICAgICAgICAgICBjb25zdCBjb2xvcnMgPSBbJyMyOTYyRkYnLCAnI0ZGNkI2QiddOyAvLyBCbHVlIGZvciBmYXN0LCBSZWQgZm9yIHNsb3dcclxuICAgICAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2luZGV4XSxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcclxuICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAyLFxyXG4gICAgICAgICAgICAgICAgICBtaW5Nb3ZlOiAwLjAxLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpbmVTdHlsZTogMSwgLy8gU29saWQgbGluZVxyXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByaWNlTGluZVZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQobmFtZSwgbGluZVNlcmllcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNlcmllczonLCBlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBpbmRpY2F0b3JzXHJcbiAgICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XHJcbiAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xyXG4gICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBmYXN0TGluZSA9IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyBcclxuICAgICAgICA/IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpXHJcbiAgICAgICAgOiBjYWxjdWxhdGVTTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcclxuICAgICAgY29uc3Qgc2xvd0xpbmUgPSBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcidcclxuICAgICAgICA/IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpXHJcbiAgICAgICAgOiBjYWxjdWxhdGVTTUEocHJpY2VzLCBzbG93UGVyaW9kKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3IgbGluZXNcclxuICAgICAgY29uc3QgZmFzdFNlcmllcyA9IGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5nZXQoJ0Zhc3QgTUEnKTtcclxuICAgICAgY29uc3Qgc2xvd1NlcmllcyA9IGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5nZXQoJ1Nsb3cgTUEnKTtcclxuXHJcbiAgICAgIGlmIChmYXN0U2VyaWVzICYmIHNsb3dTZXJpZXMpIHtcclxuICAgICAgICBjb25zdCBmYXN0RGF0YSA9IGZhc3RMaW5lLm1hcCgodmFsdWU6IG51bWJlciwgaWR4OiBudW1iZXIpID0+ICh7XHJcbiAgICAgICAgICB0aW1lOiBkYXRhW2lkeF0udGltZSxcclxuICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcclxuICAgICAgICB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNsb3dEYXRhID0gc2xvd0xpbmUubWFwKCh2YWx1ZTogbnVtYmVyLCBpZHg6IG51bWJlcikgPT4gKHtcclxuICAgICAgICAgIHRpbWU6IGRhdGFbaWR4XS50aW1lLFxyXG4gICAgICAgICAgdmFsdWU6IGlzTmFOKHZhbHVlKSA/IG51bGwgOiB2YWx1ZVxyXG4gICAgICAgIH0pKS5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKTtcclxuXHJcbiAgICAgICAgZmFzdFNlcmllcy5zZXREYXRhKGZhc3REYXRhKTtcclxuICAgICAgICBzbG93U2VyaWVzLnNldERhdGEoc2xvd0RhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgbWFya2Vyc1xyXG4gICAgICBpZiAobWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCBtYXJrZXJzID0gW107XHJcbiAgICAgICAgLy8gU3RhcnQgZnJvbSBmYXN0UGVyaW9kIHRvIGVuc3VyZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciB0aGUgaW5kaWNhdG9yc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heChmYXN0UGVyaW9kLCBzbG93UGVyaW9kKTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdExpbmVbaSAtIDFdO1xyXG4gICAgICAgICAgY29uc3QgcHJldlNsb3cgPSBzbG93TGluZVtpIC0gMV07XHJcbiAgICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xyXG4gICAgICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93TGluZVtpXTtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xyXG4gICAgICAgICAgICAvLyBCdXkgc2lnbmFsOiBGYXN0IGNyb3NzZXMgYWJvdmUgU2xvd1xyXG4gICAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xyXG4gICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXHJcbiAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogYEJ1eSAke2RhdGFbaV0uY2xvc2UudG9GaXhlZCgyKX1gLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMyxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQnV5IFNpZ25hbDonLCB7XHJcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UudG9GaXhlZCgyKSxcclxuICAgICAgICAgICAgICAgIGZhc3RNQTogY3VyckZhc3QudG9GaXhlZCgyKSxcclxuICAgICAgICAgICAgICAgIHNsb3dNQTogY3VyclNsb3cudG9GaXhlZCgyKVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNlbGwgc2lnbmFsOiBGYXN0IGNyb3NzZXMgYmVsb3cgU2xvd1xyXG4gICAgICAgICAgICBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XHJcbiAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZWY1MzUwJyxcclxuICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGBTZWxsICR7ZGF0YVtpXS5jbG9zZS50b0ZpeGVkKDIpfWAsXHJcbiAgICAgICAgICAgICAgICBzaXplOiAzLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZWxsIFNpZ25hbDonLCB7XHJcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgcHJpY2U6IGRhdGFbaV0uY2xvc2UudG9GaXhlZCgyKSxcclxuICAgICAgICAgICAgICAgIGZhc3RNQTogY3VyckZhc3QudG9GaXhlZCgyKSxcclxuICAgICAgICAgICAgICAgIHNsb3dNQTogY3VyclNsb3cudG9GaXhlZCgyKVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nICR7bWFya2Vycy5sZW5ndGh9IG1hcmtlcnNgKTtcclxuICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50LnNldE1hcmtlcnMobWFya2Vycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9yczonLCBlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBVcGRhdGUgdGhlIHN0cmF0ZWd5IGNoYW5nZSBlZmZlY3RcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ1N0cmF0ZWd5IGNoYW5nZWQ6Jywgc3RyYXRlZ3kpO1xyXG4gICAgXHJcbiAgICBpZiAoY2hhcnRSZWYuY3VycmVudCAmJiBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ1JlaW5pdGlhbGl6aW5nIHN0cmF0ZWd5IGluZGljYXRvcnMnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFuIHVwIG9sZCBpbmRpY2F0b3JzIGFuZCBtYXJrZXJzXHJcbiAgICAgIGlmIChtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnRSZWYuY3VycmVudCwgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIG1hcmtlciBzZXJpZXM6JywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0UmVmLmN1cnJlbnQhLCBzZXJpZXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGluZGljYXRvciBzZXJpZXM6JywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXplIG5ldyBzdHJhdGVneSBpbW1lZGlhdGVseSBpZiBub3Qgbm9uZVxyXG4gICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIHN0cmF0ZWd5OicsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtzdHJhdGVneV0pOyAvLyBPbmx5IHJ1biB3aGVuIHN0cmF0ZWd5IGNoYW5nZXNcclxuXHJcbiAgLy8gTWFpbiBjaGFydCBpbml0aWFsaXphdGlvbiBlZmZlY3RcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjaGFydENvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIGNoYXJ0IHdpdGggdGltZWZyYW1lOicsIHRpbWVmcmFtZSk7XHJcblxyXG4gICAgY29uc3QgZm9ybWF0VGltZSA9ICh0aW1lOiBUaW1lKSA9PiB7XHJcbiAgICAgIGxldCBkYXRlOiBEYXRlO1xyXG4gICAgICBcclxuICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEhhbmRsZSBCdXNpbmVzc0RheSBmb3JtYXRcclxuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRpbWUgYXMgQnVzaW5lc3NEYXk7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZm9ybWF0T3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgbW9udGg6ICdzaG9ydCcsXHJcbiAgICAgICAgZGF5OiAnbnVtZXJpYycsXHJcbiAgICAgICAgaG91cjogJzItZGlnaXQnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIGhvdXIxMjogZmFsc2VcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEZvciBkYWlseSB0aW1lZnJhbWVzLCBkb24ndCBzaG93IHRpbWVcclxuICAgICAgaWYgKHRpbWVmcmFtZSA9PT0gJzFkJykge1xyXG4gICAgICAgIGRlbGV0ZSBmb3JtYXRPcHRpb25zLmhvdXI7XHJcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMubWludXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCBmb3JtYXRPcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2hhcnRPcHRpb25zOiBEZWVwUGFydGlhbDxDaGFydE9wdGlvbnM+ID0ge1xyXG4gICAgICBsYXlvdXQ6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzFFMjIyRCcgfSxcclxuICAgICAgICB0ZXh0Q29sb3I6ICcjREREJyxcclxuICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgZm9udEZhbWlseTogJ1JvYm90bywgc2Fucy1zZXJpZicsXHJcbiAgICAgIH0sXHJcbiAgICAgIGdyaWQ6IHtcclxuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxyXG4gICAgICAgIGhvcnpMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGNyb3NzaGFpcjoge1xyXG4gICAgICAgIG1vZGU6IDEsXHJcbiAgICAgICAgdmVydExpbmU6IHtcclxuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcclxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXHJcbiAgICAgICAgICBzdHlsZTogMyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvcnpMaW5lOiB7XHJcbiAgICAgICAgICB3aWR0aDogMSBhcyBMaW5lV2lkdGgsXHJcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxyXG4gICAgICAgICAgc3R5bGU6IDMsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgdGltZVNjYWxlOiB7XHJcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcclxuICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICBzZWNvbmRzVmlzaWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXHJcbiAgICAgIH0sXHJcbiAgICAgIGxvY2FsaXphdGlvbjoge1xyXG4gICAgICAgIHRpbWVGb3JtYXR0ZXI6IGZvcm1hdFRpbWUsXHJcbiAgICAgIH0sXHJcbiAgICAgIHdhdGVybWFyazoge1xyXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjaGFydCA9IGNyZWF0ZUNoYXJ0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQsIHtcclxuICAgICAgLi4uY2hhcnRPcHRpb25zLFxyXG4gICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xyXG4gICAgICB1cENvbG9yOiAnIzI2YTY5YScsXHJcbiAgICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxyXG4gICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcclxuICAgICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCA9IGNhbmRsZXN0aWNrU2VyaWVzO1xyXG5cclxuICAgIC8vIEZldGNoIGhpc3RvcmljYWwgZGF0YVxyXG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgaGlzdG9yaWNhbERhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgaGlzdG9yaWNhbCBkYXRhOicsIGhpc3RvcmljYWxEYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IGhpc3RvcmljYWxEYXRhO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNldCBjYW5kbGVzdGljayBkYXRhXHJcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudD8uc2V0RGF0YShoaXN0b3JpY2FsRGF0YS5tYXAoZCA9PiAoe1xyXG4gICAgICAgICAgdGltZTogZC50aW1lIGFzIFRpbWUsXHJcbiAgICAgICAgICBvcGVuOiBkLm9wZW4sXHJcbiAgICAgICAgICBoaWdoOiBkLmhpZ2gsXHJcbiAgICAgICAgICBsb3c6IGQubG93LFxyXG4gICAgICAgICAgY2xvc2U6IGQuY2xvc2VcclxuICAgICAgICB9KSkpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHN0cmF0ZWd5IGluZGljYXRvcnMgaWYgYSBzdHJhdGVneSBpcyBzZWxlY3RlZFxyXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHN0cmF0ZWd5IGluZGljYXRvcnMgYWZ0ZXIgbG9hZGluZyBkYXRhJyk7XHJcbiAgICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGEsIGNoYXJ0LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWREYXRhKCk7XHJcbiAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlYWwtdGltZSBwcmljZSB1cGRhdGVzXHJcbiAgICBsZXQgY3VycmVudENhbmRsZSA9IHtcclxuICAgICAgb3BlbjogMCxcclxuICAgICAgaGlnaDogLUluZmluaXR5LFxyXG4gICAgICBsb3c6IEluZmluaXR5LFxyXG4gICAgICBjbG9zZTogMCxcclxuICAgICAgdGltZTogMCxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZ2V0SW50ZXJ2YWxTZWNvbmRzID0gKHRmOiBUaW1lZnJhbWUpOiBudW1iZXIgPT4ge1xyXG4gICAgICBzd2l0Y2ggKHRmKSB7XHJcbiAgICAgICAgY2FzZSAnMW0nOiByZXR1cm4gNjA7XHJcbiAgICAgICAgY2FzZSAnNW0nOiByZXR1cm4gMzAwO1xyXG4gICAgICAgIGNhc2UgJzE1bSc6IHJldHVybiA5MDA7XHJcbiAgICAgICAgY2FzZSAnMzBtJzogcmV0dXJuIDE4MDA7XHJcbiAgICAgICAgY2FzZSAnMWgnOiByZXR1cm4gMzYwMDtcclxuICAgICAgICBjYXNlICc0aCc6IHJldHVybiAxNDQwMDtcclxuICAgICAgICBjYXNlICcxZCc6IHJldHVybiA4NjQwMDtcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gNjA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1ByaWNlKChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2FuZGxlVGltZXN0YW1wID0gTWF0aC5mbG9vcihkYXRhLnRpbWUgLyBpbnRlcnZhbFNlY29uZHMpICogaW50ZXJ2YWxTZWNvbmRzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcgY2FuZGxlXHJcbiAgICAgICAgaWYgKGNhbmRsZVRpbWVzdGFtcCAhPT0gKGN1cnJlbnRDYW5kbGUudGltZSBhcyBVVENUaW1lc3RhbXApKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBjYW5kbGUsIGZpbmFsaXplIGl0XHJcbiAgICAgICAgICBpZiAoY3VycmVudENhbmRsZS50aW1lICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhbmRsZSA9IHtcclxuICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXHJcbiAgICAgICAgICAgICAgb3BlbjogY3VycmVudENhbmRsZS5vcGVuLFxyXG4gICAgICAgICAgICAgIGhpZ2g6IGN1cnJlbnRDYW5kbGUuaGlnaCxcclxuICAgICAgICAgICAgICBsb3c6IGN1cnJlbnRDYW5kbGUubG93LFxyXG4gICAgICAgICAgICAgIGNsb3NlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShuZXdDYW5kbGUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGhpc3RvcmljYWwgZGF0YSB3aXRoIHRoZSBuZXcgY2FuZGxlXHJcbiAgICAgICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwge1xyXG4gICAgICAgICAgICAgIC4uLm5ld0NhbmRsZSxcclxuICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUgYXMgVVRDVGltZXN0YW1wXHJcbiAgICAgICAgICAgIH1dO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBjb21wbGV0ZWQgY2FuZGxlXHJcbiAgICAgICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQgJiYgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGNoYXJ0UmVmLmN1cnJlbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBjYW5kbGVcclxuICAgICAgICAgIGN1cnJlbnRDYW5kbGUgPSB7XHJcbiAgICAgICAgICAgIHRpbWU6IE51bWJlcihjYW5kbGVUaW1lc3RhbXApIGFzIFVUQ1RpbWVzdGFtcCxcclxuICAgICAgICAgICAgb3BlbjogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICBjbG9zZTogZGF0YS52YWx1ZSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYW5kbGVcclxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlID4gY3VycmVudENhbmRsZS5oaWdoKSBjdXJyZW50Q2FuZGxlLmhpZ2ggPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPCBjdXJyZW50Q2FuZGxlLmxvdykgY3VycmVudENhbmRsZS5sb3cgPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgY3VycmVudENhbmRsZS5jbG9zZSA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBjdXJyZW50IGluLXByb2dyZXNzIGNhbmRsZVxyXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQgJiYgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNpemUgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjdXJyZW50Q2FuZGxlXTtcclxuICAgICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyh1cGRhdGVkRGF0YSwgY2hhcnRSZWYuY3VycmVudCwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgdGltZWZyYW1lKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgVHJhZGluZ1ZpZXcgbG9nbyBlbGVtZW50cyBpZiB0aGV5IGV4aXN0XHJcbiAgICBjb25zdCByZW1vdmVUcmFkaW5nVmlld0xvZ28gPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxvZ29FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3R2LWF0dHItbG9nbycpO1xyXG4gICAgICBpZiAobG9nb0VsZW1lbnQpIHtcclxuICAgICAgICBsb2dvRWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaGVhZGVyTG9nbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50di1oZWFkZXJfX2xpbmsnKTtcclxuICAgICAgaWYgKGhlYWRlckxvZ28pIHtcclxuICAgICAgICBoZWFkZXJMb2dvLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJ1biBsb2dvIHJlbW92YWwgYWZ0ZXIgY2hhcnQgaXMgY3JlYXRlZFxyXG4gICAgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvKCk7XHJcbiAgICAvLyBBbHNvIHJ1biBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGNhdGNoIGR5bmFtaWNhbGx5IGFkZGVkIGVsZW1lbnRzXHJcbiAgICBjb25zdCBsb2dvVGltZW91dElkID0gc2V0VGltZW91dChyZW1vdmVUcmFkaW5nVmlld0xvZ28sIDEwMCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICBpZiAoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5hcHBseU9wdGlvbnMoe1xyXG4gICAgICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICBjbGVhclRpbWVvdXQobG9nb1RpbWVvdXRJZCk7XHJcbiAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbdGltZWZyYW1lLCBzdHJhdGVneV0pO1xyXG5cclxuICByZXR1cm4gPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgLz47XHJcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUNoYXJ0IiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJzdWJzY3JpYmVUb1ByaWNlIiwiZ2V0U3RyYXRlZ3kiLCJjYWxjdWxhdGVFTUEiLCJjYWxjdWxhdGVTTUEiLCJDYW5kbGVzdGlja0NoYXJ0IiwidGltZWZyYW1lIiwic3RyYXRlZ3kiLCJ0b2tlbiIsImV4Y2hhbmdlIiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZXN0aWNrU2VyaWVzUmVmIiwiaW5kaWNhdG9yU2VyaWVzUmVmcyIsIk1hcCIsIm1hcmtlclNlcmllc1JlZiIsImhpc3RvcmljYWxEYXRhUmVmIiwic2FmZWx5UmVtb3ZlU2VyaWVzIiwiY2hhcnQiLCJzZXJpZXMiLCJyZW1vdmVTZXJpZXMiLCJlIiwiY29uc29sZSIsImVycm9yIiwidXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzIiwiZGF0YSIsImlzSW5pdGlhbFNldHVwIiwibGVuZ3RoIiwibG9nIiwic2VsZWN0ZWRTdHJhdGVneSIsImN1cnJlbnQiLCJhZGRMaW5lU2VyaWVzIiwibGFzdFZhbHVlVmlzaWJsZSIsInByaWNlTGluZVZpc2libGUiLCJ2aXNpYmxlIiwiaWQiLCJpbmRpY2F0b3JzIiwiZm9yRWFjaCIsIm5hbWUiLCJpbmRleCIsImNvbG9ycyIsImxpbmVTZXJpZXMiLCJjb2xvciIsImxpbmVXaWR0aCIsInRpdGxlIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsImxpbmVTdHlsZSIsInNldCIsInByaWNlcyIsIm1hcCIsImQiLCJjbG9zZSIsImZhc3RQZXJpb2QiLCJzbG93UGVyaW9kIiwiZmFzdExpbmUiLCJzbG93TGluZSIsImZhc3RTZXJpZXMiLCJnZXQiLCJzbG93U2VyaWVzIiwiZmFzdERhdGEiLCJ2YWx1ZSIsImlkeCIsInRpbWUiLCJpc05hTiIsImZpbHRlciIsInNsb3dEYXRhIiwic2V0RGF0YSIsIm1hcmtlcnMiLCJpIiwiTWF0aCIsIm1heCIsInByZXZGYXN0IiwicHJldlNsb3ciLCJjdXJyRmFzdCIsImN1cnJTbG93IiwicHVzaCIsInBvc2l0aW9uIiwic2hhcGUiLCJ0ZXh0IiwidG9GaXhlZCIsInNpemUiLCJEYXRlIiwidG9Mb2NhbGVTdHJpbmciLCJwcmljZSIsImZhc3RNQSIsInNsb3dNQSIsInNldE1hcmtlcnMiLCJjbGVhciIsImZvcm1hdFRpbWUiLCJkYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJjaGFydE9wdGlvbnMiLCJsYXlvdXQiLCJiYWNrZ3JvdW5kIiwidGV4dENvbG9yIiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiZ3JpZCIsInZlcnRMaW5lcyIsImhvcnpMaW5lcyIsImNyb3NzaGFpciIsIm1vZGUiLCJ2ZXJ0TGluZSIsIndpZHRoIiwic3R5bGUiLCJob3J6TGluZSIsInRpbWVTY2FsZSIsImJvcmRlckNvbG9yIiwidGltZVZpc2libGUiLCJzZWNvbmRzVmlzaWJsZSIsInJpZ2h0UHJpY2VTY2FsZSIsImxvY2FsaXphdGlvbiIsInRpbWVGb3JtYXR0ZXIiLCJ3YXRlcm1hcmsiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNhbmRsZXN0aWNrU2VyaWVzIiwiYWRkQ2FuZGxlc3RpY2tTZXJpZXMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsImxvYWREYXRhIiwiaGlzdG9yaWNhbERhdGEiLCJvcGVuIiwiaGlnaCIsImxvdyIsImN1cnJlbnRDYW5kbGUiLCJJbmZpbml0eSIsImdldEludGVydmFsU2Vjb25kcyIsInRmIiwidW5zdWJzY3JpYmUiLCJpbnRlcnZhbFNlY29uZHMiLCJjYW5kbGVUaW1lc3RhbXAiLCJmbG9vciIsIm5ld0NhbmRsZSIsInVwZGF0ZSIsIk51bWJlciIsInVwZGF0ZWREYXRhIiwicmVtb3ZlVHJhZGluZ1ZpZXdMb2dvIiwibG9nb0VsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicmVtb3ZlIiwiaGVhZGVyTG9nbyIsInF1ZXJ5U2VsZWN0b3IiLCJsb2dvVGltZW91dElkIiwic2V0VGltZW91dCIsImhhbmRsZVJlc2l6ZSIsImFwcGx5T3B0aW9ucyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentPrice, setCurrentPrice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const candleSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentCandleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false,\n                fixLeftEdge: true,\n                rightOffset: 12,\n                barSpacing: 6,\n                minBarSpacing: 2,\n                rightBarStaysOnScroll: true,\n                lockVisibleTimeRangeOnResize: true,\n                tickMarkFormatter: (time)=>{\n                    const date = new Date(time * 1000);\n                    if (timeframe === \"1d\" || timeframe === \"1w\") {\n                        return date.toLocaleDateString();\n                    }\n                    return date.toLocaleTimeString([], {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\"\n                    });\n                }\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\",\n                autoScale: true,\n                scaleMargins: {\n                    top: 0.2,\n                    bottom: 0.2\n                },\n                entireTextOnly: true\n            },\n            handleScale: {\n                axisPressedMouseMove: {\n                    time: true,\n                    price: true\n                },\n                mouseWheel: true,\n                pinch: true\n            },\n            handleScroll: {\n                mouseWheel: true,\n                pressedMouseMove: true,\n                horzTouchDrag: true,\n                vertTouchDrag: true\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\",\n            priceFormat: {\n                type: \"price\",\n                precision: 2,\n                minMove: 0.01\n            }\n        });\n        candleSeriesRef.current = candlestickSeries;\n        chartRef.current = chart;\n        // Fetch historical data first\n        (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe).then((data)=>{\n            if (data) {\n                const candles = data.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    }));\n                candlestickSeries.setData(candles);\n                // Set up the current candle\n                const lastCandle = candles[candles.length - 1];\n                const currentTime = Math.floor(Date.now() / 1000);\n                const interval = timeframe === \"1w\" ? 604800 : timeframe === \"1d\" ? 86400 : timeframe === \"4h\" ? 14400 : timeframe === \"1h\" ? 3600 : timeframe === \"30m\" ? 1800 : timeframe === \"15m\" ? 900 : timeframe === \"5m\" ? 300 : 60;\n                const currentInterval = Math.floor(currentTime / interval) * interval;\n                currentCandleRef.current = {\n                    time: currentInterval,\n                    open: lastCandle.close,\n                    high: lastCandle.close,\n                    low: lastCandle.close,\n                    close: lastCandle.close\n                };\n                // Set visible range based on timeframe\n                const timeScale = chart.timeScale();\n                const visibleBars = timeframe === \"1w\" ? 52 : timeframe === \"1d\" ? 90 : timeframe === \"4h\" ? 180 : timeframe === \"1h\" ? 168 : 240; // 4 hours for smaller timeframes\n                const timeRange = interval * visibleBars;\n                const fromTime = currentTime - timeRange;\n                const toTime = currentTime + interval * 2;\n                timeScale.setVisibleRange({\n                    from: fromTime,\n                    to: toTime\n                });\n                timeScale.fitContent();\n            }\n        }).catch(console.error);\n        // Subscribe to real-time price updates\n        const unsubscribePrice = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((param)=>{\n            let { time, value } = param;\n            var _chartRef_current;\n            // Update current price display immediately\n            setCurrentPrice(value.toLocaleString(\"en-US\", {\n                minimumFractionDigits: 2,\n                maximumFractionDigits: 2\n            }));\n            // Update or create new candle\n            if (!currentCandleRef.current) {\n                const interval = timeframe === \"1w\" ? 604800 : timeframe === \"1d\" ? 86400 : timeframe === \"4h\" ? 14400 : timeframe === \"1h\" ? 3600 : timeframe === \"30m\" ? 1800 : timeframe === \"15m\" ? 900 : timeframe === \"5m\" ? 300 : 60;\n                const currentInterval = Math.floor(time / interval) * interval;\n                currentCandleRef.current = {\n                    time: currentInterval,\n                    open: value,\n                    high: value,\n                    low: value,\n                    close: value\n                };\n            } else {\n                const interval = timeframe === \"1w\" ? 604800 : timeframe === \"1d\" ? 86400 : timeframe === \"4h\" ? 14400 : timeframe === \"1h\" ? 3600 : timeframe === \"30m\" ? 1800 : timeframe === \"15m\" ? 900 : timeframe === \"5m\" ? 300 : 60;\n                const currentInterval = Math.floor(time / interval) * interval;\n                const candleInterval = Math.floor(currentCandleRef.current.time / interval) * interval;\n                if (currentInterval > candleInterval) {\n                    // Save the completed candle\n                    const completedCandle = {\n                        ...currentCandleRef.current\n                    };\n                    candleSeriesRef.current.update(completedCandle);\n                    // Create new candle\n                    currentCandleRef.current = {\n                        time: currentInterval,\n                        open: value,\n                        high: value,\n                        low: value,\n                        close: value\n                    };\n                } else {\n                    // Update current candle\n                    currentCandleRef.current.high = Math.max(currentCandleRef.current.high, value);\n                    currentCandleRef.current.low = Math.min(currentCandleRef.current.low, value);\n                    currentCandleRef.current.close = value;\n                    // Update the candlestick immediately\n                    candleSeriesRef.current.update(currentCandleRef.current);\n                }\n            }\n            // Auto-scroll if we're at the right edge\n            const timeScale = (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.timeScale();\n            if (timeScale) {\n                const logicalRange = timeScale.getVisibleLogicalRange();\n                if (logicalRange && logicalRange.to >= currentCandleRef.current.time - 5) {\n                    timeScale.scrollToPosition(1, false);\n                }\n            }\n        }, timeframe);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n            unsubscribePrice();\n        };\n    }, [\n        timeframe\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative w-full h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"w-full h-full\"\n            }, void 0, false, {\n                fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 263,\n                columnNumber: 7\n            }, this),\n            currentPrice && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-4 left-4 bg-[#2B2B43] px-4 py-2 rounded-lg shadow-lg\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center gap-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-gray-400\",\n                            children: \"BTC/USD\"\n                        }, void 0, false, {\n                            fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                            lineNumber: 267,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-2xl font-semibold text-white\",\n                            children: [\n                                \"$\",\n                                currentPrice\n                            ]\n                        }, void 0, true, {\n                            fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                            lineNumber: 268,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                    lineNumber: 266,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 265,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"e:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 262,\n        columnNumber: 5\n    }, this);\n}\n_s(CandlestickChart, \"xysZfrJCJac1Qt+K59tcNnkLslI=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ29EO0FBQ3dEO0FBQ1k7QUFjakgsU0FBU00saUJBQWlCLEtBQW9DO1FBQXBDLEVBQUVDLFNBQVMsRUFBeUIsR0FBcEM7O0lBQy9CLE1BQU1DLG9CQUFvQlAsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1RLFdBQVdSLDZDQUFNQSxDQUFtQjtJQUMxQyxNQUFNLENBQUNTLGNBQWNDLGdCQUFnQixHQUFHVCwrQ0FBUUEsQ0FBUztJQUN6RCxNQUFNVSxrQkFBa0JYLDZDQUFNQSxDQUFNO0lBQ3BDLE1BQU1ZLG1CQUFtQlosNkNBQU1BLENBQWdCO0lBRS9DRCxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ1Esa0JBQWtCTSxPQUFPLEVBQUU7UUFFaEMsTUFBTUMsZUFBZTtZQUNuQkMsUUFBUTtnQkFDTkMsWUFBWTtvQkFBRUMsT0FBTztnQkFBVTtnQkFDL0JDLFdBQVc7WUFDYjtZQUNBQyxNQUFNO2dCQUNKQyxXQUFXO29CQUFFSCxPQUFPO2dCQUFVO2dCQUM5QkksV0FBVztvQkFBRUosT0FBTztnQkFBVTtZQUNoQztZQUNBSyxXQUFXO2dCQUNUQyxNQUFNO2dCQUNOQyxVQUFVO29CQUNSQyxPQUFPO29CQUNQUixPQUFPO29CQUNQUyxPQUFPO2dCQUNUO2dCQUNBQyxVQUFVO29CQUNSRixPQUFPO29CQUNQUixPQUFPO29CQUNQUyxPQUFPO2dCQUNUO1lBQ0Y7WUFDQUUsV0FBVztnQkFDVEMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsZ0JBQWdCO2dCQUNoQkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsWUFBWTtnQkFDWkMsZUFBZTtnQkFDZkMsdUJBQXVCO2dCQUN2QkMsOEJBQThCO2dCQUM5QkMsbUJBQW1CLENBQUNDO29CQUNsQixNQUFNQyxPQUFPLElBQUlDLEtBQUtGLE9BQU87b0JBQzdCLElBQUlqQyxj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QU8sQ0FBQ2lELFdBQVc7b0JBQzVDQyxRQUFReEQsa0JBQWtCTSxPQUFPLENBQUNtRCxZQUFZO2dCQUNoRDtZQUNGO1FBQ0Y7UUFFQXdELE9BQU9DLGdCQUFnQixDQUFDLFVBQVVIO1FBRWxDLE9BQU87WUFDTEUsT0FBT0UsbUJBQW1CLENBQUMsVUFBVUo7WUFDckMsSUFBSTlHLFNBQVNLLE9BQU8sRUFBRTtnQkFDcEJMLFNBQVNLLE9BQU8sQ0FBQzhHLE1BQU07WUFDekI7WUFDQWxCO1FBQ0Y7SUFDRixHQUFHO1FBQUNuRztLQUFVO0lBRWQscUJBQ0UsOERBQUNzSDtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlFLEtBQUt2SDtnQkFBbUJzSCxXQUFVOzs7Ozs7WUFDdENwSCw4QkFDQyw4REFBQ21IO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNFOzRCQUFLRixXQUFVO3NDQUFnQjs7Ozs7O3NDQUNoQyw4REFBQ0U7NEJBQUtGLFdBQVU7O2dDQUFvQztnQ0FBRXBIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNbEU7R0FoUWdCSjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0LCBDb2xvclR5cGUsIElDaGFydEFwaSwgTGluZVdpZHRoLCBVVENUaW1lc3RhbXAsIFNlcmllc1R5cGUgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9QcmljZSwgc3Vic2NyaWJlVG9UcmFkZXMsIGdldEhpc3RvcmljYWxEYXRhLCBUaW1lZnJhbWUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSSc7XG5cbmludGVyZmFjZSBDYW5kbGUge1xuICB0aW1lOiBVVENUaW1lc3RhbXA7XG4gIG9wZW46IG51bWJlcjtcbiAgaGlnaDogbnVtYmVyO1xuICBsb3c6IG51bWJlcjtcbiAgY2xvc2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhbmRsZXN0aWNrQ2hhcnQoeyB0aW1lZnJhbWUgfTogQ2FuZGxlc3RpY2tDaGFydFByb3BzKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50UHJpY2UsIHNldEN1cnJlbnRQcmljZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcbiAgY29uc3QgY2FuZGxlU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRDYW5kbGVSZWYgPSB1c2VSZWY8Q2FuZGxlIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IGNoYXJ0T3B0aW9ucyA9IHtcbiAgICAgIGxheW91dDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzFFMjIyRCcgfSxcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXG4gICAgICB9LFxuICAgICAgZ3JpZDoge1xuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgICBob3J6TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgfSxcbiAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBtb2RlOiAxLFxuICAgICAgICB2ZXJ0TGluZToge1xuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxuICAgICAgICAgIHN0eWxlOiAzLFxuICAgICAgICB9LFxuICAgICAgICBob3J6TGluZToge1xuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxuICAgICAgICAgIHN0eWxlOiAzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRpbWVTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgc2Vjb25kc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICBmaXhMZWZ0RWRnZTogdHJ1ZSxcbiAgICAgICAgcmlnaHRPZmZzZXQ6IDEyLFxuICAgICAgICBiYXJTcGFjaW5nOiA2LFxuICAgICAgICBtaW5CYXJTcGFjaW5nOiAyLFxuICAgICAgICByaWdodEJhclN0YXlzT25TY3JvbGw6IHRydWUsXG4gICAgICAgIGxvY2tWaXNpYmxlVGltZVJhbmdlT25SZXNpemU6IHRydWUsXG4gICAgICAgIHRpY2tNYXJrRm9ybWF0dGVyOiAodGltZTogVVRDVGltZXN0YW1wKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgICAgICAgICBpZiAodGltZWZyYW1lID09PSAnMWQnIHx8IHRpbWVmcmFtZSA9PT0gJzF3Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlVGltZVN0cmluZyhbXSwgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICBhdXRvU2NhbGU6IHRydWUsXG4gICAgICAgIHNjYWxlTWFyZ2luczoge1xuICAgICAgICAgIHRvcDogMC4yLFxuICAgICAgICAgIGJvdHRvbTogMC4yLFxuICAgICAgICB9LFxuICAgICAgICBlbnRpcmVUZXh0T25seTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBoYW5kbGVTY2FsZToge1xuICAgICAgICBheGlzUHJlc3NlZE1vdXNlTW92ZToge1xuICAgICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgICAgcHJpY2U6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgIHBpbmNoOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIGhhbmRsZVNjcm9sbDoge1xuICAgICAgICBtb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgICBwcmVzc2VkTW91c2VNb3ZlOiB0cnVlLFxuICAgICAgICBob3J6VG91Y2hEcmFnOiB0cnVlLFxuICAgICAgICB2ZXJ0VG91Y2hEcmFnOiB0cnVlLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCB7XG4gICAgICAuLi5jaGFydE9wdGlvbnMsXG4gICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYW5kbGVzdGlja1NlcmllcyA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHtcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgYm9yZGVyVmlzaWJsZTogZmFsc2UsXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgcHJlY2lzaW9uOiAyLFxuICAgICAgICBtaW5Nb3ZlOiAwLjAxLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBcbiAgICBjYW5kbGVTZXJpZXNSZWYuY3VycmVudCA9IGNhbmRsZXN0aWNrU2VyaWVzO1xuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcblxuICAgIC8vIEZldGNoIGhpc3RvcmljYWwgZGF0YSBmaXJzdFxuICAgIGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSkudGhlbihkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNhbmRsZXMgPSBkYXRhLm1hcCgoZDogYW55KSA9PiAoe1xuICAgICAgICAgIHRpbWU6IGQudGltZSBhcyBVVENUaW1lc3RhbXAsXG4gICAgICAgICAgb3BlbjogZC5vcGVuLFxuICAgICAgICAgIGhpZ2g6IGQuaGlnaCxcbiAgICAgICAgICBsb3c6IGQubG93LFxuICAgICAgICAgIGNsb3NlOiBkLmNsb3NlLFxuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5zZXREYXRhKGNhbmRsZXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBjdXJyZW50IGNhbmRsZVxuICAgICAgICBjb25zdCBsYXN0Q2FuZGxlID0gY2FuZGxlc1tjYW5kbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRpbWVmcmFtZSA9PT0gJzF3JyA/IDYwNDgwMCA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnMWQnID8gODY0MDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnNGgnID8gMTQ0MDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnMWgnID8gMzYwMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lZnJhbWUgPT09ICczMG0nID8gMTgwMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lZnJhbWUgPT09ICcxNW0nID8gOTAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzVtJyA/IDMwMCA6IDYwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbnRlcnZhbCA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCBhcyBVVENUaW1lc3RhbXA7XG4gICAgICAgIFxuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgdGltZTogY3VycmVudEludGVydmFsLFxuICAgICAgICAgIG9wZW46IGxhc3RDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgaGlnaDogbGFzdENhbmRsZS5jbG9zZSxcbiAgICAgICAgICBsb3c6IGxhc3RDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgY2xvc2U6IGxhc3RDYW5kbGUuY2xvc2UsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdmlzaWJsZSByYW5nZSBiYXNlZCBvbiB0aW1lZnJhbWVcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gY2hhcnQudGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGltZWZyYW1lID09PSAnMXcnID8gNTIgOiAvLyAxIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzFkJyA/IDkwIDogLy8gMyBtb250aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzRoJyA/IDE4MCA6IC8vIDMwIGRheXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzFoJyA/IDE2OCA6IC8vIDEgd2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgMjQwOyAvLyA0IGhvdXJzIGZvciBzbWFsbGVyIHRpbWVmcmFtZXNcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IGludGVydmFsICogdmlzaWJsZUJhcnM7XG4gICAgICAgIGNvbnN0IGZyb21UaW1lID0gY3VycmVudFRpbWUgLSB0aW1lUmFuZ2U7XG4gICAgICAgIGNvbnN0IHRvVGltZSA9IGN1cnJlbnRUaW1lICsgaW50ZXJ2YWwgKiAyO1xuICAgICAgICBcbiAgICAgICAgdGltZVNjYWxlLnNldFZpc2libGVSYW5nZSh7XG4gICAgICAgICAgZnJvbTogZnJvbVRpbWUgYXMgVVRDVGltZXN0YW1wLFxuICAgICAgICAgIHRvOiB0b1RpbWUgYXMgVVRDVGltZXN0YW1wLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aW1lU2NhbGUuZml0Q29udGVudCgpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlYWwtdGltZSBwcmljZSB1cGRhdGVzXG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcmljZSA9IHN1YnNjcmliZVRvUHJpY2UoKHsgdGltZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgcHJpY2UgZGlzcGxheSBpbW1lZGlhdGVseVxuICAgICAgc2V0Q3VycmVudFByaWNlKHZhbHVlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHtcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJcbiAgICAgIH0pKTtcblxuICAgICAgLy8gVXBkYXRlIG9yIGNyZWF0ZSBuZXcgY2FuZGxlXG4gICAgICBpZiAoIWN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRpbWVmcmFtZSA9PT0gJzF3JyA/IDYwNDgwMCA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnMWQnID8gODY0MDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnNGgnID8gMTQ0MDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnMWgnID8gMzYwMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lZnJhbWUgPT09ICczMG0nID8gMTgwMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lZnJhbWUgPT09ICcxNW0nID8gOTAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzVtJyA/IDMwMCA6IDYwO1xuICAgICAgICBjb25zdCBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLmZsb29yKHRpbWUgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCBhcyBVVENUaW1lc3RhbXA7XG4gICAgICAgIFxuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgdGltZTogY3VycmVudEludGVydmFsLFxuICAgICAgICAgIG9wZW46IHZhbHVlLFxuICAgICAgICAgIGhpZ2g6IHZhbHVlLFxuICAgICAgICAgIGxvdzogdmFsdWUsXG4gICAgICAgICAgY2xvc2U6IHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aW1lZnJhbWUgPT09ICcxdycgPyA2MDQ4MDAgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzFkJyA/IDg2NDAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzRoJyA/IDE0NDAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVmcmFtZSA9PT0gJzFoJyA/IDM2MDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnMzBtJyA/IDE4MDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWZyYW1lID09PSAnMTVtJyA/IDkwMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lZnJhbWUgPT09ICc1bScgPyAzMDAgOiA2MDtcbiAgICAgICAgY29uc3QgY3VycmVudEludGVydmFsID0gTWF0aC5mbG9vcih0aW1lIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwgYXMgVVRDVGltZXN0YW1wO1xuICAgICAgICBjb25zdCBjYW5kbGVJbnRlcnZhbCA9IE1hdGguZmxvb3IoY3VycmVudENhbmRsZVJlZi5jdXJyZW50LnRpbWUgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbDtcbiAgICAgICAgXG4gICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgPiBjYW5kbGVJbnRlcnZhbCkge1xuICAgICAgICAgIC8vIFNhdmUgdGhlIGNvbXBsZXRlZCBjYW5kbGVcbiAgICAgICAgICBjb25zdCBjb21wbGV0ZWRDYW5kbGUgPSB7IC4uLmN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCB9O1xuICAgICAgICAgIGNhbmRsZVNlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjb21wbGV0ZWRDYW5kbGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgY2FuZGxlXG4gICAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgdGltZTogY3VycmVudEludGVydmFsLFxuICAgICAgICAgICAgb3BlbjogdmFsdWUsXG4gICAgICAgICAgICBoaWdoOiB2YWx1ZSxcbiAgICAgICAgICAgIGxvdzogdmFsdWUsXG4gICAgICAgICAgICBjbG9zZTogdmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBjYW5kbGVcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQuaGlnaCA9IE1hdGgubWF4KGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5oaWdoLCB2YWx1ZSk7XG4gICAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmxvdyA9IE1hdGgubWluKGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5sb3csIHZhbHVlKTtcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQuY2xvc2UgPSB2YWx1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNhbmRsZXN0aWNrIGltbWVkaWF0ZWx5XG4gICAgICAgICAgY2FuZGxlU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXV0by1zY3JvbGwgaWYgd2UncmUgYXQgdGhlIHJpZ2h0IGVkZ2VcbiAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IGNoYXJ0UmVmLmN1cnJlbnQ/LnRpbWVTY2FsZSgpO1xuICAgICAgaWYgKHRpbWVTY2FsZSkge1xuICAgICAgICBjb25zdCBsb2dpY2FsUmFuZ2UgPSB0aW1lU2NhbGUuZ2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSgpO1xuICAgICAgICBpZiAobG9naWNhbFJhbmdlICYmIGxvZ2ljYWxSYW5nZS50byA+PSAoY3VycmVudENhbmRsZVJlZi5jdXJyZW50LnRpbWUgYXMgbnVtYmVyKSAtIDUpIHtcbiAgICAgICAgICB0aW1lU2NhbGUuc2Nyb2xsVG9Qb3NpdGlvbigxLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aW1lZnJhbWUpO1xuXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LmFwcGx5T3B0aW9ucyh7XG4gICAgICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHVuc3Vic2NyaWJlUHJpY2UoKTtcbiAgICB9O1xuICB9LCBbdGltZWZyYW1lXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIHctZnVsbCBoLWZ1bGxcIj5cbiAgICAgIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiIC8+XG4gICAgICB7Y3VycmVudFByaWNlICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtNCBsZWZ0LTQgYmctWyMyQjJCNDNdIHB4LTQgcHktMiByb3VuZGVkLWxnIHNoYWRvdy1sZ1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDBcIj5CVEMvVVNEPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlXCI+JHtjdXJyZW50UHJpY2V9PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiY3JlYXRlQ2hhcnQiLCJzdWJzY3JpYmVUb1ByaWNlIiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJDYW5kbGVzdGlja0NoYXJ0IiwidGltZWZyYW1lIiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImN1cnJlbnRQcmljZSIsInNldEN1cnJlbnRQcmljZSIsImNhbmRsZVNlcmllc1JlZiIsImN1cnJlbnRDYW5kbGVSZWYiLCJjdXJyZW50IiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsImNvbG9yIiwidGV4dENvbG9yIiwiZ3JpZCIsInZlcnRMaW5lcyIsImhvcnpMaW5lcyIsImNyb3NzaGFpciIsIm1vZGUiLCJ2ZXJ0TGluZSIsIndpZHRoIiwic3R5bGUiLCJob3J6TGluZSIsInRpbWVTY2FsZSIsImJvcmRlckNvbG9yIiwidGltZVZpc2libGUiLCJzZWNvbmRzVmlzaWJsZSIsImZpeExlZnRFZGdlIiwicmlnaHRPZmZzZXQiLCJiYXJTcGFjaW5nIiwibWluQmFyU3BhY2luZyIsInJpZ2h0QmFyU3RheXNPblNjcm9sbCIsImxvY2tWaXNpYmxlVGltZVJhbmdlT25SZXNpemUiLCJ0aWNrTWFya0Zvcm1hdHRlciIsInRpbWUiLCJkYXRlIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiLCJyaWdodFByaWNlU2NhbGUiLCJhdXRvU2NhbGUiLCJzY2FsZU1hcmdpbnMiLCJ0b3AiLCJib3R0b20iLCJlbnRpcmVUZXh0T25seSIsImhhbmRsZVNjYWxlIiwiYXhpc1ByZXNzZWRNb3VzZU1vdmUiLCJwcmljZSIsIm1vdXNlV2hlZWwiLCJwaW5jaCIsImhhbmRsZVNjcm9sbCIsInByZXNzZWRNb3VzZU1vdmUiLCJob3J6VG91Y2hEcmFnIiwidmVydFRvdWNoRHJhZyIsImNoYXJ0IiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJwcmljZUZvcm1hdCIsInR5cGUiLCJwcmVjaXNpb24iLCJtaW5Nb3ZlIiwidGhlbiIsImRhdGEiLCJjYW5kbGVzIiwibWFwIiwiZCIsIm9wZW4iLCJoaWdoIiwibG93IiwiY2xvc2UiLCJzZXREYXRhIiwibGFzdENhbmRsZSIsImxlbmd0aCIsImN1cnJlbnRUaW1lIiwiTWF0aCIsImZsb29yIiwibm93IiwiaW50ZXJ2YWwiLCJjdXJyZW50SW50ZXJ2YWwiLCJ2aXNpYmxlQmFycyIsInRpbWVSYW5nZSIsImZyb21UaW1lIiwidG9UaW1lIiwic2V0VmlzaWJsZVJhbmdlIiwiZnJvbSIsInRvIiwiZml0Q29udGVudCIsImNhdGNoIiwiY29uc29sZSIsImVycm9yIiwidW5zdWJzY3JpYmVQcmljZSIsInZhbHVlIiwidG9Mb2NhbGVTdHJpbmciLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJjYW5kbGVJbnRlcnZhbCIsImNvbXBsZXRlZENhbmRsZSIsInVwZGF0ZSIsIm1heCIsIm1pbiIsImxvZ2ljYWxSYW5nZSIsImdldFZpc2libGVMb2dpY2FsUmFuZ2UiLCJzY3JvbGxUb1Bvc2l0aW9uIiwiaGFuZGxlUmVzaXplIiwiYXBwbHlPcHRpb25zIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmUiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiLCJzcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts":
/*!**********************************************!*\
  !*** ./src/services/api/cryptoCompareAPI.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentPrice: function() { return /* binding */ getCurrentPrice; },\n/* harmony export */   getHistoricalData: function() { return /* binding */ getHistoricalData; },\n/* harmony export */   subscribeToPrice: function() { return /* binding */ subscribeToPrice; },\n/* harmony export */   subscribeToTrades: function() { return /* binding */ subscribeToTrades; }\n/* harmony export */ });\nconst TIMEFRAME_CONFIG = {\n    \"1m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 60\n    },\n    \"5m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 300\n    },\n    \"15m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 900\n    },\n    \"30m\": {\n        endpoint: \"histominute\",\n        limit: 1440,\n        interval: 1800\n    },\n    \"1h\": {\n        endpoint: \"histohour\",\n        limit: 720,\n        interval: 3600\n    },\n    \"4h\": {\n        endpoint: \"histohour\",\n        limit: 720,\n        interval: 14400\n    },\n    \"1d\": {\n        endpoint: \"histoday\",\n        limit: 365,\n        interval: 86400\n    },\n    \"1w\": {\n        endpoint: \"histoday\",\n        limit: 365,\n        interval: 604800\n    }\n};\nlet socket = null;\nlet priceUpdateCallbacks = [];\nlet tradeUpdateCallbacks = [];\nlet pendingSubscription = false;\nlet lastPrice = 0;\nlet reconnectAttempts = 0;\nlet currentTimeframe = \"1m\";\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 2000;\n// Fallback to REST API when WebSocket fails\nasync function fetchPriceUpdate() {\n    try {\n        const response = await fetch(\"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\");\n        const data = await response.json();\n        const price = data.USD;\n        const timestamp = Math.floor(Date.now() / 1000);\n        if (price && !isNaN(price) && price !== lastPrice) {\n            lastPrice = price;\n            priceUpdateCallbacks.forEach((callback)=>callback({\n                    time: timestamp,\n                    value: price\n                }));\n        }\n    } catch (error) {\n        console.error(\"Error fetching price via REST:\", error);\n    }\n}\nfunction sendSubscription(ws) {\n    const subscribeMsg = {\n        \"action\": \"SubAdd\",\n        \"subs\": [\n            \"5~CCCAGG~BTC~USD\",\n            \"2~Coinbase~BTC~USD\",\n            \"11~BTC~USD\" // Direct price feed\n        ]\n    };\n    try {\n        ws.send(JSON.stringify(subscribeMsg));\n        console.log(\"Subscribed to price feeds\");\n        pendingSubscription = false;\n    } catch (error) {\n        console.error(\"Error sending subscription:\", error);\n        pendingSubscription = true;\n    }\n}\n// Update the WebSocket message handler to respect timeframes\nfunction handlePriceUpdate(price, timestamp, timeframe) {\n    const config = TIMEFRAME_CONFIG[timeframe];\n    const interval = config.interval;\n    // Align timestamp to the current timeframe interval\n    const alignedTimestamp = Math.floor(timestamp / interval) * interval;\n    if (price && !isNaN(price) && price !== lastPrice) {\n        lastPrice = price;\n        priceUpdateCallbacks.forEach((callback)=>callback({\n                time: alignedTimestamp,\n                value: price\n            }));\n        if (tradeUpdateCallbacks.length > 0) {\n            tradeUpdateCallbacks.forEach((callback)=>callback({\n                    time: alignedTimestamp,\n                    price: price,\n                    volume24h: 0 // Volume will be updated separately\n                }));\n        }\n    }\n}\nfunction connectWebSocket() {\n    if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n        if (pendingSubscription) {\n            sendSubscription(socket);\n        }\n        return;\n    }\n    // Don't try to reconnect too many times\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n        console.log(\"Max reconnection attempts reached, falling back to REST API\");\n        // Set up periodic REST API polling as fallback\n        const pollInterval = setInterval(fetchPriceUpdate, 5000);\n        return;\n    }\n    try {\n        // Close existing socket if any\n        if (socket) {\n            socket.close();\n            socket = null;\n        }\n        socket = new WebSocket(\"wss://streamer.cryptocompare.com/v2\");\n        socket.onopen = ()=>{\n            console.log(\"Connected to CryptoCompare WebSocket\");\n            reconnectAttempts = 0; // Reset attempts on successful connection\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                sendSubscription(socket);\n            } else {\n                pendingSubscription = true;\n            }\n        };\n        socket.onmessage = (event)=>{\n            try {\n                const data = JSON.parse(event.data);\n                if (data.TYPE === \"20\" && data.MESSAGE === \"SUBSCRIBECOMPLETE\") {\n                    console.log(\"Successfully subscribed to feeds\");\n                    return;\n                }\n                const timestamp = Math.floor(Date.now() / 1000);\n                let price = null;\n                if (data.TYPE === \"11\" || data.TYPE === \"2\" || data.TYPE === \"5\") {\n                    price = parseFloat(data.PRICE);\n                    if (price && !isNaN(price)) {\n                        handlePriceUpdate(price, timestamp, currentTimeframe);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error processing message:\", error);\n            }\n        };\n        socket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            reconnectAttempts++;\n            reconnect();\n        };\n        socket.onclose = (event)=>{\n            console.log(\"WebSocket closed with code \".concat(event.code, \", reason: \").concat(event.reason));\n            reconnect();\n        };\n        // Ping every 15 seconds to keep connection alive\n        const pingInterval = setInterval(()=>{\n            if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n                try {\n                    socket.send(JSON.stringify({\n                        \"action\": \"PING\"\n                    }));\n                } catch (error) {\n                    console.error(\"Error sending ping:\", error);\n                    reconnect();\n                }\n            }\n        }, 15000);\n        // Clean up ping interval on socket close\n        socket.addEventListener(\"close\", ()=>clearInterval(pingInterval));\n    } catch (error) {\n        console.error(\"Error creating WebSocket:\", error);\n        reconnectAttempts++;\n        setTimeout(connectWebSocket, RECONNECT_DELAY);\n    }\n}\nfunction reconnect() {\n    if (socket) {\n        try {\n            socket.close();\n        } catch (error) {\n            console.error(\"Error closing socket:\", error);\n        }\n        socket = null;\n    }\n    setTimeout(connectWebSocket, RECONNECT_DELAY * Math.min(reconnectAttempts, 5));\n}\nfunction subscribeToPrice(callback) {\n    let timeframe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"1m\";\n    currentTimeframe = timeframe;\n    priceUpdateCallbacks.push(callback);\n    // Immediately get current price via REST API\n    getCurrentPrice().then((price)=>{\n        const timestamp = Math.floor(Date.now() / 1000);\n        callback({\n            time: timestamp,\n            value: price\n        });\n    }).catch(console.error);\n    // If this is the first subscriber, connect to WebSocket\n    if (priceUpdateCallbacks.length === 1) {\n        connectWebSocket();\n    }\n    return ()=>{\n        priceUpdateCallbacks = priceUpdateCallbacks.filter((cb)=>cb !== callback);\n        if (priceUpdateCallbacks.length === 0 && tradeUpdateCallbacks.length === 0 && socket) {\n            socket.close();\n            socket = null;\n        }\n    };\n}\nfunction subscribeToTrades(callback) {\n    tradeUpdateCallbacks.push(callback);\n    // If this is the first subscriber, connect to WebSocket\n    if (tradeUpdateCallbacks.length === 1 && priceUpdateCallbacks.length === 0) {\n        connectWebSocket();\n    }\n    return ()=>{\n        tradeUpdateCallbacks = tradeUpdateCallbacks.filter((cb)=>cb !== callback);\n        if (priceUpdateCallbacks.length === 0 && tradeUpdateCallbacks.length === 0 && socket) {\n            socket.close();\n            socket = null;\n        }\n    };\n}\nasync function getCurrentPrice() {\n    try {\n        const response = await fetch(\"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\");\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.USD;\n    } catch (error) {\n        console.error(\"Error fetching price:\", error);\n        throw error;\n    }\n}\nasync function getHistoricalData() {\n    let timeframe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1m\";\n    try {\n        var _data_Data;\n        const config = TIMEFRAME_CONFIG[timeframe];\n        const endTime = Math.floor(Date.now() / 1000);\n        // Calculate the appropriate aggregate parameter based on timeframe\n        let aggregate = 1;\n        if (config.endpoint === \"histominute\") {\n            aggregate = config.interval / 60;\n        } else if (config.endpoint === \"histohour\") {\n            aggregate = config.interval / 3600;\n        } else if (config.endpoint === \"histoday\") {\n            aggregate = config.interval / 86400;\n        }\n        const url = \"https://min-api.cryptocompare.com/data/v2/\".concat(config.endpoint, \"?fsym=BTC&tsym=USD&limit=\").concat(config.limit, \"&toTs=\").concat(endTime, \"&aggregate=\").concat(aggregate);\n        console.log(\"Fetching historical data for \".concat(timeframe, \" timeframe...\"));\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!((_data_Data = data.Data) === null || _data_Data === void 0 ? void 0 : _data_Data.Data)) {\n            throw new Error(\"Invalid data format received from API\");\n        }\n        return data.Data.Data;\n    } catch (error) {\n        console.error(\"Error fetching historical data:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBcUJBLE1BQU1BLG1CQUF1RDtJQUMzRCxNQUFNO1FBQUVDLFVBQVU7UUFBZUMsT0FBTztRQUFNQyxVQUFVO0lBQUc7SUFDM0QsTUFBTTtRQUFFRixVQUFVO1FBQWVDLE9BQU87UUFBTUMsVUFBVTtJQUFJO0lBQzVELE9BQU87UUFBRUYsVUFBVTtRQUFlQyxPQUFPO1FBQU1DLFVBQVU7SUFBSTtJQUM3RCxPQUFPO1FBQUVGLFVBQVU7UUFBZUMsT0FBTztRQUFNQyxVQUFVO0lBQUs7SUFDOUQsTUFBTTtRQUFFRixVQUFVO1FBQWFDLE9BQU87UUFBS0MsVUFBVTtJQUFLO0lBQzFELE1BQU07UUFBRUYsVUFBVTtRQUFhQyxPQUFPO1FBQUtDLFVBQVU7SUFBTTtJQUMzRCxNQUFNO1FBQUVGLFVBQVU7UUFBWUMsT0FBTztRQUFLQyxVQUFVO0lBQU07SUFDMUQsTUFBTTtRQUFFRixVQUFVO1FBQVlDLE9BQU87UUFBS0MsVUFBVTtJQUFPO0FBQzdEO0FBRUEsSUFBSUMsU0FBMkI7QUFDL0IsSUFBSUMsdUJBQXNELEVBQUU7QUFDNUQsSUFBSUMsdUJBQXNELEVBQUU7QUFDNUQsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLG1CQUE4QjtBQUNsQyxNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMsa0JBQWtCO0FBRXhCLDRDQUE0QztBQUM1QyxlQUFlQztJQUNiLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU07UUFDN0IsTUFBTUMsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1FBQ2hDLE1BQU1DLFFBQVFGLEtBQUtHLEdBQUc7UUFDdEIsTUFBTUMsWUFBWUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7UUFFMUMsSUFBSU4sU0FBUyxDQUFDTyxNQUFNUCxV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aEIsTUFBTSxJQUFJQyxNQUFNLHVCQUF1QyxPQUFoQmpFLFNBQVNrRSxNQUFNO1FBQ3hEO1FBRUEsTUFBTWhFLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtRQUNoQyxJQUFJLEdBQUNELGFBQUFBLEtBQUtxRSxJQUFJLGNBQVRyRSxpQ0FBQUEsV0FBV3FFLElBQUksR0FBRTtZQUNwQixNQUFNLElBQUlOLE1BQU07UUFDbEI7UUFFQSxPQUFPL0QsS0FBS3FFLElBQUksQ0FBQ0EsSUFBSTtJQUN2QixFQUFFLE9BQU92RCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEkudHM/NTNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUaW1lLCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuXG5pbnRlcmZhY2UgUHJpY2VEYXRhIHtcbiAgdGltZTogVVRDVGltZXN0YW1wO1xuICB2YWx1ZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVHJhZGVEYXRhIHtcbiAgdGltZTogVVRDVGltZXN0YW1wO1xuICBwcmljZTogbnVtYmVyO1xuICB2b2x1bWUyNGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgVGltZWZyYW1lQ29uZmlnID0ge1xuICBlbmRwb2ludDogc3RyaW5nO1xuICBsaW1pdDogbnVtYmVyO1xuICBpbnRlcnZhbDogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBUaW1lZnJhbWUgPSAnMW0nIHwgJzVtJyB8ICcxNW0nIHwgJzMwbScgfCAnMWgnIHwgJzRoJyB8ICcxZCcgfCAnMXcnO1xuXG5jb25zdCBUSU1FRlJBTUVfQ09ORklHOiBSZWNvcmQ8VGltZWZyYW1lLCBUaW1lZnJhbWVDb25maWc+ID0ge1xuICAnMW0nOiB7IGVuZHBvaW50OiAnaGlzdG9taW51dGUnLCBsaW1pdDogMTQ0MCwgaW50ZXJ2YWw6IDYwIH0sXG4gICc1bSc6IHsgZW5kcG9pbnQ6ICdoaXN0b21pbnV0ZScsIGxpbWl0OiAxNDQwLCBpbnRlcnZhbDogMzAwIH0sXG4gICcxNW0nOiB7IGVuZHBvaW50OiAnaGlzdG9taW51dGUnLCBsaW1pdDogMTQ0MCwgaW50ZXJ2YWw6IDkwMCB9LFxuICAnMzBtJzogeyBlbmRwb2ludDogJ2hpc3RvbWludXRlJywgbGltaXQ6IDE0NDAsIGludGVydmFsOiAxODAwIH0sXG4gICcxaCc6IHsgZW5kcG9pbnQ6ICdoaXN0b2hvdXInLCBsaW1pdDogNzIwLCBpbnRlcnZhbDogMzYwMCB9LFxuICAnNGgnOiB7IGVuZHBvaW50OiAnaGlzdG9ob3VyJywgbGltaXQ6IDcyMCwgaW50ZXJ2YWw6IDE0NDAwIH0sXG4gICcxZCc6IHsgZW5kcG9pbnQ6ICdoaXN0b2RheScsIGxpbWl0OiAzNjUsIGludGVydmFsOiA4NjQwMCB9LFxuICAnMXcnOiB7IGVuZHBvaW50OiAnaGlzdG9kYXknLCBsaW1pdDogMzY1LCBpbnRlcnZhbDogNjA0ODAwIH1cbn07XG5cbmxldCBzb2NrZXQ6IFdlYlNvY2tldCB8IG51bGwgPSBudWxsO1xubGV0IHByaWNlVXBkYXRlQ2FsbGJhY2tzOiAoKGRhdGE6IFByaWNlRGF0YSkgPT4gdm9pZClbXSA9IFtdO1xubGV0IHRyYWRlVXBkYXRlQ2FsbGJhY2tzOiAoKGRhdGE6IFRyYWRlRGF0YSkgPT4gdm9pZClbXSA9IFtdO1xubGV0IHBlbmRpbmdTdWJzY3JpcHRpb24gPSBmYWxzZTtcbmxldCBsYXN0UHJpY2UgPSAwO1xubGV0IHJlY29ubmVjdEF0dGVtcHRzID0gMDtcbmxldCBjdXJyZW50VGltZWZyYW1lOiBUaW1lZnJhbWUgPSAnMW0nO1xuY29uc3QgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDU7XG5jb25zdCBSRUNPTk5FQ1RfREVMQVkgPSAyMDAwO1xuXG4vLyBGYWxsYmFjayB0byBSRVNUIEFQSSB3aGVuIFdlYlNvY2tldCBmYWlsc1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcmljZVVwZGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUJUQyZ0c3ltcz1VU0QnKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IHByaWNlID0gZGF0YS5VU0Q7XG4gICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgYXMgVVRDVGltZXN0YW1wO1xuXG4gICAgaWYgKHByaWNlICYmICFpc05hTihwcmljZSkgJiYgcHJpY2UgIT09IGxhc3RQcmljZSkge1xuICAgICAgbGFzdFByaWNlID0gcHJpY2U7XG4gICAgICBwcmljZVVwZGF0ZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHtcbiAgICAgICAgdGltZTogdGltZXN0YW1wLFxuICAgICAgICB2YWx1ZTogcHJpY2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJpY2UgdmlhIFJFU1Q6JywgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRTdWJzY3JpcHRpb24od3M6IFdlYlNvY2tldCkge1xuICBjb25zdCBzdWJzY3JpYmVNc2cgPSB7XG4gICAgXCJhY3Rpb25cIjogXCJTdWJBZGRcIixcbiAgICBcInN1YnNcIjogW1xuICAgICAgXCI1fkNDQ0FHR35CVEN+VVNEXCIsICAgICAgIC8vIEFnZ3JlZ2F0ZSBpbmRleCAobW9zdCBmcmVxdWVudClcbiAgICAgIFwiMn5Db2luYmFzZX5CVEN+VVNEXCIsICAgICAvLyBDb2luYmFzZSB0aWNrZXJcbiAgICAgIFwiMTF+QlRDflVTRFwiICAgICAgICAgICAgICAvLyBEaXJlY3QgcHJpY2UgZmVlZFxuICAgIF1cbiAgfTtcbiAgXG4gIHRyeSB7XG4gICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeShzdWJzY3JpYmVNc2cpKTtcbiAgICBjb25zb2xlLmxvZygnU3Vic2NyaWJlZCB0byBwcmljZSBmZWVkcycpO1xuICAgIHBlbmRpbmdTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIHN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgcGVuZGluZ1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gIH1cbn1cblxuLy8gVXBkYXRlIHRoZSBXZWJTb2NrZXQgbWVzc2FnZSBoYW5kbGVyIHRvIHJlc3BlY3QgdGltZWZyYW1lc1xuZnVuY3Rpb24gaGFuZGxlUHJpY2VVcGRhdGUocHJpY2U6IG51bWJlciwgdGltZXN0YW1wOiBVVENUaW1lc3RhbXAsIHRpbWVmcmFtZTogVGltZWZyYW1lKSB7XG4gIGNvbnN0IGNvbmZpZyA9IFRJTUVGUkFNRV9DT05GSUdbdGltZWZyYW1lXTtcbiAgY29uc3QgaW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWw7XG4gIFxuICAvLyBBbGlnbiB0aW1lc3RhbXAgdG8gdGhlIGN1cnJlbnQgdGltZWZyYW1lIGludGVydmFsXG4gIGNvbnN0IGFsaWduZWRUaW1lc3RhbXAgPSBNYXRoLmZsb29yKHRpbWVzdGFtcCAvIGludGVydmFsKSAqIGludGVydmFsIGFzIFVUQ1RpbWVzdGFtcDtcbiAgXG4gIGlmIChwcmljZSAmJiAhaXNOYU4ocHJpY2UpICYmIHByaWNlICE9PSBsYXN0UHJpY2UpIHtcbiAgICBsYXN0UHJpY2UgPSBwcmljZTtcbiAgICBcbiAgICBwcmljZVVwZGF0ZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHtcbiAgICAgIHRpbWU6IGFsaWduZWRUaW1lc3RhbXAsXG4gICAgICB2YWx1ZTogcHJpY2VcbiAgICB9KSk7XG5cbiAgICBpZiAodHJhZGVVcGRhdGVDYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgdHJhZGVVcGRhdGVDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh7XG4gICAgICAgIHRpbWU6IGFsaWduZWRUaW1lc3RhbXAsXG4gICAgICAgIHByaWNlOiBwcmljZSxcbiAgICAgICAgdm9sdW1lMjRoOiAwIC8vIFZvbHVtZSB3aWxsIGJlIHVwZGF0ZWQgc2VwYXJhdGVseVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25uZWN0V2ViU29ja2V0KCkge1xuICBpZiAoc29ja2V0Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgIGlmIChwZW5kaW5nU3Vic2NyaXB0aW9uKSB7XG4gICAgICBzZW5kU3Vic2NyaXB0aW9uKHNvY2tldCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERvbid0IHRyeSB0byByZWNvbm5lY3QgdG9vIG1hbnkgdGltZXNcbiAgaWYgKHJlY29ubmVjdEF0dGVtcHRzID49IE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMpIHtcbiAgICBjb25zb2xlLmxvZygnTWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyByZWFjaGVkLCBmYWxsaW5nIGJhY2sgdG8gUkVTVCBBUEknKTtcbiAgICAvLyBTZXQgdXAgcGVyaW9kaWMgUkVTVCBBUEkgcG9sbGluZyBhcyBmYWxsYmFja1xuICAgIGNvbnN0IHBvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZldGNoUHJpY2VVcGRhdGUsIDUwMDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gQ2xvc2UgZXhpc3Rpbmcgc29ja2V0IGlmIGFueVxuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KCd3c3M6Ly9zdHJlYW1lci5jcnlwdG9jb21wYXJlLmNvbS92MicpO1xuXG4gICAgc29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gQ3J5cHRvQ29tcGFyZSBXZWJTb2NrZXQnKTtcbiAgICAgIHJlY29ubmVjdEF0dGVtcHRzID0gMDsgLy8gUmVzZXQgYXR0ZW1wdHMgb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBzZW5kU3Vic2NyaXB0aW9uKHNvY2tldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc29ja2V0Lm9ubWVzc2FnZSA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhLlRZUEUgPT09IFwiMjBcIiAmJiBkYXRhLk1FU1NBR0UgPT09IFwiU1VCU0NSSUJFQ09NUExFVEVcIikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCB0byBmZWVkcycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIGFzIFVUQ1RpbWVzdGFtcDtcbiAgICAgICAgbGV0IHByaWNlOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAgICAgICBpZiAoZGF0YS5UWVBFID09PSBcIjExXCIgfHwgZGF0YS5UWVBFID09PSBcIjJcIiB8fCBkYXRhLlRZUEUgPT09IFwiNVwiKSB7XG4gICAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0KGRhdGEuUFJJQ0UpO1xuICAgICAgICAgIGlmIChwcmljZSAmJiAhaXNOYU4ocHJpY2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVQcmljZVVwZGF0ZShwcmljZSwgdGltZXN0YW1wLCBjdXJyZW50VGltZWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNvY2tldC5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICAgIHJlY29ubmVjdCgpO1xuICAgIH07XG5cbiAgICBzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFdlYlNvY2tldCBjbG9zZWQgd2l0aCBjb2RlICR7ZXZlbnQuY29kZX0sIHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gICAgICByZWNvbm5lY3QoKTtcbiAgICB9O1xuXG4gICAgLy8gUGluZyBldmVyeSAxNSBzZWNvbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBhbGl2ZVxuICAgIGNvbnN0IHBpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChzb2NrZXQ/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBcImFjdGlvblwiOiBcIlBJTkdcIiB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyBwaW5nOicsIGVycm9yKTtcbiAgICAgICAgICByZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDE1MDAwKTtcblxuICAgIC8vIENsZWFuIHVwIHBpbmcgaW50ZXJ2YWwgb24gc29ja2V0IGNsb3NlXG4gICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpKTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFdlYlNvY2tldDonLCBlcnJvcik7XG4gICAgcmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICBzZXRUaW1lb3V0KGNvbm5lY3RXZWJTb2NrZXQsIFJFQ09OTkVDVF9ERUxBWSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb25uZWN0KCkge1xuICBpZiAoc29ja2V0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbG9zaW5nIHNvY2tldDonLCBlcnJvcik7XG4gICAgfVxuICAgIHNvY2tldCA9IG51bGw7XG4gIH1cbiAgc2V0VGltZW91dChjb25uZWN0V2ViU29ja2V0LCBSRUNPTk5FQ1RfREVMQVkgKiBNYXRoLm1pbihyZWNvbm5lY3RBdHRlbXB0cywgNSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlVG9QcmljZShjYWxsYmFjazogKGRhdGE6IFByaWNlRGF0YSkgPT4gdm9pZCwgdGltZWZyYW1lOiBUaW1lZnJhbWUgPSAnMW0nKSB7XG4gIGN1cnJlbnRUaW1lZnJhbWUgPSB0aW1lZnJhbWU7XG4gIHByaWNlVXBkYXRlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICBcbiAgLy8gSW1tZWRpYXRlbHkgZ2V0IGN1cnJlbnQgcHJpY2UgdmlhIFJFU1QgQVBJXG4gIGdldEN1cnJlbnRQcmljZSgpLnRoZW4ocHJpY2UgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIGFzIFVUQ1RpbWVzdGFtcDtcbiAgICBjYWxsYmFjayh7XG4gICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICB2YWx1ZTogcHJpY2VcbiAgICB9KTtcbiAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gIFxuICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBzdWJzY3JpYmVyLCBjb25uZWN0IHRvIFdlYlNvY2tldFxuICBpZiAocHJpY2VVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgY29ubmVjdFdlYlNvY2tldCgpO1xuICB9XG4gIFxuICByZXR1cm4gKCkgPT4ge1xuICAgIHByaWNlVXBkYXRlQ2FsbGJhY2tzID0gcHJpY2VVcGRhdGVDYWxsYmFja3MuZmlsdGVyKGNiID0+IGNiICE9PSBjYWxsYmFjayk7XG4gICAgaWYgKHByaWNlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCAmJiB0cmFkZVVwZGF0ZUNhbGxiYWNrcy5sZW5ndGggPT09IDAgJiYgc29ja2V0KSB7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlVG9UcmFkZXMoY2FsbGJhY2s6IChkYXRhOiBUcmFkZURhdGEpID0+IHZvaWQpIHtcbiAgdHJhZGVVcGRhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIFxuICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBzdWJzY3JpYmVyLCBjb25uZWN0IHRvIFdlYlNvY2tldFxuICBpZiAodHJhZGVVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAxICYmIHByaWNlVXBkYXRlQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbm5lY3RXZWJTb2NrZXQoKTtcbiAgfVxuICBcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0cmFkZVVwZGF0ZUNhbGxiYWNrcyA9IHRyYWRlVXBkYXRlQ2FsbGJhY2tzLmZpbHRlcihjYiA9PiBjYiAhPT0gY2FsbGJhY2spO1xuICAgIGlmIChwcmljZVVwZGF0ZUNhbGxiYWNrcy5sZW5ndGggPT09IDAgJiYgdHJhZGVVcGRhdGVDYWxsYmFja3MubGVuZ3RoID09PSAwICYmIHNvY2tldCkge1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRQcmljZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vbWluLWFwaS5jcnlwdG9jb21wYXJlLmNvbS9kYXRhL3ByaWNlP2ZzeW09QlRDJnRzeW1zPVVTRCcpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YS5VU0Q7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJpY2U6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWU6IFRpbWVmcmFtZSA9ICcxbScpOiBQcm9taXNlPGFueVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29uZmlnID0gVElNRUZSQU1FX0NPTkZJR1t0aW1lZnJhbWVdO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFwcHJvcHJpYXRlIGFnZ3JlZ2F0ZSBwYXJhbWV0ZXIgYmFzZWQgb24gdGltZWZyYW1lXG4gICAgbGV0IGFnZ3JlZ2F0ZSA9IDE7XG4gICAgaWYgKGNvbmZpZy5lbmRwb2ludCA9PT0gJ2hpc3RvbWludXRlJykge1xuICAgICAgYWdncmVnYXRlID0gY29uZmlnLmludGVydmFsIC8gNjA7XG4gICAgfSBlbHNlIGlmIChjb25maWcuZW5kcG9pbnQgPT09ICdoaXN0b2hvdXInKSB7XG4gICAgICBhZ2dyZWdhdGUgPSBjb25maWcuaW50ZXJ2YWwgLyAzNjAwO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmVuZHBvaW50ID09PSAnaGlzdG9kYXknKSB7XG4gICAgICBhZ2dyZWdhdGUgPSBjb25maWcuaW50ZXJ2YWwgLyA4NjQwMDtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9taW4tYXBpLmNyeXB0b2NvbXBhcmUuY29tL2RhdGEvdjIvJHtjb25maWcuZW5kcG9pbnR9P2ZzeW09QlRDJnRzeW09VVNEJmxpbWl0PSR7Y29uZmlnLmxpbWl0fSZ0b1RzPSR7ZW5kVGltZX0mYWdncmVnYXRlPSR7YWdncmVnYXRlfWA7XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIGhpc3RvcmljYWwgZGF0YSBmb3IgJHt0aW1lZnJhbWV9IHRpbWVmcmFtZS4uLmApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKCFkYXRhLkRhdGE/LkRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIGZvcm1hdCByZWNlaXZlZCBmcm9tIEFQSScpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLkRhdGEuRGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59ICJdLCJuYW1lcyI6WyJUSU1FRlJBTUVfQ09ORklHIiwiZW5kcG9pbnQiLCJsaW1pdCIsImludGVydmFsIiwic29ja2V0IiwicHJpY2VVcGRhdGVDYWxsYmFja3MiLCJ0cmFkZVVwZGF0ZUNhbGxiYWNrcyIsInBlbmRpbmdTdWJzY3JpcHRpb24iLCJsYXN0UHJpY2UiLCJyZWNvbm5lY3RBdHRlbXB0cyIsImN1cnJlbnRUaW1lZnJhbWUiLCJNQVhfUkVDT05ORUNUX0FUVEVNUFRTIiwiUkVDT05ORUNUX0RFTEFZIiwiZmV0Y2hQcmljZVVwZGF0ZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsInByaWNlIiwiVVNEIiwidGltZXN0YW1wIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImlzTmFOIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwidGltZSIsInZhbHVlIiwiZXJyb3IiLCJjb25zb2xlIiwic2VuZFN1YnNjcmlwdGlvbiIsIndzIiwic3Vic2NyaWJlTXNnIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJsb2ciLCJoYW5kbGVQcmljZVVwZGF0ZSIsInRpbWVmcmFtZSIsImNvbmZpZyIsImFsaWduZWRUaW1lc3RhbXAiLCJsZW5ndGgiLCJ2b2x1bWUyNGgiLCJjb25uZWN0V2ViU29ja2V0IiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJwb2xsSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsb3NlIiwib25vcGVuIiwib25tZXNzYWdlIiwiZXZlbnQiLCJwYXJzZSIsIlRZUEUiLCJNRVNTQUdFIiwicGFyc2VGbG9hdCIsIlBSSUNFIiwib25lcnJvciIsInJlY29ubmVjdCIsIm9uY2xvc2UiLCJjb2RlIiwicmVhc29uIiwicGluZ0ludGVydmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsZWFySW50ZXJ2YWwiLCJzZXRUaW1lb3V0IiwibWluIiwic3Vic2NyaWJlVG9QcmljZSIsInB1c2giLCJnZXRDdXJyZW50UHJpY2UiLCJ0aGVuIiwiY2F0Y2giLCJmaWx0ZXIiLCJjYiIsInN1YnNjcmliZVRvVHJhZGVzIiwib2siLCJFcnJvciIsInN0YXR1cyIsImdldEhpc3RvcmljYWxEYXRhIiwiZW5kVGltZSIsImFnZ3JlZ2F0ZSIsInVybCIsIkRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/ema-crossover */ \"(app-pages-browser)/./src/services/strategies/ema-crossover.ts\");\n/* harmony import */ var _services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/services/strategies/sma-crossover */ \"(app-pages-browser)/./src/services/strategies/sma-crossover.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token, exchange } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const lastSignalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Add this function for signal detection\n    const detectCrossoverSignals = (data, fastLine, slowLine, startIndex)=>{\n        const signals = [];\n        for(let i = Math.max(startIndex, 1); i < data.length; i++){\n            const prevFast = fastLine[i - 1];\n            const prevSlow = slowLine[i - 1];\n            const currFast = fastLine[i];\n            const currSlow = slowLine[i];\n            if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                // Buy signal: Fast crosses above Slow\n                if (prevFast <= prevSlow && currFast > currSlow) {\n                    signals.push({\n                        time: data[i].time,\n                        type: \"buy\",\n                        price: data[i].close,\n                        fastMA: currFast,\n                        slowMA: currSlow\n                    });\n                } else if (prevFast >= prevSlow && currFast < currSlow) {\n                    signals.push({\n                        time: data[i].time,\n                        type: \"sell\",\n                        price: data[i].close,\n                        fastMA: currFast,\n                        slowMA: currSlow\n                    });\n                }\n            }\n        }\n        return signals;\n    };\n    // Modify the updateStrategyIndicators function\n    const updateStrategyIndicators = function(data, chart) {\n        let isInitialSetup = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy || strategy === \"none\") {\n                console.log(\"No strategy selected or invalid strategy\");\n                return;\n            }\n            if (isInitialSetup) {\n                console.log(\"Setting up new strategy indicators\");\n                try {\n                    // Create marker series for signals using a line series\n                    markerSeriesRef.current = chart.addLineSeries({\n                        lastValueVisible: false,\n                        priceLineVisible: false,\n                        visible: false\n                    });\n                    // Create indicator series\n                    if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                        const indicators = [\n                            \"Fast MA\",\n                            \"Slow MA\"\n                        ];\n                        indicators.forEach((name, index)=>{\n                            console.log(\"Adding indicator: \".concat(name));\n                            const colors = [\n                                \"#2962FF\",\n                                \"#FF6B6B\"\n                            ]; // Blue for fast, Red for slow\n                            const lineSeries = chart.addLineSeries({\n                                color: colors[index],\n                                lineWidth: 2,\n                                title: name,\n                                priceFormat: {\n                                    type: \"price\",\n                                    precision: 2,\n                                    minMove: 0.01\n                                },\n                                lineStyle: 1,\n                                lastValueVisible: true,\n                                priceLineVisible: false\n                            });\n                            indicatorSeriesRefs.current.set(name, lineSeries);\n                        });\n                    }\n                } catch (e) {\n                    console.error(\"Error creating series:\", e);\n                    return;\n                }\n            }\n            // Calculate indicators\n            const prices = data.map((d)=>d.close);\n            const fastPeriod = 9;\n            const slowPeriod = 21;\n            const fastLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, fastPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, fastPeriod);\n            const slowLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, slowPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, slowPeriod);\n            // Update indicator lines\n            const fastSeries = indicatorSeriesRefs.current.get(\"Fast MA\");\n            const slowSeries = indicatorSeriesRefs.current.get(\"Slow MA\");\n            if (fastSeries && slowSeries) {\n                const fastData = fastLine.map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                const slowData = slowLine.map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                fastSeries.setData(fastData);\n                slowSeries.setData(slowData);\n            }\n            // Detect signals\n            const startIndex = isInitialSetup ? Math.max(fastPeriod, slowPeriod) : data.length - 2;\n            const signals = detectCrossoverSignals(data, fastLine, slowLine, startIndex);\n            // Update markers if we have new signals\n            if (signals.length > 0 && markerSeriesRef.current) {\n                const markers = signals.map((signal)=>({\n                        time: signal.time,\n                        position: signal.type === \"buy\" ? \"belowBar\" : \"aboveBar\",\n                        color: signal.type === \"buy\" ? \"#26a69a\" : \"#ef5350\",\n                        shape: signal.type === \"buy\" ? \"arrowUp\" : \"arrowDown\",\n                        text: \"\".concat(signal.type === \"buy\" ? \"Buy\" : \"Sell\", \" \").concat(signal.price.toFixed(2)),\n                        size: 3\n                    }));\n                // For real-time updates, append to existing markers\n                if (!isInitialSetup && markerSeriesRef.current) {\n                    const existingMarkers = markerSeriesRef.current.markers();\n                    markers.push(...existingMarkers);\n                }\n                markerSeriesRef.current.setMarkers(markers);\n                // Log the signals\n                signals.forEach((signal)=>{\n                    console.log(\"\".concat(signal.type.toUpperCase(), \" Signal:\"), {\n                        time: new Date(signal.time * 1000).toLocaleString(),\n                        price: signal.price.toFixed(2),\n                        fastMA: signal.fastMA.toFixed(2),\n                        slowMA: signal.slowMA.toFixed(2)\n                    });\n                });\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current && historicalDataRef.current.length > 0) {\n            console.log(\"Reinitializing strategy indicators\");\n            // Clean up old indicators and markers\n            if (markerSeriesRef.current) {\n                try {\n                    safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    safelyRemoveSeries(chartRef.current, series);\n                } catch (e) {\n                    console.error(\"Error removing indicator series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            // Initialize new strategy immediately if not none\n            if (strategy !== \"none\") {\n                try {\n                    updateStrategyIndicators(historicalDataRef.current, chartRef.current, true);\n                } catch (e) {\n                    console.error(\"Error initializing strategy:\", e);\n                }\n            }\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                var // Set candlestick data\n                _candlestickSeriesRef_current;\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                (_candlestickSeriesRef_current = candlestickSeriesRef.current) === null || _candlestickSeriesRef_current === void 0 ? void 0 : _candlestickSeriesRef_current.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Initialize strategy indicators if a strategy is selected\n                if (strategy !== \"none\") {\n                    console.log(\"Initializing strategy indicators after loading data\");\n                    updateStrategyIndicators(historicalData, chart, true);\n                }\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current,\n                            {\n                                ...newCandle,\n                                time: currentCandle.time\n                            }\n                        ];\n                        // Update strategy indicators with completed candle\n                        if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                            updateStrategyIndicators(historicalDataRef.current, chartRef.current, false);\n                        }\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: Number(candleTimestamp),\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                }\n                // Update candlestick series with the current state\n                candlestickSeriesRef.current.update(currentCandle);\n                // Update strategy indicators with current in-progress candle\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const updatedData = [\n                        ...historicalDataRef.current,\n                        currentCandle\n                    ];\n                    updateStrategyIndicators(updatedData, chartRef.current, false);\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 481,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"A5KOt13apH6B8777DhsXxwqClJI=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRTBDO0FBQ087QUFDZ0Q7QUFDakM7QUFDRztBQUNBO0FBaUI1RCxTQUFTUSxpQkFBaUIsS0FBK0Q7UUFBL0QsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUF5QixHQUEvRDs7SUFDL0IsTUFBTUMsb0JBQW9CWiw2Q0FBTUEsQ0FBaUI7SUFDakQsTUFBTWEsV0FBV2IsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU1jLHVCQUF1QmQsNkNBQU1BLENBQU07SUFDekMsTUFBTWUsc0JBQXNCZiw2Q0FBTUEsQ0FBbUIsSUFBSWdCO0lBQ3pELE1BQU1DLGtCQUFrQmpCLDZDQUFNQSxDQUFNO0lBQ3BDLE1BQU1rQixvQkFBb0JsQiw2Q0FBTUEsQ0FBUSxFQUFFO0lBQzFDLE1BQU1tQixnQkFBZ0JuQiw2Q0FBTUEsQ0FBZ0Q7SUFFNUUscUNBQXFDO0lBQ3JDLE1BQU1vQixxQkFBcUIsQ0FBQ0MsT0FBa0JDO1FBQzVDLElBQUk7WUFDRixJQUFJQSxVQUFVRCxPQUFPO2dCQUNuQkEsTUFBTUUsWUFBWSxDQUFDRDtZQUNyQjtRQUNGLEVBQUUsT0FBT0UsR0FBRztZQUNWQyxRQUFRQyxLQUFLLENBQUMsMEJBQTBCRjtRQUMxQztJQUNGO0lBRUEseUNBQXlDO0lBQ3pDLE1BQU1HLHlCQUF5QixDQUM3QkMsTUFDQUMsVUFDQUMsVUFDQUM7UUFFQSxNQUFNQyxVQUFVLEVBQUU7UUFFbEIsSUFBSyxJQUFJQyxJQUFJQyxLQUFLQyxHQUFHLENBQUNKLFlBQVksSUFBSUUsSUFBSUwsS0FBS1EsTUFBTSxFQUFFSCxJQUFLO1lBQzFELE1BQU1JLFdBQVdSLFFBQVEsQ0FBQ0ksSUFBSSxFQUFFO1lBQ2hDLE1BQU1LLFdBQVdSLFFBQVEsQ0FBQ0csSUFBSSxFQUFFO1lBQ2hDLE1BQU1NLFdBQVdWLFFBQVEsQ0FBQ0ksRUFBRTtZQUM1QixNQUFNTyxXQUFXVixRQUFRLENBQUNHLEVBQUU7WUFFNUIsSUFBSSxDQUFDUSxNQUFNSixhQUFhLENBQUNJLE1BQU1ILGFBQWEsQ0FBQ0csTUFBTUYsYUFBYSxDQUFDRSxNQUFNRCxXQUFXO2dCQUNoRixzQ0FBc0M7Z0JBQ3RDLElBQUlILFlBQVlDLFlBQVlDLFdBQVdDLFVBQVU7b0JBQy9DUixRQUFRVSxJQUFJLENBQUM7d0JBQ1hDLE1BQU1mLElBQUksQ0FBQ0ssRUFBRSxDQUFDVSxJQUFJO3dCQUNsQkMsTUFBTTt3QkFDTkMsT0FBT2pCLElBQUksQ0FBQ0ssRUFBRSxDQUFDYSxLQUFLO3dCQUNwQkMsUUFBUVI7d0JBQ1JTLFFBQVFSO29CQUNWO2dCQUNGLE9BRUssSUFBSUgsWUFBWUMsWUFBWUMsV0FBV0MsVUFBVTtvQkFDcERSLFFBQVFVLElBQUksQ0FBQzt3QkFDWEMsTUFBTWYsSUFBSSxDQUFDSyxFQUFFLENBQUNVLElBQUk7d0JBQ2xCQyxNQUFNO3dCQUNOQyxPQUFPakIsSUFBSSxDQUFDSyxFQUFFLENBQUNhLEtBQUs7d0JBQ3BCQyxRQUFRUjt3QkFDUlMsUUFBUVI7b0JBQ1Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsT0FBT1I7SUFDVDtJQUVBLCtDQUErQztJQUMvQyxNQUFNaUIsMkJBQTJCLFNBQUNyQixNQUFhUDtZQUFrQjZCLGtGQUEwQjtRQUN6RixJQUFJO1lBQ0YsSUFBSSxDQUFDN0IsU0FBUyxDQUFDTyxLQUFLUSxNQUFNLEVBQUU7Z0JBQzFCWCxRQUFRMEIsR0FBRyxDQUFDO2dCQUNaO1lBQ0Y7WUFFQSxNQUFNQyxtQkFBbUJoRCxpRUFBV0EsQ0FBQ0s7WUFDckMsSUFBSSxDQUFDMkMsb0JBQW9CM0MsYUFBYSxRQUFRO2dCQUM1Q2dCLFFBQVEwQixHQUFHLENBQUM7Z0JBQ1o7WUFDRjtZQUVBLElBQUlELGdCQUFnQjtnQkFDbEJ6QixRQUFRMEIsR0FBRyxDQUFDO2dCQUNaLElBQUk7b0JBQ0YsdURBQXVEO29CQUN2RGxDLGdCQUFnQm9DLE9BQU8sR0FBR2hDLE1BQU1pQyxhQUFhLENBQUM7d0JBQzVDQyxrQkFBa0I7d0JBQ2xCQyxrQkFBa0I7d0JBQ2xCQyxTQUFTO29CQUNYO29CQUVBLDBCQUEwQjtvQkFDMUIsSUFBSUwsaUJBQWlCTSxFQUFFLEtBQUssbUJBQW1CTixpQkFBaUJNLEVBQUUsS0FBSyxpQkFBaUI7d0JBQ3RGLE1BQU1DLGFBQWE7NEJBQUM7NEJBQVc7eUJBQVU7d0JBQ3pDQSxXQUFXQyxPQUFPLENBQUMsQ0FBQ0MsTUFBTUM7NEJBQ3hCckMsUUFBUTBCLEdBQUcsQ0FBQyxxQkFBMEIsT0FBTFU7NEJBQ2pDLE1BQU1FLFNBQVM7Z0NBQUM7Z0NBQVc7NkJBQVUsRUFBRSw4QkFBOEI7NEJBQ3JFLE1BQU1DLGFBQWEzQyxNQUFNaUMsYUFBYSxDQUFDO2dDQUNyQ1csT0FBT0YsTUFBTSxDQUFDRCxNQUFNO2dDQUNwQkksV0FBVztnQ0FDWEMsT0FBT047Z0NBQ1BPLGFBQWE7b0NBQ1h4QixNQUFNO29DQUNOeUIsV0FBVztvQ0FDWEMsU0FBUztnQ0FDWDtnQ0FDQUMsV0FBVztnQ0FDWGhCLGtCQUFrQjtnQ0FDbEJDLGtCQUFrQjs0QkFDcEI7NEJBQ0F6QyxvQkFBb0JzQyxPQUFPLENBQUNtQixHQUFHLENBQUNYLE1BQU1HO3dCQUN4QztvQkFDRjtnQkFDRixFQUFFLE9BQU94QyxHQUFHO29CQUNWQyxRQUFRQyxLQUFLLENBQUMsMEJBQTBCRjtvQkFDeEM7Z0JBQ0Y7WUFDRjtZQUVBLHVCQUF1QjtZQUN2QixNQUFNaUQsU0FBUzdDLEtBQUs4QyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUU3QixLQUFLO1lBQ3BDLE1BQU04QixhQUFhO1lBQ25CLE1BQU1DLGFBQWE7WUFFbkIsTUFBTWhELFdBQVd1QixpQkFBaUJNLEVBQUUsS0FBSyxrQkFDckNyRCxnRkFBWUEsQ0FBQ29FLFFBQVFHLGNBQ3JCdEUsZ0ZBQVlBLENBQUNtRSxRQUFRRztZQUN6QixNQUFNOUMsV0FBV3NCLGlCQUFpQk0sRUFBRSxLQUFLLGtCQUNyQ3JELGdGQUFZQSxDQUFDb0UsUUFBUUksY0FDckJ2RSxnRkFBWUEsQ0FBQ21FLFFBQVFJO1lBRXpCLHlCQUF5QjtZQUN6QixNQUFNQyxhQUFhL0Qsb0JBQW9Cc0MsT0FBTyxDQUFDMEIsR0FBRyxDQUFDO1lBQ25ELE1BQU1DLGFBQWFqRSxvQkFBb0JzQyxPQUFPLENBQUMwQixHQUFHLENBQUM7WUFFbkQsSUFBSUQsY0FBY0UsWUFBWTtnQkFDNUIsTUFBTUMsV0FBV3BELFNBQVM2QyxHQUFHLENBQUMsQ0FBQ1EsT0FBZUMsTUFBaUI7d0JBQzdEeEMsTUFBTWYsSUFBSSxDQUFDdUQsSUFBSSxDQUFDeEMsSUFBSTt3QkFDcEJ1QyxPQUFPekMsTUFBTXlDLFNBQVMsT0FBT0E7b0JBQy9CLElBQUlFLE1BQU0sQ0FBQ1QsQ0FBQUEsSUFBS0EsRUFBRU8sS0FBSyxLQUFLO2dCQUU1QixNQUFNRyxXQUFXdkQsU0FBUzRDLEdBQUcsQ0FBQyxDQUFDUSxPQUFlQyxNQUFpQjt3QkFDN0R4QyxNQUFNZixJQUFJLENBQUN1RCxJQUFJLENBQUN4QyxJQUFJO3dCQUNwQnVDLE9BQU96QyxNQUFNeUMsU0FBUyxPQUFPQTtvQkFDL0IsSUFBSUUsTUFBTSxDQUFDVCxDQUFBQSxJQUFLQSxFQUFFTyxLQUFLLEtBQUs7Z0JBRTVCSixXQUFXUSxPQUFPLENBQUNMO2dCQUNuQkQsV0FBV00sT0FBTyxDQUFDRDtZQUNyQjtZQUVBLGlCQUFpQjtZQUNqQixNQUFNdEQsYUFBYW1CLGlCQUFpQmhCLEtBQUtDLEdBQUcsQ0FBQ3lDLFlBQVlDLGNBQWNqRCxLQUFLUSxNQUFNLEdBQUc7WUFDckYsTUFBTUosVUFBVUwsdUJBQXVCQyxNQUFNQyxVQUFVQyxVQUFVQztZQUVqRSx3Q0FBd0M7WUFDeEMsSUFBSUMsUUFBUUksTUFBTSxHQUFHLEtBQUtuQixnQkFBZ0JvQyxPQUFPLEVBQUU7Z0JBQ2pELE1BQU1rQyxVQUFVdkQsUUFBUTBDLEdBQUcsQ0FBQ2MsQ0FBQUEsU0FBVzt3QkFDckM3QyxNQUFNNkMsT0FBTzdDLElBQUk7d0JBQ2pCOEMsVUFBVUQsT0FBTzVDLElBQUksS0FBSyxRQUFRLGFBQWE7d0JBQy9DcUIsT0FBT3VCLE9BQU81QyxJQUFJLEtBQUssUUFBUSxZQUFZO3dCQUMzQzhDLE9BQU9GLE9BQU81QyxJQUFJLEtBQUssUUFBUSxZQUFZO3dCQUMzQytDLE1BQU0sR0FBNkNILE9BQTFDQSxPQUFPNUMsSUFBSSxLQUFLLFFBQVEsUUFBUSxRQUFPLEtBQTJCLE9BQXhCNEMsT0FBTzNDLEtBQUssQ0FBQytDLE9BQU8sQ0FBQzt3QkFDeEVDLE1BQU07b0JBQ1I7Z0JBRUEsb0RBQW9EO2dCQUNwRCxJQUFJLENBQUMzQyxrQkFBa0JqQyxnQkFBZ0JvQyxPQUFPLEVBQUU7b0JBQzlDLE1BQU15QyxrQkFBa0I3RSxnQkFBZ0JvQyxPQUFPLENBQUNrQyxPQUFPO29CQUN2REEsUUFBUTdDLElBQUksSUFBSW9EO2dCQUNsQjtnQkFFQTdFLGdCQUFnQm9DLE9BQU8sQ0FBQzBDLFVBQVUsQ0FBQ1I7Z0JBRW5DLGtCQUFrQjtnQkFDbEJ2RCxRQUFRNEIsT0FBTyxDQUFDNEIsQ0FBQUE7b0JBQ2QvRCxRQUFRMEIsR0FBRyxDQUFDLEdBQTZCLE9BQTFCcUMsT0FBTzVDLElBQUksQ0FBQ29ELFdBQVcsSUFBRyxhQUFXO3dCQUNsRHJELE1BQU0sSUFBSXNELEtBQUtULE9BQU83QyxJQUFJLEdBQUcsTUFBTXVELGNBQWM7d0JBQ2pEckQsT0FBTzJDLE9BQU8zQyxLQUFLLENBQUMrQyxPQUFPLENBQUM7d0JBQzVCN0MsUUFBUXlDLE9BQU96QyxNQUFNLENBQUM2QyxPQUFPLENBQUM7d0JBQzlCNUMsUUFBUXdDLE9BQU94QyxNQUFNLENBQUM0QyxPQUFPLENBQUM7b0JBQ2hDO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU9wRSxHQUFHO1lBQ1ZDLFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NGO1FBQ3REO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEN6QixnREFBU0EsQ0FBQztRQUNSMEIsUUFBUTBCLEdBQUcsQ0FBQyxxQkFBcUIxQztRQUVqQyxJQUFJSSxTQUFTd0MsT0FBTyxJQUFJbkMsa0JBQWtCbUMsT0FBTyxDQUFDakIsTUFBTSxHQUFHLEdBQUc7WUFDNURYLFFBQVEwQixHQUFHLENBQUM7WUFFWixzQ0FBc0M7WUFDdEMsSUFBSWxDLGdCQUFnQm9DLE9BQU8sRUFBRTtnQkFDM0IsSUFBSTtvQkFDRmpDLG1CQUFtQlAsU0FBU3dDLE9BQU8sRUFBRXBDLGdCQUFnQm9DLE9BQU87Z0JBQzlELEVBQUUsT0FBTzdCLEdBQUc7b0JBQ1ZDLFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNGO2dCQUNqRDtnQkFDQVAsZ0JBQWdCb0MsT0FBTyxHQUFHO1lBQzVCO1lBRUF0QyxvQkFBb0JzQyxPQUFPLENBQUNPLE9BQU8sQ0FBQ3RDLENBQUFBO2dCQUNsQyxJQUFJO29CQUNGRixtQkFBbUJQLFNBQVN3QyxPQUFPLEVBQUcvQjtnQkFDeEMsRUFBRSxPQUFPRSxHQUFHO29CQUNWQyxRQUFRQyxLQUFLLENBQUMsb0NBQW9DRjtnQkFDcEQ7WUFDRjtZQUNBVCxvQkFBb0JzQyxPQUFPLENBQUM4QyxLQUFLO1lBRWpDLGtEQUFrRDtZQUNsRCxJQUFJMUYsYUFBYSxRQUFRO2dCQUN2QixJQUFJO29CQUNGd0MseUJBQXlCL0Isa0JBQWtCbUMsT0FBTyxFQUFFeEMsU0FBU3dDLE9BQU8sRUFBRTtnQkFDeEUsRUFBRSxPQUFPN0IsR0FBRztvQkFDVkMsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0Y7Z0JBQ2hEO1lBQ0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ2Y7S0FBUyxHQUFHLGlDQUFpQztJQUVqRCxtQ0FBbUM7SUFDbkNWLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDYSxrQkFBa0J5QyxPQUFPLEVBQUU7UUFDaEM1QixRQUFRMEIsR0FBRyxDQUFDLHNDQUFzQzNDO1FBRWxELE1BQU00RixhQUFhLENBQUN6RDtZQUNsQixJQUFJMEQ7WUFFSixJQUFJLE9BQU8xRCxTQUFTLFVBQVU7Z0JBQzVCMEQsT0FBTyxJQUFJSixLQUFLdEQsT0FBTztZQUN6QixPQUFPLElBQUksT0FBT0EsU0FBUyxVQUFVO2dCQUNuQzBELE9BQU8sSUFBSUosS0FBS3REO1lBQ2xCLE9BQU87Z0JBQ0wsNEJBQTRCO2dCQUM1QixNQUFNLEVBQUUyRCxJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUc3RDtnQkFDN0IwRCxPQUFPLElBQUlKLEtBQUtLLE1BQU1DLFFBQVEsR0FBR0M7WUFDbkM7WUFFQSxNQUFNQyxnQkFBNEM7Z0JBQ2hERixPQUFPO2dCQUNQQyxLQUFLO2dCQUNMRSxNQUFNO2dCQUNOQyxRQUFRO2dCQUNSQyxRQUFRO1lBQ1Y7WUFFQSx3Q0FBd0M7WUFDeEMsSUFBSXBHLGNBQWMsTUFBTTtnQkFDdEIsT0FBT2lHLGNBQWNDLElBQUk7Z0JBQ3pCLE9BQU9ELGNBQWNFLE1BQU07WUFDN0I7WUFFQSxPQUFPTixLQUFLSCxjQUFjLENBQUMsU0FBU087UUFDdEM7UUFFQSxNQUFNSSxlQUEwQztZQUM5Q0MsUUFBUTtnQkFDTkMsWUFBWTtvQkFBRTlDLE9BQU87Z0JBQVU7Z0JBQy9CK0MsV0FBVztnQkFDWEMsVUFBVTtnQkFDVkMsWUFBWTtZQUNkO1lBQ0FDLE1BQU07Z0JBQ0pDLFdBQVc7b0JBQUVuRCxPQUFPO2dCQUFVO2dCQUM5Qm9ELFdBQVc7b0JBQUVwRCxPQUFPO2dCQUFVO1lBQ2hDO1lBQ0FxRCxXQUFXO2dCQUNUQyxNQUFNO2dCQUNOQyxVQUFVO29CQUNSQyxPQUFPO29CQUNQeEQsT0FBTztvQkFDUHlELE9BQU87Z0JBQ1Q7Z0JBQ0FDLFVBQVU7b0JBQ1JGLE9BQU87b0JBQ1B4RCxPQUFPO29CQUNQeUQsT0FBTztnQkFDVDtZQUNGO1lBQ0FFLFdBQVc7Z0JBQ1RDLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JDLGdCQUFnQjtZQUNsQjtZQUNBQyxpQkFBaUI7Z0JBQ2ZILGFBQWE7WUFDZjtZQUNBSSxjQUFjO2dCQUNaQyxlQUFlOUI7WUFDakI7WUFDQStCLFdBQVc7Z0JBQ1QxRSxTQUFTO1lBQ1g7UUFDRjtRQUVBLE1BQU1wQyxRQUFRcEIsK0RBQVdBLENBQUNXLGtCQUFrQnlDLE9BQU8sRUFBRTtZQUNuRCxHQUFHd0QsWUFBWTtZQUNmWSxPQUFPN0csa0JBQWtCeUMsT0FBTyxDQUFDK0UsV0FBVztZQUM1Q0MsUUFBUXpILGtCQUFrQnlDLE9BQU8sQ0FBQ2lGLFlBQVk7UUFDaEQ7UUFFQSxNQUFNQyxvQkFBb0JsSCxNQUFNbUgsb0JBQW9CLENBQUM7WUFDbkRDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxlQUFlO1lBQ2ZDLGFBQWE7WUFDYkMsZUFBZTtRQUNqQjtRQUVBL0gscUJBQXFCdUMsT0FBTyxHQUFHa0Y7UUFFL0Isd0JBQXdCO1FBQ3hCLE1BQU1PLFdBQVc7WUFDZixJQUFJO29CQUtGLHVCQUF1QjtnQkFDdkJoSTtnQkFMQSxNQUFNaUksaUJBQWlCLE1BQU03SSxpRkFBaUJBLENBQUNNO2dCQUMvQ2lCLFFBQVEwQixHQUFHLENBQUMsMkJBQTJCNEYsZUFBZTNHLE1BQU07Z0JBQzVEbEIsa0JBQWtCbUMsT0FBTyxHQUFHMEY7aUJBRzVCakksZ0NBQUFBLHFCQUFxQnVDLE9BQU8sY0FBNUJ2QyxvREFBQUEsOEJBQThCd0UsT0FBTyxDQUFDeUQsZUFBZXJFLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBTTt3QkFDN0RoQyxNQUFNZ0MsRUFBRWhDLElBQUk7d0JBQ1pxRyxNQUFNckUsRUFBRXFFLElBQUk7d0JBQ1pDLE1BQU10RSxFQUFFc0UsSUFBSTt3QkFDWkMsS0FBS3ZFLEVBQUV1RSxHQUFHO3dCQUNWcEcsT0FBTzZCLEVBQUU3QixLQUFLO29CQUNoQjtnQkFFQSwyREFBMkQ7Z0JBQzNELElBQUlyQyxhQUFhLFFBQVE7b0JBQ3ZCZ0IsUUFBUTBCLEdBQUcsQ0FBQztvQkFDWkYseUJBQXlCOEYsZ0JBQWdCMUgsT0FBTztnQkFDbEQ7WUFDRixFQUFFLE9BQU9LLE9BQU87Z0JBQ2RELFFBQVFDLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2xEO1FBQ0Y7UUFFQW9IO1FBQ0FqSSxTQUFTd0MsT0FBTyxHQUFHaEM7UUFFbkIsdUNBQXVDO1FBQ3ZDLElBQUk4SCxnQkFBZ0I7WUFDbEJILE1BQU07WUFDTkMsTUFBTSxDQUFDRztZQUNQRixLQUFLRTtZQUNMdEcsT0FBTztZQUNQSCxNQUFNO1FBQ1I7UUFFQSxNQUFNMEcscUJBQXFCLENBQUNDO1lBQzFCLE9BQVFBO2dCQUNOLEtBQUs7b0JBQU0sT0FBTztnQkFDbEIsS0FBSztvQkFBTSxPQUFPO2dCQUNsQixLQUFLO29CQUFPLE9BQU87Z0JBQ25CLEtBQUs7b0JBQU8sT0FBTztnQkFDbkIsS0FBSztvQkFBTSxPQUFPO2dCQUNsQixLQUFLO29CQUFNLE9BQU87Z0JBQ2xCLEtBQUs7b0JBQU0sT0FBTztnQkFDbEI7b0JBQVMsT0FBTztZQUNsQjtRQUNGO1FBRUEsTUFBTUMsY0FBY3BKLGdGQUFnQkEsQ0FBQyxDQUFDeUI7WUFDcEMsSUFBSWQscUJBQXFCdUMsT0FBTyxFQUFFO2dCQUNoQyxNQUFNbUcsa0JBQWtCSCxtQkFBbUI3STtnQkFDM0MsTUFBTWlKLGtCQUFrQnZILEtBQUt3SCxLQUFLLENBQUM5SCxLQUFLZSxJQUFJLEdBQUc2RyxtQkFBbUJBO2dCQUVsRSwwQkFBMEI7Z0JBQzFCLElBQUlDLG9CQUFxQk4sY0FBY3hHLElBQUksRUFBbUI7b0JBQzVELDhDQUE4QztvQkFDOUMsSUFBSXdHLGNBQWN4RyxJQUFJLEtBQUssR0FBRzt3QkFDNUIsTUFBTWdILFlBQVk7NEJBQ2hCaEgsTUFBTXdHLGNBQWN4RyxJQUFJOzRCQUN4QnFHLE1BQU1HLGNBQWNILElBQUk7NEJBQ3hCQyxNQUFNRSxjQUFjRixJQUFJOzRCQUN4QkMsS0FBS0MsY0FBY0QsR0FBRzs0QkFDdEJwRyxPQUFPcUcsY0FBY3JHLEtBQUs7d0JBQzVCO3dCQUNBaEMscUJBQXFCdUMsT0FBTyxDQUFDdUcsTUFBTSxDQUFDRDt3QkFFcEMsNkNBQTZDO3dCQUM3Q3pJLGtCQUFrQm1DLE9BQU8sR0FBRzsrQkFBSW5DLGtCQUFrQm1DLE9BQU87NEJBQUU7Z0NBQ3pELEdBQUdzRyxTQUFTO2dDQUNaaEgsTUFBTXdHLGNBQWN4RyxJQUFJOzRCQUMxQjt5QkFBRTt3QkFFRixtREFBbUQ7d0JBQ25ELElBQUlsQyxhQUFhLFVBQVVJLFNBQVN3QyxPQUFPLElBQUl0QyxvQkFBb0JzQyxPQUFPLENBQUN3QyxJQUFJLEdBQUcsR0FBRzs0QkFDbkY1Qyx5QkFBeUIvQixrQkFBa0JtQyxPQUFPLEVBQUV4QyxTQUFTd0MsT0FBTyxFQUFFO3dCQUN4RTtvQkFDRjtvQkFFQSxxQkFBcUI7b0JBQ3JCOEYsZ0JBQWdCO3dCQUNkeEcsTUFBTWtILE9BQU9KO3dCQUNiVCxNQUFNcEgsS0FBS3NELEtBQUs7d0JBQ2hCK0QsTUFBTXJILEtBQUtzRCxLQUFLO3dCQUNoQmdFLEtBQUt0SCxLQUFLc0QsS0FBSzt3QkFDZnBDLE9BQU9sQixLQUFLc0QsS0FBSztvQkFDbkI7Z0JBQ0YsT0FBTztvQkFDTCx5QkFBeUI7b0JBQ3pCLElBQUl0RCxLQUFLc0QsS0FBSyxHQUFHaUUsY0FBY0YsSUFBSSxFQUFFRSxjQUFjRixJQUFJLEdBQUdySCxLQUFLc0QsS0FBSztvQkFDcEUsSUFBSXRELEtBQUtzRCxLQUFLLEdBQUdpRSxjQUFjRCxHQUFHLEVBQUVDLGNBQWNELEdBQUcsR0FBR3RILEtBQUtzRCxLQUFLO29CQUNsRWlFLGNBQWNyRyxLQUFLLEdBQUdsQixLQUFLc0QsS0FBSztnQkFDbEM7Z0JBRUEsbURBQW1EO2dCQUNuRHBFLHFCQUFxQnVDLE9BQU8sQ0FBQ3VHLE1BQU0sQ0FBQ1Q7Z0JBRXBDLDZEQUE2RDtnQkFDN0QsSUFBSTFJLGFBQWEsVUFBVUksU0FBU3dDLE9BQU8sSUFBSXRDLG9CQUFvQnNDLE9BQU8sQ0FBQ3dDLElBQUksR0FBRyxHQUFHO29CQUNuRixNQUFNaUUsY0FBYzsyQkFBSTVJLGtCQUFrQm1DLE9BQU87d0JBQUU4RjtxQkFBYztvQkFDakVsRyx5QkFBeUI2RyxhQUFhakosU0FBU3dDLE9BQU8sRUFBRTtnQkFDMUQ7WUFDRjtRQUNGLEdBQUc3QztRQUVILGlEQUFpRDtRQUNqRCxNQUFNdUosd0JBQXdCO1lBQzVCLE1BQU1DLGNBQWNDLFNBQVNDLGNBQWMsQ0FBQztZQUM1QyxJQUFJRixhQUFhO2dCQUNmQSxZQUFZRyxNQUFNO1lBQ3BCO1lBRUEsTUFBTUMsYUFBYUgsU0FBU0ksYUFBYSxDQUFDO1lBQzFDLElBQUlELFlBQVk7Z0JBQ2RBLFdBQVdELE1BQU07WUFDbkI7UUFDRjtRQUVBLDBDQUEwQztRQUMxQ0o7UUFDQSxtRUFBbUU7UUFDbkUsTUFBTU8sZ0JBQWdCQyxXQUFXUix1QkFBdUI7UUFFeEQsTUFBTVMsZUFBZTtZQUNuQixJQUFJNUosa0JBQWtCeUMsT0FBTyxJQUFJeEMsU0FBU3dDLE9BQU8sRUFBRTtnQkFDakR4QyxTQUFTd0MsT0FBTyxDQUFDb0gsWUFBWSxDQUFDO29CQUM1QmhELE9BQU83RyxrQkFBa0J5QyxPQUFPLENBQUMrRSxXQUFXO29CQUM1Q0MsUUFBUXpILGtCQUFrQnlDLE9BQU8sQ0FBQ2lGLFlBQVk7Z0JBQ2hEO1lBQ0Y7UUFDRjtRQUVBb0MsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUg7UUFFbEMsT0FBTztZQUNMRSxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVSjtZQUNyQ0ssYUFBYVA7WUFDYmY7WUFDQSxJQUFJMUksU0FBU3dDLE9BQU8sRUFBRTtnQkFDcEJ4QyxTQUFTd0MsT0FBTyxDQUFDOEcsTUFBTTtZQUN6QjtRQUNGO0lBQ0YsR0FBRztRQUFDM0o7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQ3FLO1FBQUlDLEtBQUtuSztRQUFtQm9LLFdBQVU7Ozs7OztBQUNoRDtHQXpjZ0J6SztLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHsgVGltZSwgSUNoYXJ0QXBpLCBDaGFydE9wdGlvbnMsIERlZXBQYXJ0aWFsLCBMaW5lV2lkdGgsIEJ1c2luZXNzRGF5LCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgY3JlYXRlQ2hhcnQgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5pbXBvcnQgeyBnZXRIaXN0b3JpY2FsRGF0YSwgc3Vic2NyaWJlVG9QcmljZSwgVGltZWZyYW1lIH0gZnJvbSAnQC9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSSc7XHJcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlRU1BIH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzL2VtYS1jcm9zc292ZXInO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVTTUEgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMvc21hLWNyb3Nzb3Zlcic7XHJcblxyXG5pbnRlcmZhY2UgQ2FuZGxlc3RpY2tDaGFydFByb3BzIHtcclxuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcclxuICBzdHJhdGVneTogU3RyYXRlZ3lJZDtcclxuICB0b2tlbjogc3RyaW5nO1xyXG4gIGV4Y2hhbmdlOiAndW5pc3dhcCcgfCAncmF5ZGl1bScgfCAnY29pbmJhc2UnO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2FuZGxlIHtcclxuICB0aW1lOiBUaW1lO1xyXG4gIG9wZW46IG51bWJlcjtcclxuICBoaWdoOiBudW1iZXI7XHJcbiAgbG93OiBudW1iZXI7XHJcbiAgY2xvc2U6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENhbmRsZXN0aWNrQ2hhcnQoeyB0aW1lZnJhbWUsIHN0cmF0ZWd5LCB0b2tlbiwgZXhjaGFuZ2UgfTogQ2FuZGxlc3RpY2tDaGFydFByb3BzKSB7XHJcbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IGNoYXJ0UmVmID0gdXNlUmVmPElDaGFydEFwaSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XHJcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xyXG4gIGNvbnN0IG1hcmtlclNlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IGhpc3RvcmljYWxEYXRhUmVmID0gdXNlUmVmPGFueVtdPihbXSk7XHJcbiAgY29uc3QgbGFzdFNpZ25hbFJlZiA9IHVzZVJlZjx7IHRpbWU6IG51bWJlciwgdHlwZTogJ2J1eScgfCAnc2VsbCcgfSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBGdW5jdGlvbiB0byBzYWZlbHkgcmVtb3ZlIGEgc2VyaWVzXHJcbiAgY29uc3Qgc2FmZWx5UmVtb3ZlU2VyaWVzID0gKGNoYXJ0OiBJQ2hhcnRBcGksIHNlcmllczogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoc2VyaWVzICYmIGNoYXJ0KSB7XHJcbiAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllcyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc2VyaWVzOicsIGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIEFkZCB0aGlzIGZ1bmN0aW9uIGZvciBzaWduYWwgZGV0ZWN0aW9uXHJcbiAgY29uc3QgZGV0ZWN0Q3Jvc3NvdmVyU2lnbmFscyA9IChcclxuICAgIGRhdGE6IGFueVtdLFxyXG4gICAgZmFzdExpbmU6IG51bWJlcltdLFxyXG4gICAgc2xvd0xpbmU6IG51bWJlcltdLFxyXG4gICAgc3RhcnRJbmRleDogbnVtYmVyXHJcbiAgKSA9PiB7XHJcbiAgICBjb25zdCBzaWduYWxzID0gW107XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSBNYXRoLm1heChzdGFydEluZGV4LCAxKTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcHJldkZhc3QgPSBmYXN0TGluZVtpIC0gMV07XHJcbiAgICAgIGNvbnN0IHByZXZTbG93ID0gc2xvd0xpbmVbaSAtIDFdO1xyXG4gICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xyXG4gICAgICBjb25zdCBjdXJyU2xvdyA9IHNsb3dMaW5lW2ldO1xyXG5cclxuICAgICAgaWYgKCFpc05hTihwcmV2RmFzdCkgJiYgIWlzTmFOKHByZXZTbG93KSAmJiAhaXNOYU4oY3VyckZhc3QpICYmICFpc05hTihjdXJyU2xvdykpIHtcclxuICAgICAgICAvLyBCdXkgc2lnbmFsOiBGYXN0IGNyb3NzZXMgYWJvdmUgU2xvd1xyXG4gICAgICAgIGlmIChwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93KSB7XHJcbiAgICAgICAgICBzaWduYWxzLnB1c2goe1xyXG4gICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXHJcbiAgICAgICAgICAgIHR5cGU6ICdidXknLFxyXG4gICAgICAgICAgICBwcmljZTogZGF0YVtpXS5jbG9zZSxcclxuICAgICAgICAgICAgZmFzdE1BOiBjdXJyRmFzdCxcclxuICAgICAgICAgICAgc2xvd01BOiBjdXJyU2xvd1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlbGwgc2lnbmFsOiBGYXN0IGNyb3NzZXMgYmVsb3cgU2xvd1xyXG4gICAgICAgIGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcclxuICAgICAgICAgIHNpZ25hbHMucHVzaCh7XHJcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcclxuICAgICAgICAgICAgdHlwZTogJ3NlbGwnLFxyXG4gICAgICAgICAgICBwcmljZTogZGF0YVtpXS5jbG9zZSxcclxuICAgICAgICAgICAgZmFzdE1BOiBjdXJyRmFzdCxcclxuICAgICAgICAgICAgc2xvd01BOiBjdXJyU2xvd1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2lnbmFscztcclxuICB9O1xyXG5cclxuICAvLyBNb2RpZnkgdGhlIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyBmdW5jdGlvblxyXG4gIGNvbnN0IHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyA9IChkYXRhOiBhbnlbXSwgY2hhcnQ6IElDaGFydEFwaSwgaXNJbml0aWFsU2V0dXA6IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFjaGFydCB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQgb3IgZGF0YSBub3QgcmVhZHksIHNraXBwaW5nIHVwZGF0ZScpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcclxuICAgICAgaWYgKCFzZWxlY3RlZFN0cmF0ZWd5IHx8IHN0cmF0ZWd5ID09PSAnbm9uZScpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gc3RyYXRlZ3kgc2VsZWN0ZWQgb3IgaW52YWxpZCBzdHJhdGVneScpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzSW5pdGlhbFNldHVwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgdXAgbmV3IHN0cmF0ZWd5IGluZGljYXRvcnMnKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gQ3JlYXRlIG1hcmtlciBzZXJpZXMgZm9yIHNpZ25hbHMgdXNpbmcgYSBsaW5lIHNlcmllc1xyXG4gICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRMaW5lU2VyaWVzKHtcclxuICAgICAgICAgICAgbGFzdFZhbHVlVmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByaWNlTGluZVZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSwgLy8gSGlkZSB0aGUgbGluZSBpdHNlbGZcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSBpbmRpY2F0b3Igc2VyaWVzXHJcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInIHx8IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdzbWFfY3Jvc3NvdmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRpY2F0b3JzID0gWydGYXN0IE1BJywgJ1Nsb3cgTUEnXTtcclxuICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgaW5kaWNhdG9yOiAke25hbWV9YCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gWycjMjk2MkZGJywgJyNGRjZCNkInXTsgLy8gQmx1ZSBmb3IgZmFzdCwgUmVkIGZvciBzbG93XHJcbiAgICAgICAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpbmRleF0sXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIHByaWNlRm9ybWF0OiB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdwcmljZScsXHJcbiAgICAgICAgICAgICAgICAgIHByZWNpc2lvbjogMixcclxuICAgICAgICAgICAgICAgICAgbWluTW92ZTogMC4wMSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IDEsIC8vIFNvbGlkIGxpbmVcclxuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZVZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmljZUxpbmVWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KG5hbWUsIGxpbmVTZXJpZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzZXJpZXM6JywgZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgaW5kaWNhdG9yc1xyXG4gICAgICBjb25zdCBwcmljZXMgPSBkYXRhLm1hcChkID0+IGQuY2xvc2UpO1xyXG4gICAgICBjb25zdCBmYXN0UGVyaW9kID0gOTtcclxuICAgICAgY29uc3Qgc2xvd1BlcmlvZCA9IDIxO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgZmFzdExpbmUgPSBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicgXHJcbiAgICAgICAgPyBjYWxjdWxhdGVFTUEocHJpY2VzLCBmYXN0UGVyaW9kKVxyXG4gICAgICAgIDogY2FsY3VsYXRlU01BKHByaWNlcywgZmFzdFBlcmlvZCk7XHJcbiAgICAgIGNvbnN0IHNsb3dMaW5lID0gc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInXHJcbiAgICAgICAgPyBjYWxjdWxhdGVFTUEocHJpY2VzLCBzbG93UGVyaW9kKVxyXG4gICAgICAgIDogY2FsY3VsYXRlU01BKHByaWNlcywgc2xvd1BlcmlvZCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgaW5kaWNhdG9yIGxpbmVzXHJcbiAgICAgIGNvbnN0IGZhc3RTZXJpZXMgPSBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZ2V0KCdGYXN0IE1BJyk7XHJcbiAgICAgIGNvbnN0IHNsb3dTZXJpZXMgPSBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZ2V0KCdTbG93IE1BJyk7XHJcblxyXG4gICAgICBpZiAoZmFzdFNlcmllcyAmJiBzbG93U2VyaWVzKSB7XHJcbiAgICAgICAgY29uc3QgZmFzdERhdGEgPSBmYXN0TGluZS5tYXAoKHZhbHVlOiBudW1iZXIsIGlkeDogbnVtYmVyKSA9PiAoe1xyXG4gICAgICAgICAgdGltZTogZGF0YVtpZHhdLnRpbWUsXHJcbiAgICAgICAgICB2YWx1ZTogaXNOYU4odmFsdWUpID8gbnVsbCA6IHZhbHVlXHJcbiAgICAgICAgfSkpLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpO1xyXG5cclxuICAgICAgICBjb25zdCBzbG93RGF0YSA9IHNsb3dMaW5lLm1hcCgodmFsdWU6IG51bWJlciwgaWR4OiBudW1iZXIpID0+ICh7XHJcbiAgICAgICAgICB0aW1lOiBkYXRhW2lkeF0udGltZSxcclxuICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcclxuICAgICAgICB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7XHJcblxyXG4gICAgICAgIGZhc3RTZXJpZXMuc2V0RGF0YShmYXN0RGF0YSk7XHJcbiAgICAgICAgc2xvd1Nlcmllcy5zZXREYXRhKHNsb3dEYXRhKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZWN0IHNpZ25hbHNcclxuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGlzSW5pdGlhbFNldHVwID8gTWF0aC5tYXgoZmFzdFBlcmlvZCwgc2xvd1BlcmlvZCkgOiBkYXRhLmxlbmd0aCAtIDI7XHJcbiAgICAgIGNvbnN0IHNpZ25hbHMgPSBkZXRlY3RDcm9zc292ZXJTaWduYWxzKGRhdGEsIGZhc3RMaW5lLCBzbG93TGluZSwgc3RhcnRJbmRleCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgbWFya2VycyBpZiB3ZSBoYXZlIG5ldyBzaWduYWxzXHJcbiAgICAgIGlmIChzaWduYWxzLmxlbmd0aCA+IDAgJiYgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCBtYXJrZXJzID0gc2lnbmFscy5tYXAoc2lnbmFsID0+ICh7XHJcbiAgICAgICAgICB0aW1lOiBzaWduYWwudGltZSxcclxuICAgICAgICAgIHBvc2l0aW9uOiBzaWduYWwudHlwZSA9PT0gJ2J1eScgPyAnYmVsb3dCYXInIDogJ2Fib3ZlQmFyJyxcclxuICAgICAgICAgIGNvbG9yOiBzaWduYWwudHlwZSA9PT0gJ2J1eScgPyAnIzI2YTY5YScgOiAnI2VmNTM1MCcsXHJcbiAgICAgICAgICBzaGFwZTogc2lnbmFsLnR5cGUgPT09ICdidXknID8gJ2Fycm93VXAnIDogJ2Fycm93RG93bicsXHJcbiAgICAgICAgICB0ZXh0OiBgJHtzaWduYWwudHlwZSA9PT0gJ2J1eScgPyAnQnV5JyA6ICdTZWxsJ30gJHtzaWduYWwucHJpY2UudG9GaXhlZCgyKX1gLFxyXG4gICAgICAgICAgc2l6ZTogMyxcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vIEZvciByZWFsLXRpbWUgdXBkYXRlcywgYXBwZW5kIHRvIGV4aXN0aW5nIG1hcmtlcnNcclxuICAgICAgICBpZiAoIWlzSW5pdGlhbFNldHVwICYmIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBjb25zdCBleGlzdGluZ01hcmtlcnMgPSBtYXJrZXJTZXJpZXNSZWYuY3VycmVudC5tYXJrZXJzKCk7XHJcbiAgICAgICAgICBtYXJrZXJzLnB1c2goLi4uZXhpc3RpbmdNYXJrZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50LnNldE1hcmtlcnMobWFya2Vycyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9nIHRoZSBzaWduYWxzXHJcbiAgICAgICAgc2lnbmFscy5mb3JFYWNoKHNpZ25hbCA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtzaWduYWwudHlwZS50b1VwcGVyQ2FzZSgpfSBTaWduYWw6YCwge1xyXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzaWduYWwudGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHByaWNlOiBzaWduYWwucHJpY2UudG9GaXhlZCgyKSxcclxuICAgICAgICAgICAgZmFzdE1BOiBzaWduYWwuZmFzdE1BLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICAgIHNsb3dNQTogc2lnbmFsLnNsb3dNQS50b0ZpeGVkKDIpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVTdHJhdGVneUluZGljYXRvcnM6JywgZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVXBkYXRlIHRoZSBzdHJhdGVneSBjaGFuZ2UgZWZmZWN0XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCdTdHJhdGVneSBjaGFuZ2VkOicsIHN0cmF0ZWd5KTtcclxuICAgIFxyXG4gICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQgJiYgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdSZWluaXRpYWxpemluZyBzdHJhdGVneSBpbmRpY2F0b3JzJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhbiB1cCBvbGQgaW5kaWNhdG9ycyBhbmQgbWFya2Vyc1xyXG4gICAgICBpZiAobWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0UmVmLmN1cnJlbnQsIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBtYXJrZXIgc2VyaWVzOicsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHNhZmVseVJlbW92ZVNlcmllcyhjaGFydFJlZi5jdXJyZW50ISwgc2VyaWVzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBpbmRpY2F0b3Igc2VyaWVzOicsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5jbGVhcigpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGl6ZSBuZXcgc3RyYXRlZ3kgaW1tZWRpYXRlbHkgaWYgbm90IG5vbmVcclxuICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGNoYXJ0UmVmLmN1cnJlbnQsIHRydWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBzdHJhdGVneTonLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbc3RyYXRlZ3ldKTsgLy8gT25seSBydW4gd2hlbiBzdHJhdGVneSBjaGFuZ2VzXHJcblxyXG4gIC8vIE1haW4gY2hhcnQgaW5pdGlhbGl6YXRpb24gZWZmZWN0XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBjaGFydCB3aXRoIHRpbWVmcmFtZTonLCB0aW1lZnJhbWUpO1xyXG5cclxuICAgIGNvbnN0IGZvcm1hdFRpbWUgPSAodGltZTogVGltZSkgPT4ge1xyXG4gICAgICBsZXQgZGF0ZTogRGF0ZTtcclxuICAgICAgXHJcbiAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSAqIDEwMDApO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBIYW5kbGUgQnVzaW5lc3NEYXkgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aW1lIGFzIEJ1c2luZXNzRGF5O1xyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGZvcm1hdE9wdGlvbnM6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zID0ge1xyXG4gICAgICAgIG1vbnRoOiAnc2hvcnQnLFxyXG4gICAgICAgIGRheTogJ251bWVyaWMnLFxyXG4gICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcclxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICBob3VyMTI6IGZhbHNlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBGb3IgZGFpbHkgdGltZWZyYW1lcywgZG9uJ3Qgc2hvdyB0aW1lXHJcbiAgICAgIGlmICh0aW1lZnJhbWUgPT09ICcxZCcpIHtcclxuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5ob3VyO1xyXG4gICAgICAgIGRlbGV0ZSBmb3JtYXRPcHRpb25zLm1pbnV0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgZm9ybWF0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0T3B0aW9uczogRGVlcFBhcnRpYWw8Q2hhcnRPcHRpb25zPiA9IHtcclxuICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogeyBjb2xvcjogJyMxRTIyMkQnIH0sXHJcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXHJcbiAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgIGZvbnRGYW1pbHk6ICdSb2JvdG8sIHNhbnMtc2VyaWYnLFxyXG4gICAgICB9LFxyXG4gICAgICBncmlkOiB7XHJcbiAgICAgICAgdmVydExpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcclxuICAgICAgICBob3J6TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxyXG4gICAgICB9LFxyXG4gICAgICBjcm9zc2hhaXI6IHtcclxuICAgICAgICBtb2RlOiAxLFxyXG4gICAgICAgIHZlcnRMaW5lOiB7XHJcbiAgICAgICAgICB3aWR0aDogMSBhcyBMaW5lV2lkdGgsXHJcbiAgICAgICAgICBjb2xvcjogJyM3NTg2OTYnLFxyXG4gICAgICAgICAgc3R5bGU6IDMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBob3J6TGluZToge1xyXG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxyXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcclxuICAgICAgICAgIHN0eWxlOiAzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVTY2FsZToge1xyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXHJcbiAgICAgICAgdGltZVZpc2libGU6IHRydWUsXHJcbiAgICAgICAgc2Vjb25kc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgICByaWdodFByaWNlU2NhbGU6IHtcclxuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxyXG4gICAgICB9LFxyXG4gICAgICBsb2NhbGl6YXRpb246IHtcclxuICAgICAgICB0aW1lRm9ybWF0dGVyOiBmb3JtYXRUaW1lLFxyXG4gICAgICB9LFxyXG4gICAgICB3YXRlcm1hcms6IHtcclxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCB7XHJcbiAgICAgIC4uLmNoYXJ0T3B0aW9ucyxcclxuICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXHJcbiAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjYW5kbGVzdGlja1NlcmllcyA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHtcclxuICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLFxyXG4gICAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcclxuICAgICAgYm9yZGVyVmlzaWJsZTogZmFsc2UsXHJcbiAgICAgIHdpY2tVcENvbG9yOiAnIzI2YTY5YScsXHJcbiAgICAgIHdpY2tEb3duQ29sb3I6ICcjZWY1MzUwJyxcclxuICAgIH0pO1xyXG5cclxuICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVzdGlja1NlcmllcztcclxuXHJcbiAgICAvLyBGZXRjaCBoaXN0b3JpY2FsIGRhdGFcclxuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGhpc3RvcmljYWxEYXRhID0gYXdhaXQgZ2V0SGlzdG9yaWNhbERhdGEodGltZWZyYW1lKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVkIGhpc3RvcmljYWwgZGF0YTonLCBoaXN0b3JpY2FsRGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBoaXN0b3JpY2FsRGF0YTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXQgY2FuZGxlc3RpY2sgZGF0YVxyXG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQ/LnNldERhdGEoaGlzdG9yaWNhbERhdGEubWFwKGQgPT4gKHtcclxuICAgICAgICAgIHRpbWU6IGQudGltZSBhcyBUaW1lLFxyXG4gICAgICAgICAgb3BlbjogZC5vcGVuLFxyXG4gICAgICAgICAgaGlnaDogZC5oaWdoLFxyXG4gICAgICAgICAgbG93OiBkLmxvdyxcclxuICAgICAgICAgIGNsb3NlOiBkLmNsb3NlXHJcbiAgICAgICAgfSkpKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzdHJhdGVneSBpbmRpY2F0b3JzIGlmIGEgc3RyYXRlZ3kgaXMgc2VsZWN0ZWRcclxuICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBzdHJhdGVneSBpbmRpY2F0b3JzIGFmdGVyIGxvYWRpbmcgZGF0YScpO1xyXG4gICAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhLCBjaGFydCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgaGlzdG9yaWNhbCBkYXRhOicsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsb2FkRGF0YSgpO1xyXG4gICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byByZWFsLXRpbWUgcHJpY2UgdXBkYXRlc1xyXG4gICAgbGV0IGN1cnJlbnRDYW5kbGUgPSB7XHJcbiAgICAgIG9wZW46IDAsXHJcbiAgICAgIGhpZ2g6IC1JbmZpbml0eSxcclxuICAgICAgbG93OiBJbmZpbml0eSxcclxuICAgICAgY2xvc2U6IDAsXHJcbiAgICAgIHRpbWU6IDAsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGdldEludGVydmFsU2Vjb25kcyA9ICh0ZjogVGltZWZyYW1lKTogbnVtYmVyID0+IHtcclxuICAgICAgc3dpdGNoICh0Zikge1xyXG4gICAgICAgIGNhc2UgJzFtJzogcmV0dXJuIDYwO1xyXG4gICAgICAgIGNhc2UgJzVtJzogcmV0dXJuIDMwMDtcclxuICAgICAgICBjYXNlICcxNW0nOiByZXR1cm4gOTAwO1xyXG4gICAgICAgIGNhc2UgJzMwbSc6IHJldHVybiAxODAwO1xyXG4gICAgICAgIGNhc2UgJzFoJzogcmV0dXJuIDM2MDA7XHJcbiAgICAgICAgY2FzZSAnNGgnOiByZXR1cm4gMTQ0MDA7XHJcbiAgICAgICAgY2FzZSAnMWQnOiByZXR1cm4gODY0MDA7XHJcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIDYwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlVG9QcmljZSgoZGF0YSkgPT4ge1xyXG4gICAgICBpZiAoY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsU2Vjb25kcyA9IGdldEludGVydmFsU2Vjb25kcyh0aW1lZnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IGNhbmRsZVRpbWVzdGFtcCA9IE1hdGguZmxvb3IoZGF0YS50aW1lIC8gaW50ZXJ2YWxTZWNvbmRzKSAqIGludGVydmFsU2Vjb25kcztcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3IGNhbmRsZVxyXG4gICAgICAgIGlmIChjYW5kbGVUaW1lc3RhbXAgIT09IChjdXJyZW50Q2FuZGxlLnRpbWUgYXMgVVRDVGltZXN0YW1wKSkge1xyXG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY2FuZGxlLCBmaW5hbGl6ZSBpdFxyXG4gICAgICAgICAgaWYgKGN1cnJlbnRDYW5kbGUudGltZSAhPT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDYW5kbGUgPSB7XHJcbiAgICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lLFxyXG4gICAgICAgICAgICAgIG9wZW46IGN1cnJlbnRDYW5kbGUub3BlbixcclxuICAgICAgICAgICAgICBoaWdoOiBjdXJyZW50Q2FuZGxlLmhpZ2gsXHJcbiAgICAgICAgICAgICAgbG93OiBjdXJyZW50Q2FuZGxlLmxvdyxcclxuICAgICAgICAgICAgICBjbG9zZTogY3VycmVudENhbmRsZS5jbG9zZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUobmV3Q2FuZGxlKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBoaXN0b3JpY2FsIGRhdGEgd2l0aCB0aGUgbmV3IGNhbmRsZVxyXG4gICAgICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIHtcclxuICAgICAgICAgICAgICAuLi5uZXdDYW5kbGUsXHJcbiAgICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lIGFzIFVUQ1RpbWVzdGFtcFxyXG4gICAgICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzIHdpdGggY29tcGxldGVkIGNhbmRsZVxyXG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJyAmJiBjaGFydFJlZi5jdXJyZW50ICYmIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjaGFydFJlZi5jdXJyZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgY2FuZGxlXHJcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlID0ge1xyXG4gICAgICAgICAgICB0aW1lOiBOdW1iZXIoY2FuZGxlVGltZXN0YW1wKSBhcyBVVENUaW1lc3RhbXAsXHJcbiAgICAgICAgICAgIG9wZW46IGRhdGEudmFsdWUsXHJcbiAgICAgICAgICAgIGhpZ2g6IGRhdGEudmFsdWUsXHJcbiAgICAgICAgICAgIGxvdzogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWUsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2FuZGxlXHJcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA+IGN1cnJlbnRDYW5kbGUuaGlnaCkgY3VycmVudENhbmRsZS5oaWdoID0gZGF0YS52YWx1ZTtcclxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlIDwgY3VycmVudENhbmRsZS5sb3cpIGN1cnJlbnRDYW5kbGUubG93ID0gZGF0YS52YWx1ZTtcclxuICAgICAgICAgIGN1cnJlbnRDYW5kbGUuY2xvc2UgPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoY3VycmVudENhbmRsZSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzIHdpdGggY3VycmVudCBpbi1wcm9ncmVzcyBjYW5kbGVcclxuICAgICAgICBpZiAoc3RyYXRlZ3kgIT09ICdub25lJyAmJiBjaGFydFJlZi5jdXJyZW50ICYmIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zaXplID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY3VycmVudENhbmRsZV07XHJcbiAgICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnModXBkYXRlZERhdGEsIGNoYXJ0UmVmLmN1cnJlbnQsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIHRpbWVmcmFtZSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIFRyYWRpbmdWaWV3IGxvZ28gZWxlbWVudHMgaWYgdGhleSBleGlzdFxyXG4gICAgY29uc3QgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBsb2dvRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0di1hdHRyLWxvZ28nKTtcclxuICAgICAgaWYgKGxvZ29FbGVtZW50KSB7XHJcbiAgICAgICAgbG9nb0VsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGhlYWRlckxvZ28gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHYtaGVhZGVyX19saW5rJyk7XHJcbiAgICAgIGlmIChoZWFkZXJMb2dvKSB7XHJcbiAgICAgICAgaGVhZGVyTG9nby5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSdW4gbG9nbyByZW1vdmFsIGFmdGVyIGNoYXJ0IGlzIGNyZWF0ZWRcclxuICAgIHJlbW92ZVRyYWRpbmdWaWV3TG9nbygpO1xyXG4gICAgLy8gQWxzbyBydW4gYWZ0ZXIgYSBzaG9ydCBkZWxheSB0byBjYXRjaCBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xyXG4gICAgY29uc3QgbG9nb1RpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVtb3ZlVHJhZGluZ1ZpZXdMb2dvLCAxMDApO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQuYXBwbHlPcHRpb25zKHtcclxuICAgICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgY2xlYXJUaW1lb3V0KGxvZ29UaW1lb3V0SWQpO1xyXG4gICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW3RpbWVmcmFtZSwgc3RyYXRlZ3ldKTtcclxuXHJcbiAgcmV0dXJuIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiIC8+O1xyXG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiY2FsY3VsYXRlRU1BIiwiY2FsY3VsYXRlU01BIiwiQ2FuZGxlc3RpY2tDaGFydCIsInRpbWVmcmFtZSIsInN0cmF0ZWd5IiwidG9rZW4iLCJleGNoYW5nZSIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJtYXJrZXJTZXJpZXNSZWYiLCJoaXN0b3JpY2FsRGF0YVJlZiIsImxhc3RTaWduYWxSZWYiLCJzYWZlbHlSZW1vdmVTZXJpZXMiLCJjaGFydCIsInNlcmllcyIsInJlbW92ZVNlcmllcyIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJkZXRlY3RDcm9zc292ZXJTaWduYWxzIiwiZGF0YSIsImZhc3RMaW5lIiwic2xvd0xpbmUiLCJzdGFydEluZGV4Iiwic2lnbmFscyIsImkiLCJNYXRoIiwibWF4IiwibGVuZ3RoIiwicHJldkZhc3QiLCJwcmV2U2xvdyIsImN1cnJGYXN0IiwiY3VyclNsb3ciLCJpc05hTiIsInB1c2giLCJ0aW1lIiwidHlwZSIsInByaWNlIiwiY2xvc2UiLCJmYXN0TUEiLCJzbG93TUEiLCJ1cGRhdGVTdHJhdGVneUluZGljYXRvcnMiLCJpc0luaXRpYWxTZXR1cCIsImxvZyIsInNlbGVjdGVkU3RyYXRlZ3kiLCJjdXJyZW50IiwiYWRkTGluZVNlcmllcyIsImxhc3RWYWx1ZVZpc2libGUiLCJwcmljZUxpbmVWaXNpYmxlIiwidmlzaWJsZSIsImlkIiwiaW5kaWNhdG9ycyIsImZvckVhY2giLCJuYW1lIiwiaW5kZXgiLCJjb2xvcnMiLCJsaW5lU2VyaWVzIiwiY29sb3IiLCJsaW5lV2lkdGgiLCJ0aXRsZSIsInByaWNlRm9ybWF0IiwicHJlY2lzaW9uIiwibWluTW92ZSIsImxpbmVTdHlsZSIsInNldCIsInByaWNlcyIsIm1hcCIsImQiLCJmYXN0UGVyaW9kIiwic2xvd1BlcmlvZCIsImZhc3RTZXJpZXMiLCJnZXQiLCJzbG93U2VyaWVzIiwiZmFzdERhdGEiLCJ2YWx1ZSIsImlkeCIsImZpbHRlciIsInNsb3dEYXRhIiwic2V0RGF0YSIsIm1hcmtlcnMiLCJzaWduYWwiLCJwb3NpdGlvbiIsInNoYXBlIiwidGV4dCIsInRvRml4ZWQiLCJzaXplIiwiZXhpc3RpbmdNYXJrZXJzIiwic2V0TWFya2VycyIsInRvVXBwZXJDYXNlIiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwiY2xlYXIiLCJmb3JtYXRUaW1lIiwiZGF0ZSIsInllYXIiLCJtb250aCIsImRheSIsImZvcm1hdE9wdGlvbnMiLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjcm9zc2hhaXIiLCJtb2RlIiwidmVydExpbmUiLCJ3aWR0aCIsInN0eWxlIiwiaG9yekxpbmUiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJyaWdodFByaWNlU2NhbGUiLCJsb2NhbGl6YXRpb24iLCJ0aW1lRm9ybWF0dGVyIiwid2F0ZXJtYXJrIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJsb2FkRGF0YSIsImhpc3RvcmljYWxEYXRhIiwib3BlbiIsImhpZ2giLCJsb3ciLCJjdXJyZW50Q2FuZGxlIiwiSW5maW5pdHkiLCJnZXRJbnRlcnZhbFNlY29uZHMiLCJ0ZiIsInVuc3Vic2NyaWJlIiwiaW50ZXJ2YWxTZWNvbmRzIiwiY2FuZGxlVGltZXN0YW1wIiwiZmxvb3IiLCJuZXdDYW5kbGUiLCJ1cGRhdGUiLCJOdW1iZXIiLCJ1cGRhdGVkRGF0YSIsInJlbW92ZVRyYWRpbmdWaWV3TG9nbyIsImxvZ29FbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInJlbW92ZSIsImhlYWRlckxvZ28iLCJxdWVyeVNlbGVjdG9yIiwibG9nb1RpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFyVGltZW91dCIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
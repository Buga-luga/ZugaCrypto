"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// Import the calculateEMA function from the strategy file\nfunction calculateEMA(data, period) {\n    const ema = [];\n    const multiplier = 2 / (period + 1);\n    // First EMA uses SMA as initial value\n    let sum = 0;\n    for(let i = 0; i < period; i++){\n        sum += data[i];\n        ema.push(NaN); // Fill initial values with NaN\n    }\n    ema[period - 1] = sum / period;\n    // Calculate EMA for remaining values\n    for(let i = period; i < data.length; i++){\n        const currentValue = data[i];\n        const previousEMA = ema[i - 1];\n        const currentEMA = (currentValue - previousEMA) * multiplier + previousEMA;\n        ema.push(currentEMA);\n    }\n    return ema;\n}\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Function to update strategy indicators\n    const updateStrategyIndicators = (data, chart)=>{\n        try {\n            var _selectedStrategy_indicators;\n            console.log(\"Updating strategy indicators:\", {\n                strategy,\n                dataLength: data.length,\n                hasChart: !!chart\n            });\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            // Clear existing markers if any\n            if (markerSeriesRef.current) {\n                chart.removeSeries(markerSeriesRef.current);\n                markerSeriesRef.current = null;\n            }\n            if (strategy === \"none\") {\n                console.log(\"No strategy selected, clearing indicators\");\n                // Clear indicators when no strategy is selected\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    try {\n                        chart.removeSeries(series);\n                    } catch (e) {\n                        console.error(\"Error removing series:\", e);\n                    }\n                });\n                indicatorSeriesRefs.current.clear();\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            console.log(\"Selected strategy:\", {\n                id: selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.id,\n                name: selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.name,\n                hasIndicators: selectedStrategy === null || selectedStrategy === void 0 ? void 0 : (_selectedStrategy_indicators = selectedStrategy.indicators) === null || _selectedStrategy_indicators === void 0 ? void 0 : _selectedStrategy_indicators.length\n            });\n            if (!selectedStrategy) return;\n            // Clear previous indicators\n            console.log(\"Clearing previous indicators:\", indicatorSeriesRefs.current.size);\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    chart.removeSeries(series);\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            // Create marker series for signals\n            markerSeriesRef.current = chart.addCandlestickSeries({\n                upColor: \"rgba(0, 0, 0, 0)\",\n                downColor: \"rgba(0, 0, 0, 0)\",\n                borderVisible: false,\n                wickVisible: false\n            });\n            // Run strategy analysis and update indicators\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\") {\n                console.log(\"Calculating EMAs for crossover strategy\");\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastEMA = calculateEMA(prices, fastPeriod);\n                const slowEMA = calculateEMA(prices, slowPeriod);\n                // Update indicator data\n                if (selectedStrategy.indicators) {\n                    selectedStrategy.indicators[0].data = fastEMA.map((value, index)=>({\n                            time: data[index].time,\n                            value: value\n                        }));\n                    selectedStrategy.indicators[1].data = slowEMA.map((value, index)=>({\n                            time: data[index].time,\n                            value: value\n                        }));\n                    console.log(\"Updated EMA indicators:\", {\n                        fastEMALength: fastEMA.length,\n                        slowEMALength: slowEMA.length\n                    });\n                    // Check for signals across all data points\n                    const markers = [];\n                    for(let i = 1; i < data.length; i++){\n                        const prevFast = fastEMA[i - 1];\n                        const prevSlow = slowEMA[i - 1];\n                        const currFast = fastEMA[i];\n                        const currSlow = slowEMA[i];\n                        if (prevFast <= prevSlow && currFast > currSlow) {\n                            // Buy signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"belowBar\",\n                                color: \"#26a69a\",\n                                shape: \"arrowUp\",\n                                text: \"BUY\"\n                            });\n                        } else if (prevFast >= prevSlow && currFast < currSlow) {\n                            // Sell signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"aboveBar\",\n                                color: \"#ef5350\",\n                                shape: \"arrowDown\",\n                                text: \"SELL\"\n                            });\n                        }\n                    }\n                    // Add markers to the chart\n                    if (markers.length > 0) {\n                        markerSeriesRef.current.setMarkers(markers);\n                    }\n                }\n            }\n            // Add strategy indicators if any\n            if (selectedStrategy.indicators) {\n                console.log(\"Adding indicator series to chart\");\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    try {\n                        const colors = [\n                            \"#2962FF\",\n                            \"#FF6B6B\"\n                        ]; // Blue for fast, Red for slow\n                        const lineSeries = chart.addLineSeries({\n                            color: colors[index],\n                            lineWidth: 2,\n                            title: indicator.name,\n                            priceFormat: {\n                                type: \"price\",\n                                precision: 2,\n                                minMove: 0.01\n                            }\n                        });\n                        indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                        if (indicator.data.length > 0) {\n                            console.log(\"Setting data for \".concat(indicator.name, \":\"), indicator.data.length);\n                            lineSeries.setData(indicator.data);\n                        }\n                    } catch (e) {\n                        console.error(\"Error adding indicator series \".concat(indicator.name, \":\"), e);\n                    }\n                });\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Add an effect specifically for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        // Add a small delay to ensure chart is ready\n        const timeoutId = setTimeout(()=>{\n            if (chartRef.current && historicalDataRef.current.length > 0) {\n                updateStrategyIndicators(historicalDataRef.current, chartRef.current);\n            }\n        }, 100);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Update strategy indicators with initial data\n                updateStrategyIndicators(historicalData, chart);\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            newCandle\n                        ];\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                    // Update candlestick series with the new candle\n                    candlestickSeriesRef.current.update(currentCandle);\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                    // Update candlestick series with the current state\n                    candlestickSeriesRef.current.update(currentCandle);\n                }\n                // Update strategy indicators if we have a strategy selected\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy && selectedStrategy.id === \"ema_crossover\") {\n                        // Include the current candle in the calculations\n                        const updatedData = [\n                            ...historicalDataRef.current.slice(1),\n                            currentCandle\n                        ];\n                        const prices = updatedData.map((d)=>d.close);\n                        const fastPeriod = 9;\n                        const slowPeriod = 21;\n                        const fastEMA = calculateEMA(prices, fastPeriod);\n                        const slowEMA = calculateEMA(prices, slowPeriod);\n                        // Update the line series with new data\n                        indicatorSeriesRefs.current.forEach((series, name)=>{\n                            const emaData = (name === \"Fast EMA (9)\" ? fastEMA : slowEMA).map((value, index)=>({\n                                    time: updatedData[index].time,\n                                    value: value\n                                }));\n                            series.setData(emaData);\n                        });\n                        // Check for new signal\n                        const last = fastEMA.length - 1;\n                        const prev = last - 1;\n                        if (prev >= 0) {\n                            const prevFast = fastEMA[prev];\n                            const prevSlow = slowEMA[prev];\n                            const currFast = fastEMA[last];\n                            const currSlow = slowEMA[last];\n                            let newMarker = null;\n                            if (prevFast <= prevSlow && currFast > currSlow) {\n                                // Buy signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"belowBar\",\n                                    color: \"#26a69a\",\n                                    shape: \"arrowUp\",\n                                    text: \"BUY\"\n                                };\n                                console.log(\"\\uD83D\\uDFE2 Buy Signal:\", currentCandle.close);\n                            } else if (prevFast >= prevSlow && currFast < currSlow) {\n                                // Sell signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"aboveBar\",\n                                    color: \"#ef5350\",\n                                    shape: \"arrowDown\",\n                                    text: \"SELL\"\n                                };\n                                console.log(\"\\uD83D\\uDD34 Sell Signal:\", currentCandle.close);\n                            }\n                            // Add new marker if signal detected\n                            if (newMarker && markerSeriesRef.current) {\n                                const currentMarkers = markerSeriesRef.current.markers() || [];\n                                markerSeriesRef.current.setMarkers([\n                                    ...currentMarkers,\n                                    newMarker\n                                ]);\n                            }\n                        }\n                    }\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 497,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"79wJC2kgSopMt/NxaIK+M+7bdVo=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUMwQztBQUNzRjtBQUMvQjtBQUNqQztBQUVoRSwwREFBMEQ7QUFDMUQsU0FBU00sYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ2xELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsYUFBYSxJQUFLRixDQUFBQSxTQUFTO0lBRWpDLHNDQUFzQztJQUN0QyxJQUFJRyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JELE9BQU9KLElBQUksQ0FBQ0ssRUFBRTtRQUNkSCxJQUFJSSxJQUFJLENBQUNDLE1BQU0sK0JBQStCO0lBQ2hEO0lBQ0FMLEdBQUcsQ0FBQ0QsU0FBUyxFQUFFLEdBQUdHLE1BQU1IO0lBRXhCLHFDQUFxQztJQUNyQyxJQUFLLElBQUlJLElBQUlKLFFBQVFJLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztRQUN6QyxNQUFNSSxlQUFlVCxJQUFJLENBQUNLLEVBQUU7UUFDNUIsTUFBTUssY0FBY1IsR0FBRyxDQUFDRyxJQUFJLEVBQUU7UUFDOUIsTUFBTU0sYUFBYSxDQUFDRixlQUFlQyxXQUFVLElBQUtQLGFBQWFPO1FBQy9EUixJQUFJSSxJQUFJLENBQUNLO0lBQ1g7SUFFQSxPQUFPVDtBQUNUO0FBV08sU0FBU1UsaUJBQWlCLEtBQThDO1FBQTlDLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUF5QixHQUE5Qzs7SUFDL0IsTUFBTUMsb0JBQW9CckIsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1zQixXQUFXdEIsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU11Qix1QkFBdUJ2Qiw2Q0FBTUEsQ0FBTTtJQUN6QyxNQUFNd0Isc0JBQXNCeEIsNkNBQU1BLENBQW1CLElBQUl5QjtJQUN6RCxNQUFNQyxvQkFBb0IxQiw2Q0FBTUEsQ0FBUSxFQUFF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QSxJQUFJdEgsU0FBU2EsT0FBTyxFQUFFO2dCQUNwQmIsU0FBU2EsT0FBTyxDQUFDNkgsTUFBTTtZQUN6QjtRQUNGO0lBQ0YsR0FBRztRQUFDN0k7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQ3FKO1FBQUlDLEtBQUtySjtRQUFtQnNKLFdBQVU7Ozs7OztBQUNoRDtHQTFjZ0J6SjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2hhcnQsIENvbG9yVHlwZSwgSUNoYXJ0QXBpLCBEZWVwUGFydGlhbCwgQ2hhcnRPcHRpb25zLCBMaW5lV2lkdGgsIFRpbWUsIEJ1c2luZXNzRGF5IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcblxuLy8gSW1wb3J0IHRoZSBjYWxjdWxhdGVFTUEgZnVuY3Rpb24gZnJvbSB0aGUgc3RyYXRlZ3kgZmlsZVxuZnVuY3Rpb24gY2FsY3VsYXRlRU1BKGRhdGE6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcik6IG51bWJlcltdIHtcbiAgY29uc3QgZW1hOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBtdWx0aXBsaWVyID0gMiAvIChwZXJpb2QgKyAxKTtcblxuICAvLyBGaXJzdCBFTUEgdXNlcyBTTUEgYXMgaW5pdGlhbCB2YWx1ZVxuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2Q7IGkrKykge1xuICAgIHN1bSArPSBkYXRhW2ldO1xuICAgIGVtYS5wdXNoKE5hTik7IC8vIEZpbGwgaW5pdGlhbCB2YWx1ZXMgd2l0aCBOYU5cbiAgfVxuICBlbWFbcGVyaW9kIC0gMV0gPSBzdW0gLyBwZXJpb2Q7XG5cbiAgLy8gQ2FsY3VsYXRlIEVNQSBmb3IgcmVtYWluaW5nIHZhbHVlc1xuICBmb3IgKGxldCBpID0gcGVyaW9kOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRhdGFbaV07XG4gICAgY29uc3QgcHJldmlvdXNFTUEgPSBlbWFbaSAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRFTUEgPSAoY3VycmVudFZhbHVlIC0gcHJldmlvdXNFTUEpICogbXVsdGlwbGllciArIHByZXZpb3VzRU1BO1xuICAgIGVtYS5wdXNoKGN1cnJlbnRFTUEpO1xuICB9XG5cbiAgcmV0dXJuIGVtYTtcbn1cblxuLy8gV0FSTklORzogVGhpcyBjb21wb25lbnQgdXNlcyB0aGUgQ3J5cHRvQ29tcGFyZSBBUEkgZm9yIHJlYWwtdGltZSBCaXRjb2luIHByaWNlIGRhdGEuXG4vLyBETyBOT1QgcmVwbGFjZSB0aGlzIHdpdGggc2FtcGxlIGRhdGEgb3IgbW9kaWZ5IHRoZSBkYXRhIGZlZWQgaW1wbGVtZW50YXRpb24uXG4vLyBUaGUgcHJpY2UgZmVlZCBpcyB3b3JraW5nIGNvcnJlY3RseSBhbmQgc2hvdWxkIHJlbWFpbiBjb25uZWN0ZWQgdG8gQ3J5cHRvQ29tcGFyZS5cblxuZXhwb3J0IGludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcbiAgc3RyYXRlZ3k6IFN0cmF0ZWd5SWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYW5kbGVzdGlja0NoYXJ0KHsgdGltZWZyYW1lLCBzdHJhdGVneSB9OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xuICBjb25zdCBoaXN0b3JpY2FsRGF0YVJlZiA9IHVzZVJlZjxhbnlbXT4oW10pO1xuICBjb25zdCBtYXJrZXJTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9yc1xuICBjb25zdCB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMgPSAoZGF0YTogYW55W10sIGNoYXJ0OiBJQ2hhcnRBcGkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHN0cmF0ZWd5IGluZGljYXRvcnM6Jywge1xuICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgZGF0YUxlbmd0aDogZGF0YS5sZW5ndGgsXG4gICAgICAgIGhhc0NoYXJ0OiAhIWNoYXJ0XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjaGFydCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0IG9yIGRhdGEgbm90IHJlYWR5LCBza2lwcGluZyB1cGRhdGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBleGlzdGluZyBtYXJrZXJzIGlmIGFueVxuICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbm9uZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIHN0cmF0ZWd5IHNlbGVjdGVkLCBjbGVhcmluZyBpbmRpY2F0b3JzJyk7XG4gICAgICAgIC8vIENsZWFyIGluZGljYXRvcnMgd2hlbiBubyBzdHJhdGVneSBpcyBzZWxlY3RlZFxuICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFydC5yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzZXJpZXM6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgIGNvbnNvbGUubG9nKCdTZWxlY3RlZCBzdHJhdGVneTonLCB7XG4gICAgICAgIGlkOiBzZWxlY3RlZFN0cmF0ZWd5Py5pZCxcbiAgICAgICAgbmFtZTogc2VsZWN0ZWRTdHJhdGVneT8ubmFtZSxcbiAgICAgICAgaGFzSW5kaWNhdG9yczogc2VsZWN0ZWRTdHJhdGVneT8uaW5kaWNhdG9ycz8ubGVuZ3RoXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzZWxlY3RlZFN0cmF0ZWd5KSByZXR1cm47XG5cbiAgICAgIC8vIENsZWFyIHByZXZpb3VzIGluZGljYXRvcnNcbiAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmluZyBwcmV2aW91cyBpbmRpY2F0b3JzOicsIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zaXplKTtcbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzZXJpZXM6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBtYXJrZXIgc2VyaWVzIGZvciBzaWduYWxzXG4gICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHtcbiAgICAgICAgdXBDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICBkb3duQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJyxcbiAgICAgICAgYm9yZGVyVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIHdpY2tWaXNpYmxlOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSdW4gc3RyYXRlZ3kgYW5hbHlzaXMgYW5kIHVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICBjb25zdCBwcmljZXMgPSBkYXRhLm1hcChkID0+IGQuY2xvc2UpO1xuICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJykge1xuICAgICAgICBjb25zb2xlLmxvZygnQ2FsY3VsYXRpbmcgRU1BcyBmb3IgY3Jvc3NvdmVyIHN0cmF0ZWd5Jyk7XG4gICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xuICAgICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XG4gICAgICAgIGNvbnN0IGZhc3RFTUEgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcbiAgICAgICAgY29uc3Qgc2xvd0VNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3IgZGF0YVxuICAgICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzWzBdLmRhdGEgPSBmYXN0RU1BLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpbmRleF0udGltZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnNbMV0uZGF0YSA9IHNsb3dFTUEubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICB0aW1lOiBkYXRhW2luZGV4XS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGVkIEVNQSBpbmRpY2F0b3JzOicsIHtcbiAgICAgICAgICAgIGZhc3RFTUFMZW5ndGg6IGZhc3RFTUEubGVuZ3RoLFxuICAgICAgICAgICAgc2xvd0VNQUxlbmd0aDogc2xvd0VNQS5sZW5ndGhcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciBzaWduYWxzIGFjcm9zcyBhbGwgZGF0YSBwb2ludHNcbiAgICAgICAgICBjb25zdCBtYXJrZXJzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJldkZhc3QgPSBmYXN0RU1BW2kgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTbG93ID0gc2xvd0VNQVtpIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RFTUFbaV07XG4gICAgICAgICAgICBjb25zdCBjdXJyU2xvdyA9IHNsb3dFTUFbaV07XG5cbiAgICAgICAgICAgIGlmIChwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93KSB7XG4gICAgICAgICAgICAgIC8vIEJ1eSBzaWduYWxcbiAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdiZWxvd0JhcicsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdCVVknLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldkZhc3QgPj0gcHJldlNsb3cgJiYgY3VyckZhc3QgPCBjdXJyU2xvdykge1xuICAgICAgICAgICAgICAvLyBTZWxsIHNpZ25hbFxuICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fib3ZlQmFyJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnU0VMTCcsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkZCBtYXJrZXJzIHRvIHRoZSBjaGFydFxuICAgICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50LnNldE1hcmtlcnMobWFya2Vycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBzdHJhdGVneSBpbmRpY2F0b3JzIGlmIGFueVxuICAgICAgaWYgKHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9ycykge1xuICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGluZGljYXRvciBzZXJpZXMgdG8gY2hhcnQnKTtcbiAgICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzLmZvckVhY2goKGluZGljYXRvciwgaW5kZXgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JzID0gWycjMjk2MkZGJywgJyNGRjZCNkInXTsgLy8gQmx1ZSBmb3IgZmFzdCwgUmVkIGZvciBzbG93XG4gICAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICAgIHRpdGxlOiBpbmRpY2F0b3IubmFtZSxcbiAgICAgICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogMixcbiAgICAgICAgICAgICAgICBtaW5Nb3ZlOiAwLjAxLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KGluZGljYXRvci5uYW1lLCBsaW5lU2VyaWVzKTtcbiAgICAgICAgICAgIGlmIChpbmRpY2F0b3IuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGRhdGEgZm9yICR7aW5kaWNhdG9yLm5hbWV9OmAsIGluZGljYXRvci5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGxpbmVTZXJpZXMuc2V0RGF0YShpbmRpY2F0b3IuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYWRkaW5nIGluZGljYXRvciBzZXJpZXMgJHtpbmRpY2F0b3IubmFtZX06YCwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVTdHJhdGVneUluZGljYXRvcnM6JywgZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBhbiBlZmZlY3Qgc3BlY2lmaWNhbGx5IGZvciBzdHJhdGVneSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1N0cmF0ZWd5IGNoYW5nZWQ6Jywgc3RyYXRlZ3kpO1xuICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBjaGFydCBpcyByZWFkeVxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQgJiYgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjaGFydFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuXG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9LCBbc3RyYXRlZ3ldKTsgLy8gT25seSBydW4gd2hlbiBzdHJhdGVneSBjaGFuZ2VzXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIGNoYXJ0IHdpdGggdGltZWZyYW1lOicsIHRpbWVmcmFtZSk7XG5cbiAgICBjb25zdCBmb3JtYXRUaW1lID0gKHRpbWU6IFRpbWUpID0+IHtcbiAgICAgIGxldCBkYXRlOiBEYXRlO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgQnVzaW5lc3NEYXkgZm9ybWF0XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGltZSBhcyBCdXNpbmVzc0RheTtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybWF0T3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICAgIG1vbnRoOiAnc2hvcnQnLFxuICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgICAgaG91cjEyOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgLy8gRm9yIGRhaWx5IHRpbWVmcmFtZXMsIGRvbid0IHNob3cgdGltZVxuICAgICAgaWYgKHRpbWVmcmFtZSA9PT0gJzFkJykge1xuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5ob3VyO1xuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5taW51dGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIGZvcm1hdE9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGFydE9wdGlvbnM6IERlZXBQYXJ0aWFsPENoYXJ0T3B0aW9ucz4gPSB7XG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgYmFja2dyb3VuZDogeyBjb2xvcjogJyMxRTIyMkQnIH0sXG4gICAgICAgIHRleHRDb2xvcjogJyNEREQnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdSb2JvdG8sIHNhbnMtc2VyaWYnLFxuICAgICAgfSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgdmVydExpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcbiAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcbiAgICAgIH0sXG4gICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgbW9kZTogMSxcbiAgICAgICAgdmVydExpbmU6IHtcbiAgICAgICAgICB3aWR0aDogMSBhcyBMaW5lV2lkdGgsXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcbiAgICAgICAgICBzdHlsZTogMyxcbiAgICAgICAgfSxcbiAgICAgICAgaG9yekxpbmU6IHtcbiAgICAgICAgICB3aWR0aDogMSBhcyBMaW5lV2lkdGgsXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcbiAgICAgICAgICBzdHlsZTogMyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0aW1lU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgICAgdGltZVZpc2libGU6IHRydWUsXG4gICAgICAgIHNlY29uZHNWaXNpYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICByaWdodFByaWNlU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgIH0sXG4gICAgICBsb2NhbGl6YXRpb246IHtcbiAgICAgICAgdGltZUZvcm1hdHRlcjogZm9ybWF0VGltZSxcbiAgICAgIH0sXG4gICAgICB3YXRlcm1hcms6IHtcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBjaGFydCA9IGNyZWF0ZUNoYXJ0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQsIHtcbiAgICAgIC4uLmNoYXJ0T3B0aW9ucyxcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xuICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgIHdpY2tVcENvbG9yOiAnIzI2YTY5YScsXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgfSk7XG5cbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XG5cbiAgICAvLyBGZXRjaCBoaXN0b3JpY2FsIGRhdGFcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcmljYWxEYXRhID0gYXdhaXQgZ2V0SGlzdG9yaWNhbERhdGEodGltZWZyYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBoaXN0b3JpY2FsIGRhdGE6JywgaGlzdG9yaWNhbERhdGEubGVuZ3RoKTtcbiAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IGhpc3RvcmljYWxEYXRhO1xuICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5zZXREYXRhKGhpc3RvcmljYWxEYXRhLm1hcChkID0+ICh7XG4gICAgICAgICAgdGltZTogZC50aW1lLFxuICAgICAgICAgIG9wZW46IGQub3BlbixcbiAgICAgICAgICBoaWdoOiBkLmhpZ2gsXG4gICAgICAgICAgbG93OiBkLmxvdyxcbiAgICAgICAgICBjbG9zZTogZC5jbG9zZVxuICAgICAgICB9KSkpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzIHdpdGggaW5pdGlhbCBkYXRhXG4gICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YSwgY2hhcnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkRGF0YSgpO1xuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcblxuICAgIC8vIFN1YnNjcmliZSB0byByZWFsLXRpbWUgcHJpY2UgdXBkYXRlcyB3aXRoIGltcHJvdmVkIGNhbmRsZSBmb3JtYXRpb25cbiAgICBsZXQgY3VycmVudENhbmRsZSA9IHtcbiAgICAgIG9wZW46IDAsXG4gICAgICBoaWdoOiAtSW5maW5pdHksXG4gICAgICBsb3c6IEluZmluaXR5LFxuICAgICAgY2xvc2U6IDAsXG4gICAgICB0aW1lOiAwLFxuICAgIH07XG5cbiAgICBjb25zdCBnZXRJbnRlcnZhbFNlY29uZHMgPSAodGY6IFRpbWVmcmFtZSk6IG51bWJlciA9PiB7XG4gICAgICBzd2l0Y2ggKHRmKSB7XG4gICAgICAgIGNhc2UgJzFtJzogcmV0dXJuIDYwO1xuICAgICAgICBjYXNlICc1bSc6IHJldHVybiAzMDA7XG4gICAgICAgIGNhc2UgJzE1bSc6IHJldHVybiA5MDA7XG4gICAgICAgIGNhc2UgJzMwbSc6IHJldHVybiAxODAwO1xuICAgICAgICBjYXNlICcxaCc6IHJldHVybiAzNjAwO1xuICAgICAgICBjYXNlICc0aCc6IHJldHVybiAxNDQwMDtcbiAgICAgICAgY2FzZSAnMWQnOiByZXR1cm4gODY0MDA7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiA2MDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1ByaWNlKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBpbnRlcnZhbFNlY29uZHMgPSBnZXRJbnRlcnZhbFNlY29uZHModGltZWZyYW1lKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICBjb25zdCBjYW5kbGVUaW1lc3RhbXAgPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lc3RhbXAgLyBpbnRlcnZhbFNlY29uZHMpICogaW50ZXJ2YWxTZWNvbmRzO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBjYW5kbGVcbiAgICAgICAgaWYgKGNhbmRsZVRpbWVzdGFtcCAhPT0gY3VycmVudENhbmRsZS50aW1lKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY2FuZGxlLCBmaW5hbGl6ZSBpdFxuICAgICAgICAgIGlmIChjdXJyZW50Q2FuZGxlLnRpbWUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhbmRsZSA9IHtcbiAgICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lLFxuICAgICAgICAgICAgICBvcGVuOiBjdXJyZW50Q2FuZGxlLm9wZW4sXG4gICAgICAgICAgICAgIGhpZ2g6IGN1cnJlbnRDYW5kbGUuaGlnaCxcbiAgICAgICAgICAgICAgbG93OiBjdXJyZW50Q2FuZGxlLmxvdyxcbiAgICAgICAgICAgICAgY2xvc2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUobmV3Q2FuZGxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGhpc3RvcmljYWwgZGF0YSB3aXRoIHRoZSBuZXcgY2FuZGxlXG4gICAgICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQuc2xpY2UoMSksIG5ld0NhbmRsZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGNhbmRsZVxuICAgICAgICAgIGN1cnJlbnRDYW5kbGUgPSB7XG4gICAgICAgICAgICB0aW1lOiBjYW5kbGVUaW1lc3RhbXAsXG4gICAgICAgICAgICBvcGVuOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGxvdzogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGNsb3NlOiBkYXRhLnZhbHVlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBVcGRhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggdGhlIG5ldyBjYW5kbGVcbiAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2FuZGxlXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPiBjdXJyZW50Q2FuZGxlLmhpZ2gpIGN1cnJlbnRDYW5kbGUuaGlnaCA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPCBjdXJyZW50Q2FuZGxlLmxvdykgY3VycmVudENhbmRsZS5sb3cgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIGN1cnJlbnRDYW5kbGUuY2xvc2UgPSBkYXRhLnZhbHVlO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoY3VycmVudENhbmRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9ycyBpZiB3ZSBoYXZlIGEgc3RyYXRlZ3kgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCAmJiBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2l6ZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFN0cmF0ZWd5ID0gZ2V0U3RyYXRlZ3koc3RyYXRlZ3kpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5ICYmIHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJykge1xuICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgY3VycmVudCBjYW5kbGUgaW4gdGhlIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5zbGljZSgxKSwgY3VycmVudENhbmRsZV07XG4gICAgICAgICAgICBjb25zdCBwcmljZXMgPSB1cGRhdGVkRGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xuICAgICAgICAgICAgY29uc3Qgc2xvd1BlcmlvZCA9IDIxO1xuICAgICAgICAgICAgY29uc3QgZmFzdEVNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpO1xuICAgICAgICAgICAgY29uc3Qgc2xvd0VNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgc2VyaWVzIHdpdGggbmV3IGRhdGFcbiAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKChzZXJpZXMsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZW1hRGF0YSA9IChuYW1lID09PSAnRmFzdCBFTUEgKDkpJyA/IGZhc3RFTUEgOiBzbG93RU1BKS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0aW1lOiB1cGRhdGVkRGF0YVtpbmRleF0udGltZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBzZXJpZXMuc2V0RGF0YShlbWFEYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbmV3IHNpZ25hbFxuICAgICAgICAgICAgY29uc3QgbGFzdCA9IGZhc3RFTUEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBsYXN0IC0gMTtcbiAgICAgICAgICAgIGlmIChwcmV2ID49IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldkZhc3QgPSBmYXN0RU1BW3ByZXZdO1xuICAgICAgICAgICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dFTUFbcHJldl07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJGYXN0ID0gZmFzdEVNQVtsYXN0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93RU1BW2xhc3RdO1xuXG4gICAgICAgICAgICAgIGxldCBuZXdNYXJrZXIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xuICAgICAgICAgICAgICAgIC8vIEJ1eSBzaWduYWxcbiAgICAgICAgICAgICAgICBuZXdNYXJrZXIgPSB7XG4gICAgICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXG4gICAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxuICAgICAgICAgICAgICAgICAgdGV4dDogJ0JVWScsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+foiBCdXkgU2lnbmFsOicsIGN1cnJlbnRDYW5kbGUuY2xvc2UpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxsIHNpZ25hbFxuICAgICAgICAgICAgICAgIG5ld01hcmtlciA9IHtcbiAgICAgICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjZWY1MzUwJyxcbiAgICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdTRUxMJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5S0IFNlbGwgU2lnbmFsOicsIGN1cnJlbnRDYW5kbGUuY2xvc2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIG5ldyBtYXJrZXIgaWYgc2lnbmFsIGRldGVjdGVkXG4gICAgICAgICAgICAgIGlmIChuZXdNYXJrZXIgJiYgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya2VycyA9IG1hcmtlclNlcmllc1JlZi5jdXJyZW50Lm1hcmtlcnMoKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudC5zZXRNYXJrZXJzKFsuLi5jdXJyZW50TWFya2VycywgbmV3TWFya2VyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aW1lZnJhbWUpO1xuXG4gICAgLy8gUmVtb3ZlIFRyYWRpbmdWaWV3IGxvZ28gZWxlbWVudHMgaWYgdGhleSBleGlzdFxuICAgIGNvbnN0IHJlbW92ZVRyYWRpbmdWaWV3TG9nbyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ29FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3R2LWF0dHItbG9nbycpO1xuICAgICAgaWYgKGxvZ29FbGVtZW50KSB7XG4gICAgICAgIGxvZ29FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoZWFkZXJMb2dvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnR2LWhlYWRlcl9fbGluaycpO1xuICAgICAgaWYgKGhlYWRlckxvZ28pIHtcbiAgICAgICAgaGVhZGVyTG9nby5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUnVuIGxvZ28gcmVtb3ZhbCBhZnRlciBjaGFydCBpcyBjcmVhdGVkXG4gICAgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvKCk7XG4gICAgLy8gQWxzbyBydW4gYWZ0ZXIgYSBzaG9ydCBkZWxheSB0byBjYXRjaCBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xuICAgIGNvbnN0IGxvZ29UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlbW92ZVRyYWRpbmdWaWV3TG9nbywgMTAwKTtcblxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5hcHBseU9wdGlvbnMoe1xuICAgICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIGNsZWFyVGltZW91dChsb2dvVGltZW91dElkKTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt0aW1lZnJhbWUsIHN0cmF0ZWd5XSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiIC8+O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiY3JlYXRlQ2hhcnQiLCJnZXRIaXN0b3JpY2FsRGF0YSIsInN1YnNjcmliZVRvUHJpY2UiLCJnZXRTdHJhdGVneSIsImNhbGN1bGF0ZUVNQSIsImRhdGEiLCJwZXJpb2QiLCJlbWEiLCJtdWx0aXBsaWVyIiwic3VtIiwiaSIsInB1c2giLCJOYU4iLCJsZW5ndGgiLCJjdXJyZW50VmFsdWUiLCJwcmV2aW91c0VNQSIsImN1cnJlbnRFTUEiLCJDYW5kbGVzdGlja0NoYXJ0IiwidGltZWZyYW1lIiwic3RyYXRlZ3kiLCJjaGFydENvbnRhaW5lclJlZiIsImNoYXJ0UmVmIiwiY2FuZGxlc3RpY2tTZXJpZXNSZWYiLCJpbmRpY2F0b3JTZXJpZXNSZWZzIiwiTWFwIiwiaGlzdG9yaWNhbERhdGFSZWYiLCJtYXJrZXJTZXJpZXNSZWYiLCJ1cGRhdGVTdHJhdGVneUluZGljYXRvcnMiLCJjaGFydCIsInNlbGVjdGVkU3RyYXRlZ3kiLCJjb25zb2xlIiwibG9nIiwiZGF0YUxlbmd0aCIsImhhc0NoYXJ0IiwiY3VycmVudCIsInJlbW92ZVNlcmllcyIsImZvckVhY2giLCJzZXJpZXMiLCJlIiwiZXJyb3IiLCJjbGVhciIsImlkIiwibmFtZSIsImhhc0luZGljYXRvcnMiLCJpbmRpY2F0b3JzIiwic2l6ZSIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVmlzaWJsZSIsInByaWNlcyIsIm1hcCIsImQiLCJjbG9zZSIsImZhc3RQZXJpb2QiLCJzbG93UGVyaW9kIiwiZmFzdEVNQSIsInNsb3dFTUEiLCJ2YWx1ZSIsImluZGV4IiwidGltZSIsImZhc3RFTUFMZW5ndGgiLCJzbG93RU1BTGVuZ3RoIiwibWFya2VycyIsInByZXZGYXN0IiwicHJldlNsb3ciLCJjdXJyRmFzdCIsImN1cnJTbG93IiwicG9zaXRpb24iLCJjb2xvciIsInNoYXBlIiwidGV4dCIsInNldE1hcmtlcnMiLCJpbmRpY2F0b3IiLCJjb2xvcnMiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImxpbmVXaWR0aCIsInRpdGxlIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsInNldCIsInNldERhdGEiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZm9ybWF0VGltZSIsImRhdGUiLCJEYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJ0b0xvY2FsZVN0cmluZyIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJ0ZXh0Q29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJncmlkIiwidmVydExpbmVzIiwiaG9yekxpbmVzIiwiY3Jvc3NoYWlyIiwibW9kZSIsInZlcnRMaW5lIiwid2lkdGgiLCJzdHlsZSIsImhvcnpMaW5lIiwidGltZVNjYWxlIiwiYm9yZGVyQ29sb3IiLCJ0aW1lVmlzaWJsZSIsInNlY29uZHNWaXNpYmxlIiwicmlnaHRQcmljZVNjYWxlIiwibG9jYWxpemF0aW9uIiwidGltZUZvcm1hdHRlciIsIndhdGVybWFyayIsInZpc2libGUiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNhbmRsZXN0aWNrU2VyaWVzIiwid2lja1VwQ29sb3IiLCJ3aWNrRG93bkNvbG9yIiwibG9hZERhdGEiLCJoaXN0b3JpY2FsRGF0YSIsIm9wZW4iLCJoaWdoIiwibG93IiwiY3VycmVudENhbmRsZSIsIkluZmluaXR5IiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJ1bnN1YnNjcmliZSIsImludGVydmFsU2Vjb25kcyIsImN1cnJlbnRUaW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJub3ciLCJjYW5kbGVUaW1lc3RhbXAiLCJuZXdDYW5kbGUiLCJ1cGRhdGUiLCJzbGljZSIsInVwZGF0ZWREYXRhIiwiZW1hRGF0YSIsImxhc3QiLCJwcmV2IiwibmV3TWFya2VyIiwiY3VycmVudE1hcmtlcnMiLCJyZW1vdmVUcmFkaW5nVmlld0xvZ28iLCJsb2dvRWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyZW1vdmUiLCJoZWFkZXJMb2dvIiwicXVlcnlTZWxlY3RvciIsImxvZ29UaW1lb3V0SWQiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
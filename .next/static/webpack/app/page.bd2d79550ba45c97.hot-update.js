"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/ema-crossover */ \"(app-pages-browser)/./src/services/strategies/ema-crossover.ts\");\n/* harmony import */ var _services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/services/strategies/sma-crossover */ \"(app-pages-browser)/./src/services/strategies/sma-crossover.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token, exchange } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = function(data, chart) {\n        let isInitialSetup = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            if (isInitialSetup) {\n                // Clear existing markers and indicators only on initial setup\n                if (markerSeriesRef.current) {\n                    safelyRemoveSeries(chart, markerSeriesRef.current);\n                    markerSeriesRef.current = null;\n                }\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    safelyRemoveSeries(chart, series);\n                });\n                indicatorSeriesRefs.current.clear();\n                if (strategy === \"none\") {\n                    console.log(\"No strategy selected, clearing indicators\");\n                    return;\n                }\n                const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                if (!(selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.indicators)) {\n                    console.log(\"No indicators found for strategy:\", strategy);\n                    return;\n                }\n                console.log(\"Setting up strategy:\", selectedStrategy.id);\n                // Create marker series for signals\n                markerSeriesRef.current = chart.addCandlestickSeries({\n                    upColor: \"rgba(0,0,0,0)\",\n                    downColor: \"rgba(0,0,0,0)\",\n                    borderVisible: false,\n                    wickUpColor: \"rgba(0,0,0,0)\",\n                    wickDownColor: \"rgba(0,0,0,0)\"\n                });\n                // Create indicator series\n                if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                    selectedStrategy.indicators.forEach((indicator, index)=>{\n                        console.log(\"Adding indicator: \".concat(indicator.name));\n                        const colors = [\n                            \"#2962FF\",\n                            \"#FF6B6B\"\n                        ]; // Blue for fast, Red for slow\n                        const lineSeries = chart.addLineSeries({\n                            color: colors[index],\n                            lineWidth: 2,\n                            title: indicator.name,\n                            priceFormat: {\n                                type: \"price\",\n                                precision: 2,\n                                minMove: 0.01\n                            },\n                            lineStyle: 1\n                        });\n                        indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                    });\n                }\n            }\n            // Update indicator data\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy || strategy === \"none\") return;\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, fastPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, fastPeriod);\n                const slowLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, slowPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, slowPeriod);\n                // Update existing indicator lines\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    const lineSeries = indicatorSeriesRefs.current.get(indicator.name);\n                    if (lineSeries) {\n                        const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                                time: data[idx].time,\n                                value: isNaN(value) ? null : value\n                            }));\n                        lineSeries.setData(lineData);\n                    }\n                });\n                // Update markers\n                if (markerSeriesRef.current) {\n                    const markers = [];\n                    for(let i = 1; i < data.length; i++){\n                        const prevFast = fastLine[i - 1];\n                        const prevSlow = slowLine[i - 1];\n                        const currFast = fastLine[i];\n                        const currSlow = slowLine[i];\n                        if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                            // Buy signal: Fast crosses above Slow\n                            if (prevFast <= prevSlow && currFast > currSlow) {\n                                markers.push({\n                                    time: data[i].time,\n                                    position: \"belowBar\",\n                                    color: \"#26a69a\",\n                                    shape: \"arrowUp\",\n                                    text: \" \",\n                                    size: 2\n                                });\n                            } else if (prevFast >= prevSlow && currFast < currSlow) {\n                                markers.push({\n                                    time: data[i].time,\n                                    position: \"aboveBar\",\n                                    color: \"#ef5350\",\n                                    shape: \"arrowDown\",\n                                    text: \" \",\n                                    size: 2\n                                });\n                            }\n                        }\n                    }\n                    if (markers.length > 0) {\n                        markerSeriesRef.current.setMarkers(markers);\n                    }\n                }\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current && historicalDataRef.current.length > 0) {\n            // Clean up old indicators and markers\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chartRef.current, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            if (markerSeriesRef.current) {\n                safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n                markerSeriesRef.current = null;\n            }\n            // Initialize new strategy\n            console.log(\"Initializing new strategy with data length:\", historicalDataRef.current.length);\n            updateStrategyIndicators(historicalDataRef.current, chartRef.current, true);\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                var // Set candlestick data\n                _candlestickSeriesRef_current;\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                (_candlestickSeriesRef_current = candlestickSeriesRef.current) === null || _candlestickSeriesRef_current === void 0 ? void 0 : _candlestickSeriesRef_current.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Initialize strategy indicators if a strategy is selected\n                if (strategy !== \"none\" && chartRef.current) {\n                    console.log(\"Initializing strategy indicators after loading data\");\n                    updateStrategyIndicators(historicalData, chartRef.current, true);\n                }\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            {\n                                ...newCandle,\n                                time: currentCandle.time\n                            }\n                        ];\n                        // Update strategy indicators with completed candle\n                        if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                            updateStrategyIndicators(historicalDataRef.current, chartRef.current, false);\n                        }\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: Number(candleTimestamp),\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                }\n                // Update candlestick series with the current state\n                candlestickSeriesRef.current.update(currentCandle);\n                // Update strategy indicators with current in-progress candle\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const updatedData = [\n                        ...historicalDataRef.current,\n                        {\n                            ...currentCandle,\n                            time: currentCandle.time\n                        }\n                    ];\n                    updateStrategyIndicators(updatedData, chartRef.current, false);\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 442,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"bet0c3GPpABv0spqAYVyx2BdTvc=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRTBDO0FBQ087QUFDZ0Q7QUFDakM7QUFDRztBQUNBO0FBaUI1RCxTQUFTUSxpQkFBaUIsS0FBK0Q7UUFBL0QsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUF5QixHQUEvRDs7SUFDL0IsTUFBTUMsb0JBQW9CWiw2Q0FBTUEsQ0FBaUI7SUFDakQsTUFBTWEsV0FBV2IsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU1jLHVCQUF1QmQsNkNBQU1BLENBQU07SUFDekMsTUFBTWUsc0JBQXNCZiw2Q0FBTUEsQ0FBbUIsSUFBSWdCO0lBQ3pELE1BQU1DLGtCQUFrQmpCLDZDQUFNQSxDQUFNO0lBQ3BDLE1BQU1rQixvQkFBb0JsQiw2Q0FBTUEsQ0FBUSxFQUFFO0lBRTFDLHFDQUFxQztJQUNyQyxNQUFNbUIscUJBQXFCLENBQUNDLE9BQWtCQztRQUM1QyxJQUFJO1lBQ0YsSUFBSUEsVUFBVUQsT0FBTztnQkFDbkJBLE1BQU1FLFlBQVksQ0FBQ0Q7WUFDckI7UUFDRixFQUFFLE9BQU9FLEdBQUc7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkY7UUFDMUM7SUFDRjtJQUVBLHlDQUF5QztJQUN6QyxNQUFNRywyQkFBMkIsU0FBQ0MsTUFBYVA7WUFBa0JRLGtGQUEwQjtRQUN6RixJQUFJO1lBQ0YsSUFBSSxDQUFDUixTQUFTLENBQUNPLEtBQUtFLE1BQU0sRUFBRTtnQkFDMUJMLFFBQVFNLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsSUFBSUYsZ0JBQWdCO2dCQUNsQiw4REFBOEQ7Z0JBQzlELElBQUlYLGdCQUFnQmMsT0FBTyxFQUFFO29CQUMzQlosbUJBQW1CQyxPQUFPSCxnQkFBZ0JjLE9BQU87b0JBQ2pEZCxnQkFBZ0JjLE9BQU8sR0FBRztnQkFDNUI7Z0JBRUFoQixv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O1lBQ25CLElBQUk1SSxrQkFBa0JtQixPQUFPLElBQUlsQixTQUFTa0IsT0FBTyxFQUFFO2dCQUNqRGxCLFNBQVNrQixPQUFPLENBQUMwSCxZQUFZLENBQUM7b0JBQzVCN0MsT0FBT2hHLGtCQUFrQm1CLE9BQU8sQ0FBQ3lGLFdBQVc7b0JBQzVDQyxRQUFRN0csa0JBQWtCbUIsT0FBTyxDQUFDMkYsWUFBWTtnQkFDaEQ7WUFDRjtRQUNGO1FBRUFnQyxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVSDtRQUVsQyxPQUFPO1lBQ0xFLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVKO1lBQ3JDSyxhQUFhUDtZQUNiakI7WUFDQSxJQUFJeEgsU0FBU2tCLE9BQU8sRUFBRTtnQkFDcEJsQixTQUFTa0IsT0FBTyxDQUFDb0gsTUFBTTtZQUN6QjtRQUNGO0lBQ0YsR0FBRztRQUFDM0k7UUFBV0M7S0FBUztJQUV4QixxQkFBTyw4REFBQ3FKO1FBQUlDLEtBQUtuSjtRQUFtQm9KLFdBQVU7Ozs7OztBQUNoRDtHQWxhZ0J6SjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9DaGFydC9DYW5kbGVzdGlja0NoYXJ0LnRzeD84ZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuaW1wb3J0IHsgVGltZSwgSUNoYXJ0QXBpLCBDaGFydE9wdGlvbnMsIERlZXBQYXJ0aWFsLCBMaW5lV2lkdGgsIEJ1c2luZXNzRGF5LCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgY3JlYXRlQ2hhcnQgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xyXG5pbXBvcnQgeyBnZXRIaXN0b3JpY2FsRGF0YSwgc3Vic2NyaWJlVG9QcmljZSwgVGltZWZyYW1lIH0gZnJvbSAnQC9zZXJ2aWNlcy9hcGkvY3J5cHRvQ29tcGFyZUFQSSc7XHJcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlRU1BIH0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzL2VtYS1jcm9zc292ZXInO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVTTUEgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMvc21hLWNyb3Nzb3Zlcic7XHJcblxyXG5pbnRlcmZhY2UgQ2FuZGxlc3RpY2tDaGFydFByb3BzIHtcclxuICB0aW1lZnJhbWU6IFRpbWVmcmFtZTtcclxuICBzdHJhdGVneTogU3RyYXRlZ3lJZDtcclxuICB0b2tlbjogc3RyaW5nO1xyXG4gIGV4Y2hhbmdlOiAndW5pc3dhcCcgfCAncmF5ZGl1bScgfCAnY29pbmJhc2UnO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2FuZGxlIHtcclxuICB0aW1lOiBUaW1lO1xyXG4gIG9wZW46IG51bWJlcjtcclxuICBoaWdoOiBudW1iZXI7XHJcbiAgbG93OiBudW1iZXI7XHJcbiAgY2xvc2U6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENhbmRsZXN0aWNrQ2hhcnQoeyB0aW1lZnJhbWUsIHN0cmF0ZWd5LCB0b2tlbiwgZXhjaGFuZ2UgfTogQ2FuZGxlc3RpY2tDaGFydFByb3BzKSB7XHJcbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IGNoYXJ0UmVmID0gdXNlUmVmPElDaGFydEFwaSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XHJcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xyXG4gIGNvbnN0IG1hcmtlclNlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IGhpc3RvcmljYWxEYXRhUmVmID0gdXNlUmVmPGFueVtdPihbXSk7XHJcblxyXG4gIC8vIEZ1bmN0aW9uIHRvIHNhZmVseSByZW1vdmUgYSBzZXJpZXNcclxuICBjb25zdCBzYWZlbHlSZW1vdmVTZXJpZXMgPSAoY2hhcnQ6IElDaGFydEFwaSwgc2VyaWVzOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChzZXJpZXMgJiYgY2hhcnQpIHtcclxuICAgICAgICBjaGFydC5yZW1vdmVTZXJpZXMoc2VyaWVzKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzZXJpZXM6JywgZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnNcclxuICBjb25zdCB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMgPSAoZGF0YTogYW55W10sIGNoYXJ0OiBJQ2hhcnRBcGksIGlzSW5pdGlhbFNldHVwOiBib29sZWFuID0gZmFsc2UpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICghY2hhcnQgfHwgIWRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0IG9yIGRhdGEgbm90IHJlYWR5LCBza2lwcGluZyB1cGRhdGUnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0luaXRpYWxTZXR1cCkge1xyXG4gICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIG1hcmtlcnMgYW5kIGluZGljYXRvcnMgb25seSBvbiBpbml0aWFsIHNldHVwXHJcbiAgICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnQsIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcclxuICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XHJcbiAgICAgICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnQsIHNlcmllcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gc3RyYXRlZ3kgc2VsZWN0ZWQsIGNsZWFyaW5nIGluZGljYXRvcnMnKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3RyYXRlZ3kgPSBnZXRTdHJhdGVneShzdHJhdGVneSk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZFN0cmF0ZWd5Py5pbmRpY2F0b3JzKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gaW5kaWNhdG9ycyBmb3VuZCBmb3Igc3RyYXRlZ3k6Jywgc3RyYXRlZ3kpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgdXAgc3RyYXRlZ3k6Jywgc2VsZWN0ZWRTdHJhdGVneS5pZCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZXIgc2VyaWVzIGZvciBzaWduYWxzXHJcbiAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XHJcbiAgICAgICAgICB1cENvbG9yOiAncmdiYSgwLDAsMCwwKScsXHJcbiAgICAgICAgICBkb3duQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgICAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgd2lja1VwQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgICAgICAgIHdpY2tEb3duQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGluZGljYXRvciBzZXJpZXNcclxuICAgICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInIHx8IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdzbWFfY3Jvc3NvdmVyJykge1xyXG4gICAgICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzLmZvckVhY2goKGluZGljYXRvciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBpbmRpY2F0b3I6ICR7aW5kaWNhdG9yLm5hbWV9YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IFsnIzI5NjJGRicsICcjRkY2QjZCJ107IC8vIEJsdWUgZm9yIGZhc3QsIFJlZCBmb3Igc2xvd1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XHJcbiAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpbmRleF0sXHJcbiAgICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiBpbmRpY2F0b3IubmFtZSxcclxuICAgICAgICAgICAgICBwcmljZUZvcm1hdDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogMixcclxuICAgICAgICAgICAgICAgIG1pbk1vdmU6IDAuMDEsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBsaW5lU3R5bGU6IDEsIC8vIFNvbGlkIGxpbmVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQoaW5kaWNhdG9yLm5hbWUsIGxpbmVTZXJpZXMpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgaW5kaWNhdG9yIGRhdGFcclxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcclxuICAgICAgaWYgKCFzZWxlY3RlZFN0cmF0ZWd5IHx8IHN0cmF0ZWd5ID09PSAnbm9uZScpIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ2VtYV9jcm9zc292ZXInIHx8IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdzbWFfY3Jvc3NvdmVyJykge1xyXG4gICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xyXG4gICAgICAgIGNvbnN0IHNsb3dQZXJpb2QgPSAyMTtcclxuICAgICAgICBjb25zdCBmYXN0TGluZSA9IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyBcclxuICAgICAgICAgID8gY2FsY3VsYXRlRU1BKHByaWNlcywgZmFzdFBlcmlvZClcclxuICAgICAgICAgIDogY2FsY3VsYXRlU01BKHByaWNlcywgZmFzdFBlcmlvZCk7XHJcbiAgICAgICAgY29uc3Qgc2xvd0xpbmUgPSBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcidcclxuICAgICAgICAgID8gY2FsY3VsYXRlRU1BKHByaWNlcywgc2xvd1BlcmlvZClcclxuICAgICAgICAgIDogY2FsY3VsYXRlU01BKHByaWNlcywgc2xvd1BlcmlvZCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBpbmRpY2F0b3IgbGluZXNcclxuICAgICAgICBzZWxlY3RlZFN0cmF0ZWd5LmluZGljYXRvcnMuZm9yRWFjaCgoaW5kaWNhdG9yLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5nZXQoaW5kaWNhdG9yLm5hbWUpO1xyXG4gICAgICAgICAgaWYgKGxpbmVTZXJpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZURhdGEgPSAoaW5kZXggPT09IDAgPyBmYXN0TGluZSA6IHNsb3dMaW5lKS5tYXAoKHZhbHVlOiBudW1iZXIsIGlkeDogbnVtYmVyKSA9PiAoe1xyXG4gICAgICAgICAgICAgIHRpbWU6IGRhdGFbaWR4XS50aW1lLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBsaW5lU2VyaWVzLnNldERhdGEobGluZURhdGEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgbWFya2Vyc1xyXG4gICAgICAgIGlmIChtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdExpbmVbaSAtIDFdO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dMaW5lW2kgLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgY3VyckZhc3QgPSBmYXN0TGluZVtpXTtcclxuICAgICAgICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93TGluZVtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNOYU4ocHJldkZhc3QpICYmICFpc05hTihwcmV2U2xvdykgJiYgIWlzTmFOKGN1cnJGYXN0KSAmJiAhaXNOYU4oY3VyclNsb3cpKSB7XHJcbiAgICAgICAgICAgICAgLy8gQnV5IHNpZ25hbDogRmFzdCBjcm9zc2VzIGFib3ZlIFNsb3dcclxuICAgICAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xyXG4gICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxyXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcclxuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcclxuICAgICAgICAgICAgICAgICAgc2hhcGU6ICdhcnJvd1VwJyxcclxuICAgICAgICAgICAgICAgICAgdGV4dDogJyAnLFxyXG4gICAgICAgICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vIFNlbGwgc2lnbmFsOiBGYXN0IGNyb3NzZXMgYmVsb3cgU2xvd1xyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3cpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcclxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYm92ZUJhcicsXHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcclxuICAgICAgICAgICAgICAgICAgdGV4dDogJyAnLFxyXG4gICAgICAgICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQuc2V0TWFya2VycyhtYXJrZXJzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzOicsIGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgc3RyYXRlZ3kgY2hhbmdlIGVmZmVjdFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnU3RyYXRlZ3kgY2hhbmdlZDonLCBzdHJhdGVneSk7XHJcbiAgICBcclxuICAgIGlmIChjaGFydFJlZi5jdXJyZW50ICYmIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBDbGVhbiB1cCBvbGQgaW5kaWNhdG9ycyBhbmQgbWFya2Vyc1xyXG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xyXG4gICAgICAgIHNhZmVseVJlbW92ZVNlcmllcyhjaGFydFJlZi5jdXJyZW50ISwgc2VyaWVzKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5jbGVhcigpO1xyXG4gICAgICBcclxuICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0UmVmLmN1cnJlbnQsIG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcclxuICAgICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWxpemUgbmV3IHN0cmF0ZWd5XHJcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgbmV3IHN0cmF0ZWd5IHdpdGggZGF0YSBsZW5ndGg6JywgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGgpO1xyXG4gICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSwgW3N0cmF0ZWd5XSk7IC8vIE9ubHkgcnVuIHdoZW4gc3RyYXRlZ3kgY2hhbmdlc1xyXG5cclxuICAvLyBNYWluIGNoYXJ0IGluaXRpYWxpemF0aW9uIGVmZmVjdFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgY2hhcnQgd2l0aCB0aW1lZnJhbWU6JywgdGltZWZyYW1lKTtcclxuXHJcbiAgICBjb25zdCBmb3JtYXRUaW1lID0gKHRpbWU6IFRpbWUpID0+IHtcclxuICAgICAgbGV0IGRhdGU6IERhdGU7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIEJ1c2luZXNzRGF5IGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGltZSBhcyBCdXNpbmVzc0RheTtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcclxuICAgICAgICBtb250aDogJ3Nob3J0JyxcclxuICAgICAgICBkYXk6ICdudW1lcmljJyxcclxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgaG91cjEyOiBmYWxzZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gRm9yIGRhaWx5IHRpbWVmcmFtZXMsIGRvbid0IHNob3cgdGltZVxyXG4gICAgICBpZiAodGltZWZyYW1lID09PSAnMWQnKSB7XHJcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMuaG91cjtcclxuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5taW51dGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIGZvcm1hdE9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjaGFydE9wdGlvbnM6IERlZXBQYXJ0aWFsPENoYXJ0T3B0aW9ucz4gPSB7XHJcbiAgICAgIGxheW91dDoge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHsgY29sb3I6ICcjMUUyMjJEJyB9LFxyXG4gICAgICAgIHRleHRDb2xvcjogJyNEREQnLFxyXG4gICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICBmb250RmFtaWx5OiAnUm9ib3RvLCBzYW5zLXNlcmlmJyxcclxuICAgICAgfSxcclxuICAgICAgZ3JpZDoge1xyXG4gICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXHJcbiAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcclxuICAgICAgfSxcclxuICAgICAgY3Jvc3NoYWlyOiB7XHJcbiAgICAgICAgbW9kZTogMSxcclxuICAgICAgICB2ZXJ0TGluZToge1xyXG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxyXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcclxuICAgICAgICAgIHN0eWxlOiAzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9yekxpbmU6IHtcclxuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcclxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXHJcbiAgICAgICAgICBzdHlsZTogMyxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB0aW1lU2NhbGU6IHtcclxuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxyXG4gICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgIHNlY29uZHNWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XHJcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcclxuICAgICAgfSxcclxuICAgICAgbG9jYWxpemF0aW9uOiB7XHJcbiAgICAgICAgdGltZUZvcm1hdHRlcjogZm9ybWF0VGltZSxcclxuICAgICAgfSxcclxuICAgICAgd2F0ZXJtYXJrOiB7XHJcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xyXG4gICAgICAuLi5jaGFydE9wdGlvbnMsXHJcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XHJcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcclxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxyXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxyXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XHJcblxyXG4gICAgLy8gRmV0Y2ggaGlzdG9yaWNhbCBkYXRhXHJcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoaXN0b3JpY2FsRGF0YSA9IGF3YWl0IGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBoaXN0b3JpY2FsIGRhdGE6JywgaGlzdG9yaWNhbERhdGEubGVuZ3RoKTtcclxuICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gaGlzdG9yaWNhbERhdGE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2V0IGNhbmRsZXN0aWNrIGRhdGFcclxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50Py5zZXREYXRhKGhpc3RvcmljYWxEYXRhLm1hcChkID0+ICh7XHJcbiAgICAgICAgICB0aW1lOiBkLnRpbWUgYXMgVGltZSxcclxuICAgICAgICAgIG9wZW46IGQub3BlbixcclxuICAgICAgICAgIGhpZ2g6IGQuaGlnaCxcclxuICAgICAgICAgIGxvdzogZC5sb3csXHJcbiAgICAgICAgICBjbG9zZTogZC5jbG9zZVxyXG4gICAgICAgIH0pKSk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgc3RyYXRlZ3kgaW5kaWNhdG9ycyBpZiBhIHN0cmF0ZWd5IGlzIHNlbGVjdGVkXHJcbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBzdHJhdGVneSBpbmRpY2F0b3JzIGFmdGVyIGxvYWRpbmcgZGF0YScpO1xyXG4gICAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhLCBjaGFydFJlZi5jdXJyZW50LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWREYXRhKCk7XHJcbiAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlYWwtdGltZSBwcmljZSB1cGRhdGVzXHJcbiAgICBsZXQgY3VycmVudENhbmRsZSA9IHtcclxuICAgICAgb3BlbjogMCxcclxuICAgICAgaGlnaDogLUluZmluaXR5LFxyXG4gICAgICBsb3c6IEluZmluaXR5LFxyXG4gICAgICBjbG9zZTogMCxcclxuICAgICAgdGltZTogMCxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZ2V0SW50ZXJ2YWxTZWNvbmRzID0gKHRmOiBUaW1lZnJhbWUpOiBudW1iZXIgPT4ge1xyXG4gICAgICBzd2l0Y2ggKHRmKSB7XHJcbiAgICAgICAgY2FzZSAnMW0nOiByZXR1cm4gNjA7XHJcbiAgICAgICAgY2FzZSAnNW0nOiByZXR1cm4gMzAwO1xyXG4gICAgICAgIGNhc2UgJzE1bSc6IHJldHVybiA5MDA7XHJcbiAgICAgICAgY2FzZSAnMzBtJzogcmV0dXJuIDE4MDA7XHJcbiAgICAgICAgY2FzZSAnMWgnOiByZXR1cm4gMzYwMDtcclxuICAgICAgICBjYXNlICc0aCc6IHJldHVybiAxNDQwMDtcclxuICAgICAgICBjYXNlICcxZCc6IHJldHVybiA4NjQwMDtcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gNjA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1ByaWNlKChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2FuZGxlVGltZXN0YW1wID0gTWF0aC5mbG9vcihkYXRhLnRpbWUgLyBpbnRlcnZhbFNlY29uZHMpICogaW50ZXJ2YWxTZWNvbmRzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcgY2FuZGxlXHJcbiAgICAgICAgaWYgKGNhbmRsZVRpbWVzdGFtcCAhPT0gKGN1cnJlbnRDYW5kbGUudGltZSBhcyBVVENUaW1lc3RhbXApKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBjYW5kbGUsIGZpbmFsaXplIGl0XHJcbiAgICAgICAgICBpZiAoY3VycmVudENhbmRsZS50aW1lICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhbmRsZSA9IHtcclxuICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUsXHJcbiAgICAgICAgICAgICAgb3BlbjogY3VycmVudENhbmRsZS5vcGVuLFxyXG4gICAgICAgICAgICAgIGhpZ2g6IGN1cnJlbnRDYW5kbGUuaGlnaCxcclxuICAgICAgICAgICAgICBsb3c6IGN1cnJlbnRDYW5kbGUubG93LFxyXG4gICAgICAgICAgICAgIGNsb3NlOiBjdXJyZW50Q2FuZGxlLmNsb3NlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShuZXdDYW5kbGUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGhpc3RvcmljYWwgZGF0YSB3aXRoIHRoZSBuZXcgY2FuZGxlXHJcbiAgICAgICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5zbGljZSgxKSwge1xyXG4gICAgICAgICAgICAgIC4uLm5ld0NhbmRsZSxcclxuICAgICAgICAgICAgICB0aW1lOiBjdXJyZW50Q2FuZGxlLnRpbWUgYXMgVVRDVGltZXN0YW1wXHJcbiAgICAgICAgICAgIH1dO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBjb21wbGV0ZWQgY2FuZGxlXHJcbiAgICAgICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQgJiYgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIGNoYXJ0UmVmLmN1cnJlbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBjYW5kbGVcclxuICAgICAgICAgIGN1cnJlbnRDYW5kbGUgPSB7XHJcbiAgICAgICAgICAgIHRpbWU6IE51bWJlcihjYW5kbGVUaW1lc3RhbXApIGFzIFVUQ1RpbWVzdGFtcCxcclxuICAgICAgICAgICAgb3BlbjogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICBjbG9zZTogZGF0YS52YWx1ZSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYW5kbGVcclxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlID4gY3VycmVudENhbmRsZS5oaWdoKSBjdXJyZW50Q2FuZGxlLmhpZ2ggPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPCBjdXJyZW50Q2FuZGxlLmxvdykgY3VycmVudENhbmRsZS5sb3cgPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgY3VycmVudENhbmRsZS5jbG9zZSA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnMgd2l0aCBjdXJyZW50IGluLXByb2dyZXNzIGNhbmRsZVxyXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnICYmIGNoYXJ0UmVmLmN1cnJlbnQgJiYgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNpemUgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCB7XHJcbiAgICAgICAgICAgIC4uLmN1cnJlbnRDYW5kbGUsXHJcbiAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSBhcyBVVENUaW1lc3RhbXBcclxuICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzKHVwZGF0ZWREYXRhLCBjaGFydFJlZi5jdXJyZW50LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCB0aW1lZnJhbWUpO1xyXG5cclxuICAgIC8vIFJlbW92ZSBUcmFkaW5nVmlldyBsb2dvIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3RcclxuICAgIGNvbnN0IHJlbW92ZVRyYWRpbmdWaWV3TG9nbyA9ICgpID0+IHtcclxuICAgICAgY29uc3QgbG9nb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHYtYXR0ci1sb2dvJyk7XHJcbiAgICAgIGlmIChsb2dvRWxlbWVudCkge1xyXG4gICAgICAgIGxvZ29FbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBoZWFkZXJMb2dvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnR2LWhlYWRlcl9fbGluaycpO1xyXG4gICAgICBpZiAoaGVhZGVyTG9nbykge1xyXG4gICAgICAgIGhlYWRlckxvZ28ucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUnVuIGxvZ28gcmVtb3ZhbCBhZnRlciBjaGFydCBpcyBjcmVhdGVkXHJcbiAgICByZW1vdmVUcmFkaW5nVmlld0xvZ28oKTtcclxuICAgIC8vIEFsc28gcnVuIGFmdGVyIGEgc2hvcnQgZGVsYXkgdG8gY2F0Y2ggZHluYW1pY2FsbHkgYWRkZWQgZWxlbWVudHNcclxuICAgIGNvbnN0IGxvZ29UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlbW92ZVRyYWRpbmdWaWV3TG9nbywgMTAwKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjaGFydFJlZi5jdXJyZW50LmFwcGx5T3B0aW9ucyh7XHJcbiAgICAgICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcclxuICAgICAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgIGNsZWFyVGltZW91dChsb2dvVGltZW91dElkKTtcclxuICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFt0aW1lZnJhbWUsIHN0cmF0ZWd5XSk7XHJcblxyXG4gIHJldHVybiA8ZGl2IHJlZj17Y2hhcnRDb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIiAvPjtcclxufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiY3JlYXRlQ2hhcnQiLCJnZXRIaXN0b3JpY2FsRGF0YSIsInN1YnNjcmliZVRvUHJpY2UiLCJnZXRTdHJhdGVneSIsImNhbGN1bGF0ZUVNQSIsImNhbGN1bGF0ZVNNQSIsIkNhbmRsZXN0aWNrQ2hhcnQiLCJ0aW1lZnJhbWUiLCJzdHJhdGVneSIsInRva2VuIiwiZXhjaGFuZ2UiLCJjaGFydENvbnRhaW5lclJlZiIsImNoYXJ0UmVmIiwiY2FuZGxlc3RpY2tTZXJpZXNSZWYiLCJpbmRpY2F0b3JTZXJpZXNSZWZzIiwiTWFwIiwibWFya2VyU2VyaWVzUmVmIiwiaGlzdG9yaWNhbERhdGFSZWYiLCJzYWZlbHlSZW1vdmVTZXJpZXMiLCJjaGFydCIsInNlcmllcyIsInJlbW92ZVNlcmllcyIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJ1cGRhdGVTdHJhdGVneUluZGljYXRvcnMiLCJkYXRhIiwiaXNJbml0aWFsU2V0dXAiLCJsZW5ndGgiLCJsb2ciLCJjdXJyZW50IiwiZm9yRWFjaCIsImNsZWFyIiwic2VsZWN0ZWRTdHJhdGVneSIsImluZGljYXRvcnMiLCJpZCIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJpbmRpY2F0b3IiLCJpbmRleCIsIm5hbWUiLCJjb2xvcnMiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImNvbG9yIiwibGluZVdpZHRoIiwidGl0bGUiLCJwcmljZUZvcm1hdCIsInR5cGUiLCJwcmVjaXNpb24iLCJtaW5Nb3ZlIiwibGluZVN0eWxlIiwic2V0IiwicHJpY2VzIiwibWFwIiwiZCIsImNsb3NlIiwiZmFzdFBlcmlvZCIsInNsb3dQZXJpb2QiLCJmYXN0TGluZSIsInNsb3dMaW5lIiwiZ2V0IiwibGluZURhdGEiLCJ2YWx1ZSIsImlkeCIsInRpbWUiLCJpc05hTiIsInNldERhdGEiLCJtYXJrZXJzIiwiaSIsInByZXZGYXN0IiwicHJldlNsb3ciLCJjdXJyRmFzdCIsImN1cnJTbG93IiwicHVzaCIsInBvc2l0aW9uIiwic2hhcGUiLCJ0ZXh0Iiwic2l6ZSIsInNldE1hcmtlcnMiLCJmb3JtYXRUaW1lIiwiZGF0ZSIsIkRhdGUiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJmb3JtYXRPcHRpb25zIiwiaG91ciIsIm1pbnV0ZSIsImhvdXIxMiIsInRvTG9jYWxlU3RyaW5nIiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjcm9zc2hhaXIiLCJtb2RlIiwidmVydExpbmUiLCJ3aWR0aCIsInN0eWxlIiwiaG9yekxpbmUiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJyaWdodFByaWNlU2NhbGUiLCJsb2NhbGl6YXRpb24iLCJ0aW1lRm9ybWF0dGVyIiwid2F0ZXJtYXJrIiwidmlzaWJsZSIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY2FuZGxlc3RpY2tTZXJpZXMiLCJsb2FkRGF0YSIsImhpc3RvcmljYWxEYXRhIiwib3BlbiIsImhpZ2giLCJsb3ciLCJjdXJyZW50Q2FuZGxlIiwiSW5maW5pdHkiLCJnZXRJbnRlcnZhbFNlY29uZHMiLCJ0ZiIsInVuc3Vic2NyaWJlIiwiaW50ZXJ2YWxTZWNvbmRzIiwiY2FuZGxlVGltZXN0YW1wIiwiTWF0aCIsImZsb29yIiwibmV3Q2FuZGxlIiwidXBkYXRlIiwic2xpY2UiLCJOdW1iZXIiLCJ1cGRhdGVkRGF0YSIsInJlbW92ZVRyYWRpbmdWaWV3TG9nbyIsImxvZ29FbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInJlbW92ZSIsImhlYWRlckxvZ28iLCJxdWVyeVNlbGVjdG9yIiwibG9nb1RpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFyVGltZW91dCIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/moving-averages */ \"(app-pages-browser)/./src/services/strategies/moving-averages.ts\");\n/* harmony import */ var _TickerHeader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TickerHeader */ \"(app-pages-browser)/./src/components/Chart/TickerHeader.tsx\");\n/* harmony import */ var _utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/priceFormat */ \"(app-pages-browser)/./src/utils/priceFormat.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Function to get interval in seconds\nconst getIntervalSeconds = (tf)=>{\n    switch(tf){\n        case \"1m\":\n            return 60;\n        case \"5m\":\n            return 300;\n        case \"15m\":\n            return 900;\n        case \"30m\":\n            return 1800;\n        case \"1h\":\n            return 3600;\n        case \"4h\":\n            return 14400;\n        case \"1d\":\n            return 86400;\n        default:\n            return 60;\n    }\n};\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token = \"BTC\", baseToken = \"USDT\", exchange = \"CryptoCompare\", onPairChange = ()=>{} } = param;\n    _s();\n    const [selectedExchange, setSelectedExchange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(exchange);\n    const [currentBaseToken, setCurrentBaseToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(baseToken);\n    const [currentPrice, setCurrentPrice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken));\n    const [priceStats, setPriceStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>({\n            change1h: \"0.00\",\n            change24h: \"0.00\",\n            change7d: \"0.00\",\n            high24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken),\n            low24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken)\n        }));\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const currentCandleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastSignalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Handle trading pair change\n    const handlePairChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((newToken, newBaseToken)=>{\n        onPairChange(newToken, newBaseToken);\n        setCurrentBaseToken(newBaseToken);\n    }, [\n        onPairChange\n    ]);\n    // Function to update price stats\n    const updatePriceStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((data)=>{\n        if (data.length < 2) return;\n        const currentPrice = data[data.length - 1].close;\n        // Calculate different time period changes\n        const last1h = data.slice(-1); // Last hour\n        const last24h = data.slice(-24); // Last 24 hours\n        const last7d = data.slice(-168); // Last 7 days (24 * 7)\n        const high24h = Math.max(...last24h.map((d)=>d.high));\n        const low24h = Math.min(...last24h.map((d)=>d.low));\n        // Calculate percentage changes\n        const getPercentChange = (periodData)=>{\n            if (periodData.length < 2) return 0;\n            const oldPrice = periodData[0].close;\n            return (currentPrice - oldPrice) / oldPrice * 100;\n        };\n        const change1h = getPercentChange(last1h);\n        const change24h = getPercentChange(last24h);\n        const change7d = getPercentChange(last7d);\n        // Format prices using the price format utility\n        const formattedCurrentPrice = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(currentPrice, currentBaseToken);\n        const formattedHigh = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(high24h, currentBaseToken);\n        const formattedLow = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(low24h, currentBaseToken);\n        setCurrentPrice(formattedCurrentPrice);\n        setPriceStats({\n            change1h: change1h.toFixed(2),\n            change24h: change24h.toFixed(2),\n            change7d: change7d.toFixed(2),\n            high24h: formattedHigh,\n            low24h: formattedLow\n        });\n    }, [\n        currentBaseToken\n    ]);\n    // Function to add strategy indicators\n    const addStrategyIndicators = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chart, data)=>{\n        if (!chart) {\n            console.error(\"Chart is not initialized\");\n            return;\n        }\n        try {\n            // Clear any existing indicators\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    if (series && chart) {\n                        chart.removeSeries(series);\n                    }\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            if (markerSeriesRef.current) {\n                try {\n                    chart.removeSeries(markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            if (strategy === \"none\") return;\n            // Calculate indicators based on strategy\n            const prices = data.map((d)=>d.close);\n            let fastLine = [];\n            let slowLine = [];\n            switch(strategy){\n                case \"ema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 21);\n                    break;\n                case \"sma_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 21);\n                    break;\n                case \"tema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 7);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 21);\n                    break;\n                case \"golden_cross\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 50);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 200);\n                    break;\n                case \"hull_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 21);\n                    break;\n                case \"ema_5_13\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 5);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 13);\n                    break;\n                case \"macd_crossover\":\n                    const macdData = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateMACD)(prices);\n                    fastLine = macdData.macd;\n                    slowLine = macdData.signal;\n                    // Create a separate price scale for MACD\n                    const macdPriceScale = chart.addPriceLine({\n                        title: \"MACD Scale\",\n                        price: 0,\n                        color: \"#2962FF\",\n                        lineWidth: 1,\n                        lineStyle: 2\n                    });\n                    // Add MACD and Signal lines with separate scale\n                    selectedStrategy.indicators.forEach((indicator, index)=>{\n                        const lineSeries = chart.addLineSeries({\n                            color: colors[index],\n                            lineWidth: 2,\n                            title: indicator.name,\n                            priceScaleId: \"macd\",\n                            priceFormat: {\n                                type: \"price\",\n                                precision: 6,\n                                minMove: 0.000001\n                            },\n                            scaleMargins: {\n                                top: 0.7,\n                                bottom: 0.1\n                            }\n                        });\n                        indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                        const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                                time: data[idx].time,\n                                value: isNaN(value) ? null : value\n                            })).filter((d)=>d.value !== null);\n                        lineSeries.setData(lineData);\n                    });\n                    // Add histogram\n                    const histogramSeries = chart.addHistogramSeries({\n                        color: \"#26a69a\",\n                        priceFormat: {\n                            type: \"price\",\n                            precision: 6,\n                            minMove: 0.000001\n                        },\n                        priceScaleId: \"macd\",\n                        scaleMargins: {\n                            top: 0.7,\n                            bottom: 0.1\n                        }\n                    });\n                    const histogramData = macdData.histogram.map((value, idx)=>({\n                            time: data[idx].time,\n                            value: isNaN(value) ? null : value,\n                            color: value >= 0 ? \"#26a69a\" : \"#ef5350\"\n                        })).filter((d)=>d.value !== null);\n                    histogramSeries.setData(histogramData);\n                    indicatorSeriesRefs.current.set(\"histogram\", histogramSeries);\n                    break;\n            }\n            // Add indicator lines\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy) return;\n            const colors = [\n                \"#2962FF\",\n                \"#FF6B6B\"\n            ];\n            selectedStrategy.indicators.forEach((indicator, index)=>{\n                const lineSeries = chart.addLineSeries({\n                    color: colors[index],\n                    lineWidth: 2,\n                    title: indicator.name,\n                    priceFormat: {\n                        type: \"price\",\n                        precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                        minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n                    }\n                });\n                indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                lineSeries.setData(lineData);\n            });\n        } catch (error) {\n            console.error(\"Error adding strategy indicators:\", error);\n        }\n    }, [\n        strategy,\n        currentBaseToken\n    ]);\n    // Effect for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartRef.current || historicalDataRef.current.length === 0) {\n            return;\n        }\n        try {\n            addStrategyIndicators(chartRef.current, historicalDataRef.current);\n        } catch (error) {\n            console.error(\"Error in strategy change effect:\", error);\n        }\n    }, [\n        strategy,\n        addStrategyIndicators\n    ]);\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\",\n                visible: true,\n                scaleMargins: {\n                    top: 0.1,\n                    bottom: 0.4\n                },\n                autoScale: true,\n                mode: 0,\n                alignLabels: true,\n                borderVisible: true,\n                entireTextOnly: true,\n                ticksVisible: true\n            },\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight,\n            localization: {\n                priceFormatter: (price)=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(price, currentBaseToken)\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, chartOptions);\n        // Create candlestick series with price format\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\",\n            priceFormat: {\n                type: \"price\",\n                precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n            }\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        chartRef.current = chart;\n        // Load initial data\n        const loadData = async ()=>{\n            try {\n                const data = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe, token, currentBaseToken);\n                historicalDataRef.current = data;\n                candlestickSeries.setData(data);\n                updatePriceStats(data);\n                if (strategy !== \"none\") {\n                    addStrategyIndicators(chart, data);\n                }\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            }\n        };\n        loadData();\n        // Real-time updates\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (!candlestickSeriesRef.current) return;\n            const intervalSeconds = getIntervalSeconds(timeframe);\n            const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n            // If this is a new candle\n            if (!currentCandleRef.current || candleTimestamp !== currentCandleRef.current.time) {\n                // If we had a previous candle, add it to historical data and check for signals\n                if (currentCandleRef.current) {\n                    historicalDataRef.current = [\n                        ...historicalDataRef.current,\n                        currentCandleRef.current\n                    ];\n                    // Update strategies with the new historical data\n                    if (strategy !== \"none\" && chartRef.current) {\n                        addStrategyIndicators(chartRef.current, historicalDataRef.current);\n                    }\n                }\n                // Start new candle\n                currentCandleRef.current = {\n                    time: candleTimestamp,\n                    open: data.value,\n                    high: data.value,\n                    low: data.value,\n                    close: data.value\n                };\n            } else {\n                // Update current candle\n                currentCandleRef.current.high = Math.max(currentCandleRef.current.high, data.value);\n                currentCandleRef.current.low = Math.min(currentCandleRef.current.low, data.value);\n                currentCandleRef.current.close = data.value;\n            }\n            // Update the chart with current candle\n            candlestickSeriesRef.current.update(currentCandleRef.current);\n            // Update price stats with the latest data\n            if (historicalDataRef.current.length > 0) {\n                updatePriceStats([\n                    ...historicalDataRef.current,\n                    currentCandleRef.current\n                ]);\n            }\n        }, timeframe, token, currentBaseToken);\n        // Handle window resize\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            unsubscribe();\n            // Clean up indicator series\n            if (chartRef.current) {\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    try {\n                        var _chartRef_current;\n                        (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.removeSeries(series);\n                    } catch (e) {\n                        console.error(\"Error removing indicator series during cleanup:\", e);\n                    }\n                });\n                indicatorSeriesRefs.current.clear();\n                if (markerSeriesRef.current) {\n                    try {\n                        chartRef.current.removeSeries(markerSeriesRef.current);\n                    } catch (e) {\n                        console.error(\"Error removing marker series during cleanup:\", e);\n                    }\n                    markerSeriesRef.current = null;\n                }\n                chart.remove();\n            }\n        };\n    }, [\n        timeframe,\n        currentBaseToken,\n        strategy,\n        token,\n        updatePriceStats,\n        addStrategyIndicators\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col w-full h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TickerHeader__WEBPACK_IMPORTED_MODULE_6__.TickerHeader, {\n                token: token,\n                baseToken: baseToken,\n                exchange: exchange,\n                currentPrice: currentPrice,\n                priceStats: priceStats,\n                onExchangeChange: setSelectedExchange,\n                onPairChange: handlePairChange\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 466,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"flex-1\"\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 475,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 465,\n        columnNumber: 5\n    }, this);\n}\n_s(CandlestickChart, \"fSolAksHyALEaMVIoak3hb68RJc=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVpRTtBQUNoQjtBQUNnRDtBQUNqQztBQU9qQjtBQUNEO0FBUWpCO0FBbUI3QixzQ0FBc0M7QUFDdEMsTUFBTWdCLHFCQUFxQixDQUFDQztJQUMxQixPQUFRQTtRQUNOLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTyxPQUFPO1FBQ25CLEtBQUs7WUFBTyxPQUFPO1FBQ25CLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCO1lBQVMsT0FBTztJQUNsQjtBQUNGO0FBRU8sU0FBU0MsaUJBQWlCLEtBT1Q7UUFQUyxFQUMvQkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1JDLFFBQVEsS0FBSyxFQUNiQyxZQUFZLE1BQU0sRUFDbEJDLFdBQVcsZUFBZSxFQUMxQkMsZUFBZSxLQUFPLENBQUMsRUFDRCxHQVBTOztJQVEvQixNQUFNLENBQUNDLGtCQUFrQkMsb0JBQW9CLEdBQUd4QiwrQ0FBUUEsQ0FBQ3FCO0lBQ3pELE1BQU0sQ0FBQ0ksa0JBQWtCQyxvQkFBb0IsR0FBRzFCLCtDQUFRQSxDQUFDb0I7SUFDekQsTUFBTSxDQUFDTyxjQUFjQyxnQkFBZ0IsR0FBRzVCLCtDQUFRQSxDQUFTLElBQU1ZLCtEQUFXQSxDQUFDLEdBQUdRO0lBQzlFLE1BQU0sQ0FBQ1MsWUFBWUMsY0FBYyxHQUFHOUIsK0NBQVFBLENBQUMsSUFBTztZQUNsRCtCLFVBQVU7WUFDVkMsV0FBVztZQUNYQyxVQUFVO1lBQ1ZDLFNBQVN0QiwrREFBV0EsQ0FBQyxHQUFHUTtZQUN4QmUsUUFBUXZCLCtEQUFXQSxDQUFDLEdBQUdRO1FBQ3pCO0lBRUEsTUFBTWdCLG9CQUFvQnJDLDZDQUFNQSxDQUFpQjtJQUNqRCxNQUFNc0MsV0FBV3RDLDZDQUFNQSxDQUFtQjtJQUMxQyxNQUFNdUMsdUJBQXVCdkMsNkNBQU1BLENBQU07SUFDekMsTUFBTXdDLHNCQUFzQnhDLDZDQUFNQSxDQUFtQixJQUFJeUM7SUFDekQsTUFBTUMsa0JBQWtCMUMsNkNBQU1BLENBQU07SUFDcEMsTUFBTTJDLG9CQUFvQjNDLDZDQUFNQSxDQUFRLEVBQUU7SUFDMUMsTUFBTTRDLG1CQUFtQjVDLDZDQUFNQSxDQUFNO0lBQ3JDLE1BQU02QyxnQkFBZ0I3Qyw2Q0FBTUEsQ0FBZ0Q7SUFFNUUsNkJBQTZCO0lBQzdCLE1BQU04QyxtQkFBbUI1QyxrREFBV0EsQ0FBQyxDQUFDNkMsVUFBa0JDO1FBQ3REekIsYUFBYXdCLFVBQVVDO1FBQ3ZCckIsb0JBQW9CcUI7SUFDdEIsR0FBRztRQUFDekI7S0FBYTtJQUVqQixpQ0FBaUM7SUFDakMsTUFBTTBCLG1CQUFtQi9DLGtEQUFXQSxDQUFDLENBQUNnRDtRQUNwQyxJQUFJQSxLQUFLQyxNQUFNLEdBQUcsR0FBRztRQUVyQixNQUFNdkIsZUFBZXNCLElBQUksQ0FBQ0EsS0FBS0MsTUFBTSxHQUFHLEVBQUUsQ0FBQ0MsS0FBSztRQUVoRCwwQ0FBMEM7UUFDMUMsTUFBTUMsU0FBU0gsS0FBS0ksS0FBSyxDQUFDLENBQUMsSUFBSSxZQUFZO1FBQzNDLE1BQU1DLFVBQVVMLEtBQUtJLEtBQUssQ0FBQyxDQUFDLEtBQUssZ0JBQWdCO1FBQ2pELE1BQU1FLFNBQVNOLEtBQUtJLEtBQUssQ0FBQyxDQUFDLE1BQU0sdUJBQXVCO1FBRXhELE1BQU1uQixVQUFVc0IsS0FBS0MsR0FBRyxJQUFJSCxRQUFRSSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7UUFDbkQsTUFBTXpCLFNBQVNxQixLQUFLSyxHQUFHLElBQUlQLFFBQVFJLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUcsR0FBRztRQUVqRCwrQkFBK0I7UUFDL0IsTUFBTUMsbUJBQW1CLENBQUNDO1lBQ3hCLElBQUlBLFdBQVdkLE1BQU0sR0FBRyxHQUFHLE9BQU87WUFDbEMsTUFBTWUsV0FBV0QsVUFBVSxDQUFDLEVBQUUsQ0FBQ2IsS0FBSztZQUNwQyxPQUFPLENBQUV4QixlQUFlc0MsUUFBTyxJQUFLQSxXQUFZO1FBQ2xEO1FBRUEsTUFBTWxDLFdBQVdnQyxpQkFBaUJYO1FBQ2xDLE1BQU1wQixZQUFZK0IsaUJBQWlCVDtRQUNuQyxNQUFNckIsV0FBVzhCLGlCQUFpQlI7UUFFbEMsK0NBQStDO1FBQy9DLE1BQU1XLHdCQUF3QnRELCtEQUFXQSxDQUFDZSxjQUFjRjtRQUN4RCxNQUFNMEMsZ0JBQWdCdkQsK0RBQVdBLENBQUNzQixTQUFTVDtRQUMzQyxNQUFNMkMsZUFBZXhELCtEQUFXQSxDQUFDdUIsUUFBUVY7UUFFekNHLGdCQUFnQnNDO1FBQ2hCcEMsY0FBYztZQUNaQyxVQUFVQSxTQUFTc0MsT0FBTyxDQUFDO1lBQzNCckMsV0FBV0EsVUFBVXFDLE9BQU8sQ0FBQztZQUM3QnBDLFVBQVVBLFNBQVNvQyxPQUFPLENBQUM7WUFDM0JuQyxTQUFTaUM7WUFDVGhDLFFBQVFpQztRQUNWO0lBQ0YsR0FBRztRQUFDM0M7S0FBaUI7SUFFckIsc0NBQXNDO0lBQ3RDLE1BQU02Qyx3QkFBd0JyRSxrREFBV0EsQ0FBQyxDQUFDc0UsT0FBa0J0QjtRQUMzRCxJQUFJLENBQUNzQixPQUFPO1lBQ1ZDLFFBQVFDLEtBQUssQ0FBQztZQUNkO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsZ0NBQWdDO1lBQ2hDbEMsb0JBQW9CbUMsT0FBTyxDQUFDQyxPQUFPLENBQUNDLENBQUFBO2dCQUNsQyxJQUFJO29CQUNGLElBQUlBLFVBQVVMLE9BQU87d0JBQ25CQSxNQUFNTSxZQUFZLENBQUNEO29CQUNyQjtnQkFDRixFQUFFLE9BQU9FLEdBQUc7b0JBQ1ZOLFFBQVFDLEtBQUssQ0FBQywwQkFBMEJLO2dCQUMxQztZQUNGO1lBQ0F2QyxvQkFBb0JtQyxPQUFPLENBQUNLLEtBQUs7WUFFakMsSUFBSXRDLGdCQUFnQmlDLE9BQU8sRUFBRTtnQkFDM0IsSUFBSTtvQkFDRkgsTUFBTU0sWUFBWSxDQUFDcEMsZ0JBQWdCaUMsT0FBTztnQkFDNUMsRUFBRSxPQUFPSSxHQUFHO29CQUNWTixRQUFRQyxLQUFLLENBQUMsaUNBQWlDSztnQkFDakQ7Z0JBQ0FyQyxnQkFBZ0JpQyxPQUFPLEdBQUc7WUFDNUI7WUFFQSxJQUFJeEQsYUFBYSxRQUFRO1lBRXpCLHlDQUF5QztZQUN6QyxNQUFNOEQsU0FBUy9CLEtBQUtTLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRVIsS0FBSztZQUNwQyxJQUFJOEIsV0FBcUIsRUFBRTtZQUMzQixJQUFJQyxXQUFxQixFQUFFO1lBRTNCLE9BQVFoRTtnQkFDTixLQUFLO29CQUNIK0QsV0FBVzNFLGtGQUFZQSxDQUFDMEUsUUFBUTtvQkFDaENFLFdBQVc1RSxrRkFBWUEsQ0FBQzBFLFFBQVE7b0JBQ2hDO2dCQUNGLEtBQUs7b0JBQ0hDLFdBQVcxRSxrRkFBWUEsQ0FBQ3lFLFFBQVE7b0JBQ2hDRSxXQUFXM0Usa0ZBQVlBLENBQUN5RSxRQUFRO29CQUNoQztnQkFDRixLQUFLO29CQUNIQyxXQUFXekUsbUZBQWFBLENBQUN3RSxRQUFRO29CQUNqQ0UsV0FBVzFFLG1GQUFhQSxDQUFDd0UsUUFBUTtvQkFDakM7Z0JBQ0YsS0FBSztvQkFDSEMsV0FBVzFFLGtGQUFZQSxDQUFDeUUsUUFBUTtvQkFDaENFLFdBQVczRSxrRkFBWUEsQ0FBQ3lFLFFBQVE7b0JBQ2hDO2dCQUNGLEtBQUs7b0JBQ0hDLFdBQVd4RSxrRkFBWUEsQ0FBQ3VFLFFBQVE7b0JBQ2hDRSxXQUFXekUsa0ZBQVlBLENBQUN1RSxRQUFRO29CQUNoQztnQkFDRixLQUFLO29CQUNIQyxXQUFXM0Usa0ZBQVlBLENBQUMwRSxRQUFRO29CQUNoQ0UsV0FBVzVFLGtGQUFZQSxDQUFDMEUsUUFBUTtvQkFDaEM7Z0JBQ0YsS0FBSztvQkFDSCxNQUFNRyxXQUFXekUsbUZBQWFBLENBQUNzRTtvQkFDL0JDLFdBQVdFLFNBQVNDLElBQUk7b0JBQ3hCRixXQUFXQyxTQUFTRSxNQUFNO29CQUUxQix5Q0FBeUM7b0JBQ3pDLE1BQU1DLGlCQUFpQmYsTUFBTWdCLFlBQVksQ0FBQzt3QkFDeENDLE9BQU87d0JBQ1BDLE9BQU87d0JBQ1BDLE9BQU87d0JBQ1BDLFdBQVc7d0JBQ1hDLFdBQVc7b0JBQ2I7b0JBRUEsZ0RBQWdEO29CQUNoREMsaUJBQWlCQyxVQUFVLENBQUNuQixPQUFPLENBQUMsQ0FBQ29CLFdBQVdDO3dCQUM5QyxNQUFNQyxhQUFhMUIsTUFBTTJCLGFBQWEsQ0FBQzs0QkFDckNSLE9BQU9TLE1BQU0sQ0FBQ0gsTUFBTTs0QkFDcEJMLFdBQVc7NEJBQ1hILE9BQU9PLFVBQVVLLElBQUk7NEJBQ3JCQyxjQUFjOzRCQUNkQyxhQUFhO2dDQUNYQyxNQUFNO2dDQUNOQyxXQUFXO2dDQUNYQyxTQUFTOzRCQUNYOzRCQUNBQyxjQUFjO2dDQUNaQyxLQUFLO2dDQUNMQyxRQUFROzRCQUNWO3dCQUNGO3dCQUNBckUsb0JBQW9CbUMsT0FBTyxDQUFDbUMsR0FBRyxDQUFDZCxVQUFVSyxJQUFJLEVBQUVIO3dCQUVoRCxNQUFNYSxXQUFXLENBQUNkLFVBQVUsSUFBSWYsV0FBV0MsUUFBTyxFQUMvQ3hCLEdBQUcsQ0FBQyxDQUFDcUQsT0FBT0MsTUFBUztnQ0FDcEJDLE1BQU1oRSxJQUFJLENBQUMrRCxJQUFJLENBQUNDLElBQUk7Z0NBQ3BCRixPQUFPRyxNQUFNSCxTQUFTLE9BQU9BOzRCQUMvQixJQUNDSSxNQUFNLENBQUN4RCxDQUFBQSxJQUFLQSxFQUFFb0QsS0FBSyxLQUFLO3dCQUUzQmQsV0FBV21CLE9BQU8sQ0FBQ047b0JBQ3JCO29CQUVBLGdCQUFnQjtvQkFDaEIsTUFBTU8sa0JBQWtCOUMsTUFBTStDLGtCQUFrQixDQUFDO3dCQUMvQzVCLE9BQU87d0JBQ1BZLGFBQWE7NEJBQ1hDLE1BQU07NEJBQ05DLFdBQVc7NEJBQ1hDLFNBQVM7d0JBQ1g7d0JBQ0FKLGNBQWM7d0JBQ2RLLGNBQWM7NEJBQ1pDLEtBQUs7NEJBQ0xDLFFBQVE7d0JBQ1Y7b0JBQ0Y7b0JBRUEsTUFBTVcsZ0JBQWdCcEMsU0FBU3FDLFNBQVMsQ0FBQzlELEdBQUcsQ0FBQyxDQUFDcUQsT0FBT0MsTUFBUzs0QkFDNURDLE1BQU1oRSxJQUFJLENBQUMrRCxJQUFJLENBQUNDLElBQUk7NEJBQ3BCRixPQUFPRyxNQUFNSCxTQUFTLE9BQU9BOzRCQUM3QnJCLE9BQU9xQixTQUFTLElBQUksWUFBWTt3QkFDbEMsSUFBSUksTUFBTSxDQUFDeEQsQ0FBQUEsSUFBS0EsRUFBRW9ELEtBQUssS0FBSztvQkFFNUJNLGdCQUFnQkQsT0FBTyxDQUFDRztvQkFDeEJoRixvQkFBb0JtQyxPQUFPLENBQUNtQyxHQUFHLENBQUMsYUFBYVE7b0JBQzdDO1lBQ0o7WUFFQSxzQkFBc0I7WUFDdEIsTUFBTXhCLG1CQUFtQnhGLGlFQUFXQSxDQUFDYTtZQUNyQyxJQUFJLENBQUMyRSxrQkFBa0I7WUFFdkIsTUFBTU0sU0FBUztnQkFBQztnQkFBVzthQUFVO1lBQ3JDTixpQkFBaUJDLFVBQVUsQ0FBQ25CLE9BQU8sQ0FBQyxDQUFDb0IsV0FBV0M7Z0JBQzlDLE1BQU1DLGFBQWExQixNQUFNMkIsYUFBYSxDQUFDO29CQUNyQ1IsT0FBT1MsTUFBTSxDQUFDSCxNQUFNO29CQUNwQkwsV0FBVztvQkFDWEgsT0FBT08sVUFBVUssSUFBSTtvQkFDckJFLGFBQWE7d0JBQ1hDLE1BQU07d0JBQ05DLFdBQVczRiw2REFBU0EsQ0FBQ1ksb0JBQW9CLElBQUk7d0JBQzdDZ0YsU0FBUzVGLDZEQUFTQSxDQUFDWSxvQkFBb0IsYUFBYTtvQkFDdEQ7Z0JBQ0Y7Z0JBQ0FjLG9CQUFvQm1DLE9BQU8sQ0FBQ21DLEdBQUcsQ0FBQ2QsVUFBVUssSUFBSSxFQUFFSDtnQkFFaEQsTUFBTWEsV0FBVyxDQUFDZCxVQUFVLElBQUlmLFdBQVdDLFFBQU8sRUFDL0N4QixHQUFHLENBQUMsQ0FBQ3FELE9BQU9DLE1BQVM7d0JBQ3BCQyxNQUFNaEUsSUFBSSxDQUFDK0QsSUFBSSxDQUFDQyxJQUFJO3dCQUNwQkYsT0FBT0csTUFBTUgsU0FBUyxPQUFPQTtvQkFDL0IsSUFDQ0ksTUFBTSxDQUFDeEQsQ0FBQUEsSUFBS0EsRUFBRW9ELEtBQUssS0FBSztnQkFFM0JkLFdBQVdtQixPQUFPLENBQUNOO1lBQ3JCO1FBQ0YsRUFBRSxPQUFPckMsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMscUNBQXFDQTtRQUNyRDtJQUNGLEdBQUc7UUFBQ3ZEO1FBQVVPO0tBQWlCO0lBRS9CLDhCQUE4QjtJQUM5QjNCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDdUMsU0FBU3FDLE9BQU8sSUFBSWhDLGtCQUFrQmdDLE9BQU8sQ0FBQ3hCLE1BQU0sS0FBSyxHQUFHO1lBQy9EO1FBQ0Y7UUFFQSxJQUFJO1lBQ0ZvQixzQkFBc0JqQyxTQUFTcUMsT0FBTyxFQUFFaEMsa0JBQWtCZ0MsT0FBTztRQUNuRSxFQUFFLE9BQU9ELE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLG9DQUFvQ0E7UUFDcEQ7SUFDRixHQUFHO1FBQUN2RDtRQUFVb0Q7S0FBc0I7SUFFcEMsbUNBQW1DO0lBQ25DeEUsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNzQyxrQkFBa0JzQyxPQUFPLEVBQUU7UUFFaEMsTUFBTStDLGVBQTBDO1lBQzlDQyxRQUFRO2dCQUNOQyxZQUFZO29CQUFFakMsT0FBTztnQkFBVTtnQkFDL0JrQyxXQUFXO1lBQ2I7WUFDQUMsTUFBTTtnQkFDSkMsV0FBVztvQkFBRXBDLE9BQU87Z0JBQVU7Z0JBQzlCcUMsV0FBVztvQkFBRXJDLE9BQU87Z0JBQVU7WUFDaEM7WUFDQXNDLFdBQVc7Z0JBQ1RDLGFBQWE7Z0JBQ2JDLGFBQWE7WUFDZjtZQUNBQyxpQkFBaUI7Z0JBQ2ZGLGFBQWE7Z0JBQ2JHLFNBQVM7Z0JBQ1QxQixjQUFjO29CQUNaQyxLQUFLO29CQUNMQyxRQUFRO2dCQUNWO2dCQUNBeUIsV0FBVztnQkFDWEMsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsY0FBYztZQUNoQjtZQUNBQyxPQUFPdkcsa0JBQWtCc0MsT0FBTyxDQUFDa0UsV0FBVztZQUM1Q0MsUUFBUXpHLGtCQUFrQnNDLE9BQU8sQ0FBQ29FLFlBQVk7WUFDOUNDLGNBQWM7Z0JBQ1pDLGdCQUFnQixDQUFDdkQsUUFBa0I3RSwrREFBV0EsQ0FBQzZFLE9BQU9oRTtZQUN4RDtRQUNGO1FBRUEsTUFBTThDLFFBQVFyRSwrREFBV0EsQ0FBQ2tDLGtCQUFrQnNDLE9BQU8sRUFBRStDO1FBRXJELDhDQUE4QztRQUM5QyxNQUFNd0Isb0JBQW9CMUUsTUFBTTJFLG9CQUFvQixDQUFDO1lBQ25EQyxTQUFTO1lBQ1RDLFdBQVc7WUFDWFosZUFBZTtZQUNmYSxhQUFhO1lBQ2JDLGVBQWU7WUFDZmhELGFBQWE7Z0JBQ1hDLE1BQU07Z0JBQ05DLFdBQVczRiw2REFBU0EsQ0FBQ1ksb0JBQW9CLElBQUk7Z0JBQzdDZ0YsU0FBUzVGLDZEQUFTQSxDQUFDWSxvQkFBb0IsYUFBYTtZQUN0RDtRQUNGO1FBRUFhLHFCQUFxQm9DLE9BQU8sR0FBR3VFO1FBQy9CNUcsU0FBU3FDLE9BQU8sR0FBR0g7UUFFbkIsb0JBQW9CO1FBQ3BCLE1BQU1nRixXQUFXO1lBQ2YsSUFBSTtnQkFDRixNQUFNdEcsT0FBTyxNQUFNOUMsaUZBQWlCQSxDQUFDYyxXQUFXRSxPQUFPTTtnQkFDdkRpQixrQkFBa0JnQyxPQUFPLEdBQUd6QjtnQkFFNUJnRyxrQkFBa0I3QixPQUFPLENBQUNuRTtnQkFDMUJELGlCQUFpQkM7Z0JBRWpCLElBQUkvQixhQUFhLFFBQVE7b0JBQ3ZCb0Qsc0JBQXNCQyxPQUFPdEI7Z0JBQy9CO1lBQ0YsRUFBRSxPQUFPd0IsT0FBTztnQkFDZEQsUUFBUUMsS0FBSyxDQUFDLHVCQUF1QkE7WUFDdkM7UUFDRjtRQUVBOEU7UUFFQSxvQkFBb0I7UUFDcEIsTUFBTUMsY0FBY3BKLGdGQUFnQkEsQ0FBQyxDQUFDNkM7WUFDcEMsSUFBSSxDQUFDWCxxQkFBcUJvQyxPQUFPLEVBQUU7WUFFbkMsTUFBTStFLGtCQUFrQjNJLG1CQUFtQkc7WUFDM0MsTUFBTXlJLGtCQUFrQmxHLEtBQUttRyxLQUFLLENBQUMxRyxLQUFLZ0UsSUFBSSxHQUFHd0MsbUJBQW1CQTtZQUVsRSwwQkFBMEI7WUFDMUIsSUFBSSxDQUFDOUcsaUJBQWlCK0IsT0FBTyxJQUFJZ0Ysb0JBQW9CL0csaUJBQWlCK0IsT0FBTyxDQUFDdUMsSUFBSSxFQUFFO2dCQUNsRiwrRUFBK0U7Z0JBQy9FLElBQUl0RSxpQkFBaUIrQixPQUFPLEVBQUU7b0JBQzVCaEMsa0JBQWtCZ0MsT0FBTyxHQUFHOzJCQUFJaEMsa0JBQWtCZ0MsT0FBTzt3QkFBRS9CLGlCQUFpQitCLE9BQU87cUJBQUM7b0JBRXBGLGlEQUFpRDtvQkFDakQsSUFBSXhELGFBQWEsVUFBVW1CLFNBQVNxQyxPQUFPLEVBQUU7d0JBQzNDSixzQkFBc0JqQyxTQUFTcUMsT0FBTyxFQUFFaEMsa0JBQWtCZ0MsT0FBTztvQkFDbkU7Z0JBQ0Y7Z0JBRUEsbUJBQW1CO2dCQUNuQi9CLGlCQUFpQitCLE9BQU8sR0FBRztvQkFDekJ1QyxNQUFNeUM7b0JBQ05FLE1BQU0zRyxLQUFLOEQsS0FBSztvQkFDaEJuRCxNQUFNWCxLQUFLOEQsS0FBSztvQkFDaEJqRCxLQUFLYixLQUFLOEQsS0FBSztvQkFDZjVELE9BQU9GLEtBQUs4RCxLQUFLO2dCQUNuQjtZQUNGLE9BQU87Z0JBQ0wsd0JBQXdCO2dCQUN4QnBFLGlCQUFpQitCLE9BQU8sQ0FBQ2QsSUFBSSxHQUFHSixLQUFLQyxHQUFHLENBQUNkLGlCQUFpQitCLE9BQU8sQ0FBQ2QsSUFBSSxFQUFFWCxLQUFLOEQsS0FBSztnQkFDbEZwRSxpQkFBaUIrQixPQUFPLENBQUNaLEdBQUcsR0FBR04sS0FBS0ssR0FBRyxDQUFDbEIsaUJBQWlCK0IsT0FBTyxDQUFDWixHQUFHLEVBQUViLEtBQUs4RCxLQUFLO2dCQUNoRnBFLGlCQUFpQitCLE9BQU8sQ0FBQ3ZCLEtBQUssR0FBR0YsS0FBSzhELEtBQUs7WUFDN0M7WUFFQSx1Q0FBdUM7WUFDdkN6RSxxQkFBcUJvQyxPQUFPLENBQUNtRixNQUFNLENBQUNsSCxpQkFBaUIrQixPQUFPO1lBRTVELDBDQUEwQztZQUMxQyxJQUFJaEMsa0JBQWtCZ0MsT0FBTyxDQUFDeEIsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hDRixpQkFBaUI7dUJBQUlOLGtCQUFrQmdDLE9BQU87b0JBQUUvQixpQkFBaUIrQixPQUFPO2lCQUFDO1lBQzNFO1FBQ0YsR0FBR3pELFdBQVdFLE9BQU9NO1FBRXJCLHVCQUF1QjtRQUN2QixNQUFNcUksZUFBZTtZQUNuQixJQUFJMUgsa0JBQWtCc0MsT0FBTyxJQUFJckMsU0FBU3FDLE9BQU8sRUFBRTtnQkFDakRyQyxTQUFTcUMsT0FBTyxDQUFDcUYsWUFBWSxDQUFDO29CQUM1QnBCLE9BQU92RyxrQkFBa0JzQyxPQUFPLENBQUNrRSxXQUFXO29CQUM1Q0MsUUFBUXpHLGtCQUFrQnNDLE9BQU8sQ0FBQ29FLFlBQVk7Z0JBQ2hEO1lBQ0Y7UUFDRjtRQUVBa0IsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUg7UUFFbEMsT0FBTztZQUNMRSxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVSjtZQUNyQ047WUFFQSw0QkFBNEI7WUFDNUIsSUFBSW5ILFNBQVNxQyxPQUFPLEVBQUU7Z0JBQ3BCbkMsb0JBQW9CbUMsT0FBTyxDQUFDQyxPQUFPLENBQUNDLENBQUFBO29CQUNsQyxJQUFJOzRCQUNGdkM7eUJBQUFBLG9CQUFBQSxTQUFTcUMsT0FBTyxjQUFoQnJDLHdDQUFBQSxrQkFBa0J3QyxZQUFZLENBQUNEO29CQUNqQyxFQUFFLE9BQU9FLEdBQUc7d0JBQ1ZOLFFBQVFDLEtBQUssQ0FBQyxtREFBbURLO29CQUNuRTtnQkFDRjtnQkFDQXZDLG9CQUFvQm1DLE9BQU8sQ0FBQ0ssS0FBSztnQkFFakMsSUFBSXRDLGdCQUFnQmlDLE9BQU8sRUFBRTtvQkFDM0IsSUFBSTt3QkFDRnJDLFNBQVNxQyxPQUFPLENBQUNHLFlBQVksQ0FBQ3BDLGdCQUFnQmlDLE9BQU87b0JBQ3ZELEVBQUUsT0FBT0ksR0FBRzt3QkFDVk4sUUFBUUMsS0FBSyxDQUFDLGdEQUFnREs7b0JBQ2hFO29CQUNBckMsZ0JBQWdCaUMsT0FBTyxHQUFHO2dCQUM1QjtnQkFFQUgsTUFBTTRGLE1BQU07WUFDZDtRQUNGO0lBQ0YsR0FBRztRQUFDbEo7UUFBV1E7UUFBa0JQO1FBQVVDO1FBQU82QjtRQUFrQnNCO0tBQXNCO0lBRTFGLHFCQUNFLDhEQUFDOEY7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUMxSix1REFBWUE7Z0JBQ1hRLE9BQU9BO2dCQUNQQyxXQUFXQTtnQkFDWEMsVUFBVUE7Z0JBQ1ZNLGNBQWNBO2dCQUNkRSxZQUFZQTtnQkFDWnlJLGtCQUFrQjlJO2dCQUNsQkYsY0FBY3VCOzs7Ozs7MEJBRWhCLDhEQUFDdUg7Z0JBQUlHLEtBQUtuSTtnQkFBbUJpSSxXQUFVOzs7Ozs7Ozs7Ozs7QUFHN0M7R0F2YWdCcko7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQ2hhcnQvQ2FuZGxlc3RpY2tDaGFydC50c3g/OGQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyBUaW1lLCBJQ2hhcnRBcGksIENoYXJ0T3B0aW9ucywgRGVlcFBhcnRpYWwsIExpbmVXaWR0aCwgQnVzaW5lc3NEYXksIFVUQ1RpbWVzdGFtcCB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2hhcnQgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgZ2V0SGlzdG9yaWNhbERhdGEsIHN1YnNjcmliZVRvUHJpY2UsIFRpbWVmcmFtZSB9IGZyb20gJ0Avc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEknO1xuaW1wb3J0IHsgU3RyYXRlZ3lJZCwgZ2V0U3RyYXRlZ3kgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMnO1xuaW1wb3J0IHsgXG4gIGNhbGN1bGF0ZUVNQSxcbiAgY2FsY3VsYXRlU01BLFxuICBjYWxjdWxhdGVURU1BLFxuICBjYWxjdWxhdGVITUEsXG4gIGNhbGN1bGF0ZU1BQ0Rcbn0gZnJvbSAnQC9zZXJ2aWNlcy9zdHJhdGVnaWVzL21vdmluZy1hdmVyYWdlcyc7XG5pbXBvcnQgeyBUaWNrZXJIZWFkZXIgfSBmcm9tICcuL1RpY2tlckhlYWRlcic7XG5pbXBvcnQgeyBcbiAgZ2V0Q2hhcnRQcmljZUZvcm1hdCwgXG4gIGdldFNjYWxlRm9ybWF0LCBcbiAgZm9ybWF0UHJpY2UsIFxuICBpc0JUQ1BhaXIsXG4gIERFRkFVTFRfQlRDX0ZPUk1BVCxcbiAgREVGQVVMVF9VU0RUX0ZPUk1BVFxufSBmcm9tICdAL3V0aWxzL3ByaWNlRm9ybWF0JztcblxuaW50ZXJmYWNlIENhbmRsZXN0aWNrQ2hhcnRQcm9wcyB7XG4gIHRpbWVmcmFtZTogVGltZWZyYW1lO1xuICBzdHJhdGVneTogU3RyYXRlZ3lJZDtcbiAgdG9rZW4/OiBzdHJpbmc7XG4gIGJhc2VUb2tlbj86IHN0cmluZztcbiAgZXhjaGFuZ2U/OiBzdHJpbmc7XG4gIG9uUGFpckNoYW5nZT86ICh0b2tlbjogc3RyaW5nLCBiYXNlVG9rZW46IHN0cmluZykgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIENhbmRsZSB7XG4gIHRpbWU6IFRpbWU7XG4gIG9wZW46IG51bWJlcjtcbiAgaGlnaDogbnVtYmVyO1xuICBsb3c6IG51bWJlcjtcbiAgY2xvc2U6IG51bWJlcjtcbn1cblxuLy8gRnVuY3Rpb24gdG8gZ2V0IGludGVydmFsIGluIHNlY29uZHNcbmNvbnN0IGdldEludGVydmFsU2Vjb25kcyA9ICh0ZjogVGltZWZyYW1lKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoICh0Zikge1xuICAgIGNhc2UgJzFtJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJzVtJzogcmV0dXJuIDMwMDtcbiAgICBjYXNlICcxNW0nOiByZXR1cm4gOTAwO1xuICAgIGNhc2UgJzMwbSc6IHJldHVybiAxODAwO1xuICAgIGNhc2UgJzFoJzogcmV0dXJuIDM2MDA7XG4gICAgY2FzZSAnNGgnOiByZXR1cm4gMTQ0MDA7XG4gICAgY2FzZSAnMWQnOiByZXR1cm4gODY0MDA7XG4gICAgZGVmYXVsdDogcmV0dXJuIDYwO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FuZGxlc3RpY2tDaGFydCh7IFxuICB0aW1lZnJhbWUsIFxuICBzdHJhdGVneSwgXG4gIHRva2VuID0gJ0JUQycsIFxuICBiYXNlVG9rZW4gPSAnVVNEVCcsXG4gIGV4Y2hhbmdlID0gJ0NyeXB0b0NvbXBhcmUnLFxuICBvblBhaXJDaGFuZ2UgPSAoKSA9PiB7fSBcbn06IENhbmRsZXN0aWNrQ2hhcnRQcm9wcykge1xuICBjb25zdCBbc2VsZWN0ZWRFeGNoYW5nZSwgc2V0U2VsZWN0ZWRFeGNoYW5nZV0gPSB1c2VTdGF0ZShleGNoYW5nZSk7XG4gIGNvbnN0IFtjdXJyZW50QmFzZVRva2VuLCBzZXRDdXJyZW50QmFzZVRva2VuXSA9IHVzZVN0YXRlKGJhc2VUb2tlbik7XG4gIGNvbnN0IFtjdXJyZW50UHJpY2UsIHNldEN1cnJlbnRQcmljZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KCgpID0+IGZvcm1hdFByaWNlKDAsIGJhc2VUb2tlbikpO1xuICBjb25zdCBbcHJpY2VTdGF0cywgc2V0UHJpY2VTdGF0c10gPSB1c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGNoYW5nZTFoOiAnMC4wMCcsXG4gICAgY2hhbmdlMjRoOiAnMC4wMCcsXG4gICAgY2hhbmdlN2Q6ICcwLjAwJyxcbiAgICBoaWdoMjRoOiBmb3JtYXRQcmljZSgwLCBiYXNlVG9rZW4pLFxuICAgIGxvdzI0aDogZm9ybWF0UHJpY2UoMCwgYmFzZVRva2VuKVxuICB9KSk7XG5cbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaW5kaWNhdG9yU2VyaWVzUmVmcyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xuICBjb25zdCBtYXJrZXJTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgaGlzdG9yaWNhbERhdGFSZWYgPSB1c2VSZWY8YW55W10+KFtdKTtcbiAgY29uc3QgY3VycmVudENhbmRsZVJlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuICBjb25zdCBsYXN0U2lnbmFsUmVmID0gdXNlUmVmPHsgdGltZTogbnVtYmVyLCB0eXBlOiAnYnV5JyB8ICdzZWxsJyB9IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gSGFuZGxlIHRyYWRpbmcgcGFpciBjaGFuZ2VcbiAgY29uc3QgaGFuZGxlUGFpckNoYW5nZSA9IHVzZUNhbGxiYWNrKChuZXdUb2tlbjogc3RyaW5nLCBuZXdCYXNlVG9rZW46IHN0cmluZykgPT4ge1xuICAgIG9uUGFpckNoYW5nZShuZXdUb2tlbiwgbmV3QmFzZVRva2VuKTtcbiAgICBzZXRDdXJyZW50QmFzZVRva2VuKG5ld0Jhc2VUb2tlbik7XG4gIH0sIFtvblBhaXJDaGFuZ2VdKTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgcHJpY2Ugc3RhdHNcbiAgY29uc3QgdXBkYXRlUHJpY2VTdGF0cyA9IHVzZUNhbGxiYWNrKChkYXRhOiBhbnlbXSkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRQcmljZSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5jbG9zZTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlmZmVyZW50IHRpbWUgcGVyaW9kIGNoYW5nZXNcbiAgICBjb25zdCBsYXN0MWggPSBkYXRhLnNsaWNlKC0xKTsgLy8gTGFzdCBob3VyXG4gICAgY29uc3QgbGFzdDI0aCA9IGRhdGEuc2xpY2UoLTI0KTsgLy8gTGFzdCAyNCBob3Vyc1xuICAgIGNvbnN0IGxhc3Q3ZCA9IGRhdGEuc2xpY2UoLTE2OCk7IC8vIExhc3QgNyBkYXlzICgyNCAqIDcpXG4gICAgXG4gICAgY29uc3QgaGlnaDI0aCA9IE1hdGgubWF4KC4uLmxhc3QyNGgubWFwKGQgPT4gZC5oaWdoKSk7XG4gICAgY29uc3QgbG93MjRoID0gTWF0aC5taW4oLi4ubGFzdDI0aC5tYXAoZCA9PiBkLmxvdykpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIGNoYW5nZXNcbiAgICBjb25zdCBnZXRQZXJjZW50Q2hhbmdlID0gKHBlcmlvZERhdGE6IGFueVtdKSA9PiB7XG4gICAgICBpZiAocGVyaW9kRGF0YS5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgICAgIGNvbnN0IG9sZFByaWNlID0gcGVyaW9kRGF0YVswXS5jbG9zZTtcbiAgICAgIHJldHVybiAoKGN1cnJlbnRQcmljZSAtIG9sZFByaWNlKSAvIG9sZFByaWNlKSAqIDEwMDtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhbmdlMWggPSBnZXRQZXJjZW50Q2hhbmdlKGxhc3QxaCk7XG4gICAgY29uc3QgY2hhbmdlMjRoID0gZ2V0UGVyY2VudENoYW5nZShsYXN0MjRoKTtcbiAgICBjb25zdCBjaGFuZ2U3ZCA9IGdldFBlcmNlbnRDaGFuZ2UobGFzdDdkKTtcbiAgICBcbiAgICAvLyBGb3JtYXQgcHJpY2VzIHVzaW5nIHRoZSBwcmljZSBmb3JtYXQgdXRpbGl0eVxuICAgIGNvbnN0IGZvcm1hdHRlZEN1cnJlbnRQcmljZSA9IGZvcm1hdFByaWNlKGN1cnJlbnRQcmljZSwgY3VycmVudEJhc2VUb2tlbik7XG4gICAgY29uc3QgZm9ybWF0dGVkSGlnaCA9IGZvcm1hdFByaWNlKGhpZ2gyNGgsIGN1cnJlbnRCYXNlVG9rZW4pO1xuICAgIGNvbnN0IGZvcm1hdHRlZExvdyA9IGZvcm1hdFByaWNlKGxvdzI0aCwgY3VycmVudEJhc2VUb2tlbik7XG5cbiAgICBzZXRDdXJyZW50UHJpY2UoZm9ybWF0dGVkQ3VycmVudFByaWNlKTtcbiAgICBzZXRQcmljZVN0YXRzKHtcbiAgICAgIGNoYW5nZTFoOiBjaGFuZ2UxaC50b0ZpeGVkKDIpLFxuICAgICAgY2hhbmdlMjRoOiBjaGFuZ2UyNGgudG9GaXhlZCgyKSxcbiAgICAgIGNoYW5nZTdkOiBjaGFuZ2U3ZC50b0ZpeGVkKDIpLFxuICAgICAgaGlnaDI0aDogZm9ybWF0dGVkSGlnaCxcbiAgICAgIGxvdzI0aDogZm9ybWF0dGVkTG93XG4gICAgfSk7XG4gIH0sIFtjdXJyZW50QmFzZVRva2VuXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIHN0cmF0ZWd5IGluZGljYXRvcnNcbiAgY29uc3QgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzID0gdXNlQ2FsbGJhY2soKGNoYXJ0OiBJQ2hhcnRBcGksIGRhdGE6IGFueVtdKSA9PiB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgY29uc29sZS5lcnJvcignQ2hhcnQgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbmRpY2F0b3JzXG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZXJpZXMgJiYgY2hhcnQpIHtcbiAgICAgICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNlcmllczonLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIG1hcmtlciBzZXJpZXM6JywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdub25lJykgcmV0dXJuO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5kaWNhdG9ycyBiYXNlZCBvbiBzdHJhdGVneVxuICAgICAgY29uc3QgcHJpY2VzID0gZGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgIGxldCBmYXN0TGluZTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBzbG93TGluZTogbnVtYmVyW10gPSBbXTtcblxuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdlbWFfY3Jvc3NvdmVyJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDkpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlRU1BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzbWFfY3Jvc3NvdmVyJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDkpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlU01BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0ZW1hX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVURU1BKHByaWNlcywgNyk7XG4gICAgICAgICAgc2xvd0xpbmUgPSBjYWxjdWxhdGVURU1BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb2xkZW5fY3Jvc3MnOlxuICAgICAgICAgIGZhc3RMaW5lID0gY2FsY3VsYXRlU01BKHByaWNlcywgNTApO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlU01BKHByaWNlcywgMjAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHVsbF9jcm9zc292ZXInOlxuICAgICAgICAgIGZhc3RMaW5lID0gY2FsY3VsYXRlSE1BKHByaWNlcywgOSk7XG4gICAgICAgICAgc2xvd0xpbmUgPSBjYWxjdWxhdGVITUEocHJpY2VzLCAyMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VtYV81XzEzJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDUpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlRU1BKHByaWNlcywgMTMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYWNkX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgY29uc3QgbWFjZERhdGEgPSBjYWxjdWxhdGVNQUNEKHByaWNlcyk7XG4gICAgICAgICAgZmFzdExpbmUgPSBtYWNkRGF0YS5tYWNkO1xuICAgICAgICAgIHNsb3dMaW5lID0gbWFjZERhdGEuc2lnbmFsO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNlcGFyYXRlIHByaWNlIHNjYWxlIGZvciBNQUNEXG4gICAgICAgICAgY29uc3QgbWFjZFByaWNlU2NhbGUgPSBjaGFydC5hZGRQcmljZUxpbmUoe1xuICAgICAgICAgICAgdGl0bGU6ICdNQUNEIFNjYWxlJyxcbiAgICAgICAgICAgIHByaWNlOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcjMjk2MkZGJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGxpbmVTdHlsZTogMixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEFkZCBNQUNEIGFuZCBTaWduYWwgbGluZXMgd2l0aCBzZXBhcmF0ZSBzY2FsZVxuICAgICAgICAgIHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9ycy5mb3JFYWNoKChpbmRpY2F0b3IsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XG4gICAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICAgIHRpdGxlOiBpbmRpY2F0b3IubmFtZSxcbiAgICAgICAgICAgICAgcHJpY2VTY2FsZUlkOiAnbWFjZCcsXG4gICAgICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IDYsXG4gICAgICAgICAgICAgICAgbWluTW92ZTogMC4wMDAwMDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNjYWxlTWFyZ2luczoge1xuICAgICAgICAgICAgICAgIHRvcDogMC43LCAvLyBQb3NpdGlvbiB0aGUgTUFDRCBhdCB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLjEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQoaW5kaWNhdG9yLm5hbWUsIGxpbmVTZXJpZXMpO1xuXG4gICAgICAgICAgICBjb25zdCBsaW5lRGF0YSA9IChpbmRleCA9PT0gMCA/IGZhc3RMaW5lIDogc2xvd0xpbmUpXG4gICAgICAgICAgICAgIC5tYXAoKHZhbHVlLCBpZHgpID0+ICh7XG4gICAgICAgICAgICAgICAgdGltZTogZGF0YVtpZHhdLnRpbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzTmFOKHZhbHVlKSA/IG51bGwgOiB2YWx1ZVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpO1xuXG4gICAgICAgICAgICBsaW5lU2VyaWVzLnNldERhdGEobGluZURhdGEpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWRkIGhpc3RvZ3JhbVxuICAgICAgICAgIGNvbnN0IGhpc3RvZ3JhbVNlcmllcyA9IGNoYXJ0LmFkZEhpc3RvZ3JhbVNlcmllcyh7XG4gICAgICAgICAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgICAgICAgICBtaW5Nb3ZlOiAwLjAwMDAwMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmljZVNjYWxlSWQ6ICdtYWNkJyxcbiAgICAgICAgICAgIHNjYWxlTWFyZ2luczoge1xuICAgICAgICAgICAgICB0b3A6IDAuNyxcbiAgICAgICAgICAgICAgYm90dG9tOiAwLjEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgaGlzdG9ncmFtRGF0YSA9IG1hY2REYXRhLmhpc3RvZ3JhbS5tYXAoKHZhbHVlLCBpZHgpID0+ICh7XG4gICAgICAgICAgICB0aW1lOiBkYXRhW2lkeF0udGltZSxcbiAgICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWUsXG4gICAgICAgICAgICBjb2xvcjogdmFsdWUgPj0gMCA/ICcjMjZhNjlhJyA6ICcjZWY1MzUwJ1xuICAgICAgICAgIH0pKS5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKTtcblxuICAgICAgICAgIGhpc3RvZ3JhbVNlcmllcy5zZXREYXRhKGhpc3RvZ3JhbURhdGEpO1xuICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQoJ2hpc3RvZ3JhbScsIGhpc3RvZ3JhbVNlcmllcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBpbmRpY2F0b3IgbGluZXNcbiAgICAgIGNvbnN0IHNlbGVjdGVkU3RyYXRlZ3kgPSBnZXRTdHJhdGVneShzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGVjdGVkU3RyYXRlZ3kpIHJldHVybjtcblxuICAgICAgY29uc3QgY29sb3JzID0gWycjMjk2MkZGJywgJyNGRjZCNkInXTtcbiAgICAgIHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9ycy5mb3JFYWNoKChpbmRpY2F0b3IsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVTZXJpZXMgPSBjaGFydC5hZGRMaW5lU2VyaWVzKHtcbiAgICAgICAgICBjb2xvcjogY29sb3JzW2luZGV4XSxcbiAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgdGl0bGU6IGluZGljYXRvci5uYW1lLFxuICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiBpc0JUQ1BhaXIoY3VycmVudEJhc2VUb2tlbikgPyA4IDogMixcbiAgICAgICAgICAgIG1pbk1vdmU6IGlzQlRDUGFpcihjdXJyZW50QmFzZVRva2VuKSA/IDAuMDAwMDAwMDEgOiAwLjAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2V0KGluZGljYXRvci5uYW1lLCBsaW5lU2VyaWVzKTtcblxuICAgICAgICBjb25zdCBsaW5lRGF0YSA9IChpbmRleCA9PT0gMCA/IGZhc3RMaW5lIDogc2xvd0xpbmUpXG4gICAgICAgICAgLm1hcCgodmFsdWUsIGlkeCkgPT4gKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaWR4XS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IGlzTmFOKHZhbHVlKSA/IG51bGwgOiB2YWx1ZVxuICAgICAgICAgIH0pKVxuICAgICAgICAgIC5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKTtcblxuICAgICAgICBsaW5lU2VyaWVzLnNldERhdGEobGluZURhdGEpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzdHJhdGVneSBpbmRpY2F0b3JzOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtzdHJhdGVneSwgY3VycmVudEJhc2VUb2tlbl0pO1xuXG4gIC8vIEVmZmVjdCBmb3Igc3RyYXRlZ3kgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRSZWYuY3VycmVudCB8fCBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzKGNoYXJ0UmVmLmN1cnJlbnQsIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzdHJhdGVneSBjaGFuZ2UgZWZmZWN0OicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtzdHJhdGVneSwgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzXSk7XG5cbiAgLy8gTWFpbiBjaGFydCBpbml0aWFsaXphdGlvbiBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IGNoYXJ0T3B0aW9uczogRGVlcFBhcnRpYWw8Q2hhcnRPcHRpb25zPiA9IHtcbiAgICAgIGxheW91dDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzFFMjIyRCcgfSxcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXG4gICAgICB9LFxuICAgICAgZ3JpZDoge1xuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgICBob3J6TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgfSxcbiAgICAgIHRpbWVTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICByaWdodFByaWNlU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgc2NhbGVNYXJnaW5zOiB7XG4gICAgICAgICAgdG9wOiAwLjEsXG4gICAgICAgICAgYm90dG9tOiAwLjQsXG4gICAgICAgIH0sXG4gICAgICAgIGF1dG9TY2FsZTogdHJ1ZSxcbiAgICAgICAgbW9kZTogMCxcbiAgICAgICAgYWxpZ25MYWJlbHM6IHRydWUsXG4gICAgICAgIGJvcmRlclZpc2libGU6IHRydWUsXG4gICAgICAgIGVudGlyZVRleHRPbmx5OiB0cnVlLFxuICAgICAgICB0aWNrc1Zpc2libGU6IHRydWUsXG4gICAgICB9LFxuICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgbG9jYWxpemF0aW9uOiB7XG4gICAgICAgIHByaWNlRm9ybWF0dGVyOiAocHJpY2U6IG51bWJlcikgPT4gZm9ybWF0UHJpY2UocHJpY2UsIGN1cnJlbnRCYXNlVG9rZW4pLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCBjaGFydE9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHByaWNlIGZvcm1hdFxuICAgIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xuICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgIHdpY2tVcENvbG9yOiAnIzI2YTY5YScsXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICBwcmljZUZvcm1hdDoge1xuICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICBwcmVjaXNpb246IGlzQlRDUGFpcihjdXJyZW50QmFzZVRva2VuKSA/IDggOiAyLFxuICAgICAgICBtaW5Nb3ZlOiBpc0JUQ1BhaXIoY3VycmVudEJhc2VUb2tlbikgPyAwLjAwMDAwMDAxIDogMC4wMSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XG4gICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuXG4gICAgLy8gTG9hZCBpbml0aWFsIGRhdGFcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWUsIHRva2VuLCBjdXJyZW50QmFzZVRva2VuKTtcbiAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IGRhdGE7XG4gICAgICAgIFxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5zZXREYXRhKGRhdGEpO1xuICAgICAgICB1cGRhdGVQcmljZVN0YXRzKGRhdGEpO1xuXG4gICAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzKGNoYXJ0LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBkYXRhOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZERhdGEoKTtcblxuICAgIC8vIFJlYWwtdGltZSB1cGRhdGVzXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1ByaWNlKChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XG4gICAgICBjb25zdCBjYW5kbGVUaW1lc3RhbXAgPSBNYXRoLmZsb29yKGRhdGEudGltZSAvIGludGVydmFsU2Vjb25kcykgKiBpbnRlcnZhbFNlY29uZHM7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcgY2FuZGxlXG4gICAgICBpZiAoIWN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCB8fCBjYW5kbGVUaW1lc3RhbXAgIT09IGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC50aW1lKSB7XG4gICAgICAgIC8vIElmIHdlIGhhZCBhIHByZXZpb3VzIGNhbmRsZSwgYWRkIGl0IHRvIGhpc3RvcmljYWwgZGF0YSBhbmQgY2hlY2sgZm9yIHNpZ25hbHNcbiAgICAgICAgaWYgKGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCkge1xuICAgICAgICAgIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY3VycmVudENhbmRsZVJlZi5jdXJyZW50XTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ2llcyB3aXRoIHRoZSBuZXcgaGlzdG9yaWNhbCBkYXRhXG4gICAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzKGNoYXJ0UmVmLmN1cnJlbnQsIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IG5ldyBjYW5kbGVcbiAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIHRpbWU6IGNhbmRsZVRpbWVzdGFtcCxcbiAgICAgICAgICBvcGVuOiBkYXRhLnZhbHVlLFxuICAgICAgICAgIGhpZ2g6IGRhdGEudmFsdWUsXG4gICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxuICAgICAgICAgIGNsb3NlOiBkYXRhLnZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBjYW5kbGVcbiAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmhpZ2ggPSBNYXRoLm1heChjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQuaGlnaCwgZGF0YS52YWx1ZSk7XG4gICAgICAgIGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC5sb3cgPSBNYXRoLm1pbihjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQubG93LCBkYXRhLnZhbHVlKTtcbiAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmNsb3NlID0gZGF0YS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBjaGFydCB3aXRoIGN1cnJlbnQgY2FuZGxlXG4gICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQpO1xuXG4gICAgICAvLyBVcGRhdGUgcHJpY2Ugc3RhdHMgd2l0aCB0aGUgbGF0ZXN0IGRhdGFcbiAgICAgIGlmIChoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlUHJpY2VTdGF0cyhbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY3VycmVudENhbmRsZVJlZi5jdXJyZW50XSk7XG4gICAgICB9XG4gICAgfSwgdGltZWZyYW1lLCB0b2tlbiwgY3VycmVudEJhc2VUb2tlbik7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6ZVxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5hcHBseU9wdGlvbnMoe1xuICAgICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGluZGljYXRvciBzZXJpZXNcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQ/LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGluZGljYXRvciBzZXJpZXMgZHVyaW5nIGNsZWFudXA6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmVTZXJpZXMobWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIG1hcmtlciBzZXJpZXMgZHVyaW5nIGNsZWFudXA6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2hhcnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3RpbWVmcmFtZSwgY3VycmVudEJhc2VUb2tlbiwgc3RyYXRlZ3ksIHRva2VuLCB1cGRhdGVQcmljZVN0YXRzLCBhZGRTdHJhdGVneUluZGljYXRvcnNdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCB3LWZ1bGwgaC1mdWxsXCI+XG4gICAgICA8VGlja2VySGVhZGVyXG4gICAgICAgIHRva2VuPXt0b2tlbn1cbiAgICAgICAgYmFzZVRva2VuPXtiYXNlVG9rZW59XG4gICAgICAgIGV4Y2hhbmdlPXtleGNoYW5nZX1cbiAgICAgICAgY3VycmVudFByaWNlPXtjdXJyZW50UHJpY2V9XG4gICAgICAgIHByaWNlU3RhdHM9e3ByaWNlU3RhdHN9XG4gICAgICAgIG9uRXhjaGFuZ2VDaGFuZ2U9e3NldFNlbGVjdGVkRXhjaGFuZ2V9XG4gICAgICAgIG9uUGFpckNoYW5nZT17aGFuZGxlUGFpckNoYW5nZX1cbiAgICAgIC8+XG4gICAgICA8ZGl2IHJlZj17Y2hhcnRDb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cImZsZXgtMVwiIC8+XG4gICAgPC9kaXY+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiY3JlYXRlQ2hhcnQiLCJnZXRIaXN0b3JpY2FsRGF0YSIsInN1YnNjcmliZVRvUHJpY2UiLCJnZXRTdHJhdGVneSIsImNhbGN1bGF0ZUVNQSIsImNhbGN1bGF0ZVNNQSIsImNhbGN1bGF0ZVRFTUEiLCJjYWxjdWxhdGVITUEiLCJjYWxjdWxhdGVNQUNEIiwiVGlja2VySGVhZGVyIiwiZm9ybWF0UHJpY2UiLCJpc0JUQ1BhaXIiLCJnZXRJbnRlcnZhbFNlY29uZHMiLCJ0ZiIsIkNhbmRsZXN0aWNrQ2hhcnQiLCJ0aW1lZnJhbWUiLCJzdHJhdGVneSIsInRva2VuIiwiYmFzZVRva2VuIiwiZXhjaGFuZ2UiLCJvblBhaXJDaGFuZ2UiLCJzZWxlY3RlZEV4Y2hhbmdlIiwic2V0U2VsZWN0ZWRFeGNoYW5nZSIsImN1cnJlbnRCYXNlVG9rZW4iLCJzZXRDdXJyZW50QmFzZVRva2VuIiwiY3VycmVudFByaWNlIiwic2V0Q3VycmVudFByaWNlIiwicHJpY2VTdGF0cyIsInNldFByaWNlU3RhdHMiLCJjaGFuZ2UxaCIsImNoYW5nZTI0aCIsImNoYW5nZTdkIiwiaGlnaDI0aCIsImxvdzI0aCIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJtYXJrZXJTZXJpZXNSZWYiLCJoaXN0b3JpY2FsRGF0YVJlZiIsImN1cnJlbnRDYW5kbGVSZWYiLCJsYXN0U2lnbmFsUmVmIiwiaGFuZGxlUGFpckNoYW5nZSIsIm5ld1Rva2VuIiwibmV3QmFzZVRva2VuIiwidXBkYXRlUHJpY2VTdGF0cyIsImRhdGEiLCJsZW5ndGgiLCJjbG9zZSIsImxhc3QxaCIsInNsaWNlIiwibGFzdDI0aCIsImxhc3Q3ZCIsIk1hdGgiLCJtYXgiLCJtYXAiLCJkIiwiaGlnaCIsIm1pbiIsImxvdyIsImdldFBlcmNlbnRDaGFuZ2UiLCJwZXJpb2REYXRhIiwib2xkUHJpY2UiLCJmb3JtYXR0ZWRDdXJyZW50UHJpY2UiLCJmb3JtYXR0ZWRIaWdoIiwiZm9ybWF0dGVkTG93IiwidG9GaXhlZCIsImFkZFN0cmF0ZWd5SW5kaWNhdG9ycyIsImNoYXJ0IiwiY29uc29sZSIsImVycm9yIiwiY3VycmVudCIsImZvckVhY2giLCJzZXJpZXMiLCJyZW1vdmVTZXJpZXMiLCJlIiwiY2xlYXIiLCJwcmljZXMiLCJmYXN0TGluZSIsInNsb3dMaW5lIiwibWFjZERhdGEiLCJtYWNkIiwic2lnbmFsIiwibWFjZFByaWNlU2NhbGUiLCJhZGRQcmljZUxpbmUiLCJ0aXRsZSIsInByaWNlIiwiY29sb3IiLCJsaW5lV2lkdGgiLCJsaW5lU3R5bGUiLCJzZWxlY3RlZFN0cmF0ZWd5IiwiaW5kaWNhdG9ycyIsImluZGljYXRvciIsImluZGV4IiwibGluZVNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJjb2xvcnMiLCJuYW1lIiwicHJpY2VTY2FsZUlkIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsInNldCIsImxpbmVEYXRhIiwidmFsdWUiLCJpZHgiLCJ0aW1lIiwiaXNOYU4iLCJmaWx0ZXIiLCJzZXREYXRhIiwiaGlzdG9ncmFtU2VyaWVzIiwiYWRkSGlzdG9ncmFtU2VyaWVzIiwiaGlzdG9ncmFtRGF0YSIsImhpc3RvZ3JhbSIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJ0ZXh0Q29sb3IiLCJncmlkIiwidmVydExpbmVzIiwiaG9yekxpbmVzIiwidGltZVNjYWxlIiwiYm9yZGVyQ29sb3IiLCJ0aW1lVmlzaWJsZSIsInJpZ2h0UHJpY2VTY2FsZSIsInZpc2libGUiLCJhdXRvU2NhbGUiLCJtb2RlIiwiYWxpZ25MYWJlbHMiLCJib3JkZXJWaXNpYmxlIiwiZW50aXJlVGV4dE9ubHkiLCJ0aWNrc1Zpc2libGUiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwibG9jYWxpemF0aW9uIiwicHJpY2VGb3JtYXR0ZXIiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsImxvYWREYXRhIiwidW5zdWJzY3JpYmUiLCJpbnRlcnZhbFNlY29uZHMiLCJjYW5kbGVUaW1lc3RhbXAiLCJmbG9vciIsIm9wZW4iLCJ1cGRhdGUiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsImRpdiIsImNsYXNzTmFtZSIsIm9uRXhjaGFuZ2VDaGFuZ2UiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
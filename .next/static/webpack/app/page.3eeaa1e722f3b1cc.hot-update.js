"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/ema-crossover */ \"(app-pages-browser)/./src/services/strategies/ema-crossover.ts\");\n/* harmony import */ var _services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/services/strategies/sma-crossover */ \"(app-pages-browser)/./src/services/strategies/sma-crossover.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token, exchange } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = function(data, chart) {\n        let isInitialSetup = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy || strategy === \"none\") {\n                console.log(\"No strategy selected or invalid strategy\");\n                return;\n            }\n            if (isInitialSetup) {\n                console.log(\"Setting up new strategy indicators\");\n                try {\n                    // Create marker series for signals\n                    markerSeriesRef.current = chart.addCandlestickSeries({\n                        upColor: \"rgba(0,0,0,0)\",\n                        downColor: \"rgba(0,0,0,0)\",\n                        borderVisible: false,\n                        wickUpColor: \"rgba(0,0,0,0)\",\n                        wickDownColor: \"rgba(0,0,0,0)\"\n                    });\n                    // Create indicator series\n                    if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                        const indicators = [\n                            \"Fast MA\",\n                            \"Slow MA\"\n                        ];\n                        indicators.forEach((name, index)=>{\n                            console.log(\"Adding indicator: \".concat(name));\n                            const colors = [\n                                \"#2962FF\",\n                                \"#FF6B6B\"\n                            ]; // Blue for fast, Red for slow\n                            const lineSeries = chart.addLineSeries({\n                                color: colors[index],\n                                lineWidth: 2,\n                                title: name,\n                                priceFormat: {\n                                    type: \"price\",\n                                    precision: 2,\n                                    minMove: 0.01\n                                },\n                                lineStyle: 1\n                            });\n                            indicatorSeriesRefs.current.set(name, lineSeries);\n                        });\n                    }\n                } catch (e) {\n                    console.error(\"Error creating series:\", e);\n                    return;\n                }\n            }\n            // Calculate indicators\n            const prices = data.map((d)=>d.close);\n            const fastPeriod = 9;\n            const slowPeriod = 21;\n            const fastLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, fastPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, fastPeriod);\n            const slowLine = selectedStrategy.id === \"ema_crossover\" ? (0,_services_strategies_ema_crossover__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, slowPeriod) : (0,_services_strategies_sma_crossover__WEBPACK_IMPORTED_MODULE_6__.calculateSMA)(prices, slowPeriod);\n            // Update indicator lines\n            const fastSeries = indicatorSeriesRefs.current.get(\"Fast MA\");\n            const slowSeries = indicatorSeriesRefs.current.get(\"Slow MA\");\n            if (fastSeries && slowSeries) {\n                const fastData = fastLine.map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    }));\n                const slowData = slowLine.map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    }));\n                fastSeries.setData(fastData);\n                slowSeries.setData(slowData);\n            }\n            // Update markers\n            if (markerSeriesRef.current) {\n                const markers = [];\n                for(let i = 1; i < data.length; i++){\n                    const prevFast = fastLine[i - 1];\n                    const prevSlow = slowLine[i - 1];\n                    const currFast = fastLine[i];\n                    const currSlow = slowLine[i];\n                    if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                        if (prevFast <= prevSlow && currFast > currSlow) {\n                            markers.push({\n                                time: data[i].time,\n                                position: \"belowBar\",\n                                color: \"#26a69a\",\n                                shape: \"arrowUp\",\n                                text: \" \",\n                                size: 2\n                            });\n                        } else if (prevFast >= prevSlow && currFast < currSlow) {\n                            markers.push({\n                                time: data[i].time,\n                                position: \"aboveBar\",\n                                color: \"#ef5350\",\n                                shape: \"arrowDown\",\n                                text: \" \",\n                                size: 2\n                            });\n                        }\n                    }\n                }\n                if (markers.length > 0) {\n                    markerSeriesRef.current.setMarkers(markers);\n                }\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current && historicalDataRef.current.length > 0) {\n            console.log(\"Reinitializing strategy indicators\");\n            // Clean up old indicators and markers\n            if (markerSeriesRef.current) {\n                try {\n                    safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    safelyRemoveSeries(chartRef.current, series);\n                } catch (e) {\n                    console.error(\"Error removing indicator series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            // Initialize new strategy with a longer delay to ensure proper cleanup\n            if (strategy !== \"none\") {\n                const timeoutId = setTimeout(()=>{\n                    try {\n                        if (chartRef.current) {\n                            updateStrategyIndicators(historicalDataRef.current, chartRef.current, true);\n                        }\n                    } catch (e) {\n                        console.error(\"Error initializing strategy:\", e);\n                    }\n                }, 100);\n                return ()=>clearTimeout(timeoutId);\n            }\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                var // Set candlestick data\n                _candlestickSeriesRef_current;\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                (_candlestickSeriesRef_current = candlestickSeriesRef.current) === null || _candlestickSeriesRef_current === void 0 ? void 0 : _candlestickSeriesRef_current.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Initialize strategy indicators if a strategy is selected\n                if (strategy !== \"none\") {\n                    console.log(\"Initializing strategy indicators after loading data\");\n                    updateStrategyIndicators(historicalData, chart, true);\n                }\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            {\n                                ...newCandle,\n                                time: currentCandle.time\n                            }\n                        ];\n                        // Update strategy indicators with completed candle\n                        if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                            updateStrategyIndicators(historicalDataRef.current, chartRef.current, false);\n                        }\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: Number(candleTimestamp),\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                }\n                // Update candlestick series with the current state\n                candlestickSeriesRef.current.update(currentCandle);\n                // Update strategy indicators with current in-progress candle\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const updatedData = [\n                        ...historicalDataRef.current,\n                        {\n                            ...currentCandle,\n                            time: currentCandle.time\n                        }\n                    ];\n                    updateStrategyIndicators(updatedData, chartRef.current, false);\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 450,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"bet0c3GPpABv0spqAYVyx2BdTvc=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRTBDO0FBQ087QUFDZ0Q7QUFDakM7QUFDRztBQUNBO0FBaUI1RCxTQUFTUSxpQkFBaUIsS0FBK0Q7UUFBL0QsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUF5QixHQUEvRDs7SUFDL0IsTUFBTUMsb0JBQW9CWiw2Q0FBTUEsQ0FBaUI7SUFDakQsTUFBTWEsV0FBV2IsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU1jLHVCQUF1QmQsNkNBQU1BLENBQU07SUFDekMsTUFBTWUsc0JBQXNCZiw2Q0FBTUEsQ0FBbUIsSUFBSWdCO0lBQ3pELE1BQU1DLGtCQUFrQmpCLDZDQUFNQSxDQUFNO0lBQ3BDLE1BQU1rQixvQkFBb0JsQiw2Q0FBTUEsQ0FBUSxFQUFFO0lBRTFDLHFDQUFxQztJQUNyQyxNQUFNbUIscUJBQXFCLENBQUNDLE9BQWtCQztRQUM1QyxJQUFJO1lBQ0YsSUFBSUEsVUFBVUQsT0FBTztnQkFDbkJBLE1BQU1FLFlBQVksQ0FBQ0Q7WUFDckI7UUFDRixFQUFFLE9BQU9FLEdBQUc7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkY7UUFDMUM7SUFDRjtJQUVBLHlDQUF5QztJQUN6QyxNQUFNRywyQkFBMkIsU0FBQ0MsTUFBYVA7WUFBa0JRLGtGQUEwQjtRQUN6RixJQUFJO1lBQ0YsSUFBSSxDQUFDUixTQUFTLENBQUNPLEtBQUtFLE1BQU0sRUFBRTtnQkFDMUJMLFFBQVFNLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsTUFBTUMsbUJBQW1CM0IsaUVBQVdBLENBQUNLO1lBQ3JDLElBQUksQ0FBQ3NCLG9CQUFvQnRCLGFBQWEsUUFBUTtnQkFDNUNlLFFBQVFNLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsSUFBSUYsZ0JBQWdCO2dCQUNsQkosUUFBUU0sR0FB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QUluQixTQUFTbUIsT0FBTyxFQUFFO2dCQUNqRG5CLFNBQVNtQixPQUFPLENBQUM2SCxZQUFZLENBQUM7b0JBQzVCNUMsT0FBT3JHLGtCQUFrQm9CLE9BQU8sQ0FBQzZGLFdBQVc7b0JBQzVDQyxRQUFRbEgsa0JBQWtCb0IsT0FBTyxDQUFDK0YsWUFBWTtnQkFDaEQ7WUFDRjtRQUNGO1FBRUErQixPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVSDtRQUVsQyxPQUFPO1lBQ0xFLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVKO1lBQ3JDbkUsYUFBYWtFO1lBQ2JqQjtZQUNBLElBQUk3SCxTQUFTbUIsT0FBTyxFQUFFO2dCQUNwQm5CLFNBQVNtQixPQUFPLENBQUN3SCxNQUFNO1lBQ3pCO1FBQ0Y7SUFDRixHQUFHO1FBQUNoSjtRQUFXQztLQUFTO0lBRXhCLHFCQUFPLDhEQUFDd0o7UUFBSUMsS0FBS3RKO1FBQW1CdUosV0FBVTs7Ozs7O0FBQ2hEO0dBMWFnQjVKO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4PzhkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5pbXBvcnQgeyBUaW1lLCBJQ2hhcnRBcGksIENoYXJ0T3B0aW9ucywgRGVlcFBhcnRpYWwsIExpbmVXaWR0aCwgQnVzaW5lc3NEYXksIFVUQ1RpbWVzdGFtcCB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjcmVhdGVDaGFydCB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XHJcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcclxuaW1wb3J0IHsgU3RyYXRlZ3lJZCwgZ2V0U3RyYXRlZ3kgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVFTUEgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMvZW1hLWNyb3Nzb3Zlcic7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZVNNQSB9IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcy9zbWEtY3Jvc3NvdmVyJztcclxuXHJcbmludGVyZmFjZSBDYW5kbGVzdGlja0NoYXJ0UHJvcHMge1xyXG4gIHRpbWVmcmFtZTogVGltZWZyYW1lO1xyXG4gIHN0cmF0ZWd5OiBTdHJhdGVneUlkO1xyXG4gIHRva2VuOiBzdHJpbmc7XHJcbiAgZXhjaGFuZ2U6ICd1bmlzd2FwJyB8ICdyYXlkaXVtJyB8ICdjb2luYmFzZSc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDYW5kbGUge1xyXG4gIHRpbWU6IFRpbWU7XHJcbiAgb3BlbjogbnVtYmVyO1xyXG4gIGhpZ2g6IG51bWJlcjtcclxuICBsb3c6IG51bWJlcjtcclxuICBjbG9zZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2FuZGxlc3RpY2tDaGFydCh7IHRpbWVmcmFtZSwgc3RyYXRlZ3ksIHRva2VuLCBleGNoYW5nZSB9OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcclxuICBjb25zdCBjaGFydENvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcclxuICBjb25zdCBpbmRpY2F0b3JTZXJpZXNSZWZzID0gdXNlUmVmPE1hcDxzdHJpbmcsIGFueT4+KG5ldyBNYXAoKSk7XHJcbiAgY29uc3QgbWFya2VyU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XHJcbiAgY29uc3QgaGlzdG9yaWNhbERhdGFSZWYgPSB1c2VSZWY8YW55W10+KFtdKTtcclxuXHJcbiAgLy8gRnVuY3Rpb24gdG8gc2FmZWx5IHJlbW92ZSBhIHNlcmllc1xyXG4gIGNvbnN0IHNhZmVseVJlbW92ZVNlcmllcyA9IChjaGFydDogSUNoYXJ0QXBpLCBzZXJpZXM6IGFueSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHNlcmllcyAmJiBjaGFydCkge1xyXG4gICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNlcmllczonLCBlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9yc1xyXG4gIGNvbnN0IHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyA9IChkYXRhOiBhbnlbXSwgY2hhcnQ6IElDaGFydEFwaSwgaXNJbml0aWFsU2V0dXA6IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFjaGFydCB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQgb3IgZGF0YSBub3QgcmVhZHksIHNraXBwaW5nIHVwZGF0ZScpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcclxuICAgICAgaWYgKCFzZWxlY3RlZFN0cmF0ZWd5IHx8IHN0cmF0ZWd5ID09PSAnbm9uZScpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gc3RyYXRlZ3kgc2VsZWN0ZWQgb3IgaW52YWxpZCBzdHJhdGVneScpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzSW5pdGlhbFNldHVwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgdXAgbmV3IHN0cmF0ZWd5IGluZGljYXRvcnMnKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gQ3JlYXRlIG1hcmtlciBzZXJpZXMgZm9yIHNpZ25hbHNcclxuICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xyXG4gICAgICAgICAgICB1cENvbG9yOiAncmdiYSgwLDAsMCwwKScsXHJcbiAgICAgICAgICAgIGRvd25Db2xvcjogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgICAgICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd2lja1VwQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgICAgICAgICAgd2lja0Rvd25Db2xvcjogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGluZGljYXRvciBzZXJpZXNcclxuICAgICAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicgfHwgc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ3NtYV9jcm9zc292ZXInKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljYXRvcnMgPSBbJ0Zhc3QgTUEnLCAnU2xvdyBNQSddO1xyXG4gICAgICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goKG5hbWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBpbmRpY2F0b3I6ICR7bmFtZX1gKTtcclxuICAgICAgICAgICAgICBjb25zdCBjb2xvcnMgPSBbJyMyOTYyRkYnLCAnI0ZGNkI2QiddOyAvLyBCbHVlIGZvciBmYXN0LCBSZWQgZm9yIHNsb3dcclxuICAgICAgICAgICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2luZGV4XSxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcclxuICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAyLFxyXG4gICAgICAgICAgICAgICAgICBtaW5Nb3ZlOiAwLjAxLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpbmVTdHlsZTogMSwgLy8gU29saWQgbGluZVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQobmFtZSwgbGluZVNlcmllcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNlcmllczonLCBlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBpbmRpY2F0b3JzXHJcbiAgICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XHJcbiAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xyXG4gICAgICBjb25zdCBzbG93UGVyaW9kID0gMjE7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBmYXN0TGluZSA9IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyBcclxuICAgICAgICA/IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpXHJcbiAgICAgICAgOiBjYWxjdWxhdGVTTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcclxuICAgICAgY29uc3Qgc2xvd0xpbmUgPSBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcidcclxuICAgICAgICA/IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpXHJcbiAgICAgICAgOiBjYWxjdWxhdGVTTUEocHJpY2VzLCBzbG93UGVyaW9kKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3IgbGluZXNcclxuICAgICAgY29uc3QgZmFzdFNlcmllcyA9IGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5nZXQoJ0Zhc3QgTUEnKTtcclxuICAgICAgY29uc3Qgc2xvd1NlcmllcyA9IGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5nZXQoJ1Nsb3cgTUEnKTtcclxuXHJcbiAgICAgIGlmIChmYXN0U2VyaWVzICYmIHNsb3dTZXJpZXMpIHtcclxuICAgICAgICBjb25zdCBmYXN0RGF0YSA9IGZhc3RMaW5lLm1hcCgodmFsdWU6IG51bWJlciwgaWR4OiBudW1iZXIpID0+ICh7XHJcbiAgICAgICAgICB0aW1lOiBkYXRhW2lkeF0udGltZSxcclxuICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgY29uc3Qgc2xvd0RhdGEgPSBzbG93TGluZS5tYXAoKHZhbHVlOiBudW1iZXIsIGlkeDogbnVtYmVyKSA9PiAoe1xyXG4gICAgICAgICAgdGltZTogZGF0YVtpZHhdLnRpbWUsXHJcbiAgICAgICAgICB2YWx1ZTogaXNOYU4odmFsdWUpID8gbnVsbCA6IHZhbHVlXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBmYXN0U2VyaWVzLnNldERhdGEoZmFzdERhdGEpO1xyXG4gICAgICAgIHNsb3dTZXJpZXMuc2V0RGF0YShzbG93RGF0YSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBtYXJrZXJzXHJcbiAgICAgIGlmIChtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdExpbmVbaSAtIDFdO1xyXG4gICAgICAgICAgY29uc3QgcHJldlNsb3cgPSBzbG93TGluZVtpIC0gMV07XHJcbiAgICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xyXG4gICAgICAgICAgY29uc3QgY3VyclNsb3cgPSBzbG93TGluZVtpXTtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xyXG4gICAgICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xyXG4gICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXHJcbiAgICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJyAnLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XHJcbiAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZWY1MzUwJyxcclxuICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6ICcgJyxcclxuICAgICAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQuc2V0TWFya2VycyhtYXJrZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzOicsIGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgc3RyYXRlZ3kgY2hhbmdlIGVmZmVjdFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnU3RyYXRlZ3kgY2hhbmdlZDonLCBzdHJhdGVneSk7XHJcbiAgICBcclxuICAgIGlmIChjaGFydFJlZi5jdXJyZW50ICYmIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnUmVpbml0aWFsaXppbmcgc3RyYXRlZ3kgaW5kaWNhdG9ycycpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYW4gdXAgb2xkIGluZGljYXRvcnMgYW5kIG1hcmtlcnNcclxuICAgICAgaWYgKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHNhZmVseVJlbW92ZVNlcmllcyhjaGFydFJlZi5jdXJyZW50LCBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgbWFya2VyIHNlcmllczonLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuZm9yRWFjaChzZXJpZXMgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzYWZlbHlSZW1vdmVTZXJpZXMoY2hhcnRSZWYuY3VycmVudCEsIHNlcmllcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgaW5kaWNhdG9yIHNlcmllczonLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuY2xlYXIoKTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpemUgbmV3IHN0cmF0ZWd5IHdpdGggYSBsb25nZXIgZGVsYXkgdG8gZW5zdXJlIHByb3BlciBjbGVhbnVwXHJcbiAgICAgIGlmIChzdHJhdGVneSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LCBjaGFydFJlZi5jdXJyZW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgc3RyYXRlZ3k6JywgZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMTAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW3N0cmF0ZWd5XSk7IC8vIE9ubHkgcnVuIHdoZW4gc3RyYXRlZ3kgY2hhbmdlc1xyXG5cclxuICAvLyBNYWluIGNoYXJ0IGluaXRpYWxpemF0aW9uIGVmZmVjdFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgY2hhcnQgd2l0aCB0aW1lZnJhbWU6JywgdGltZWZyYW1lKTtcclxuXHJcbiAgICBjb25zdCBmb3JtYXRUaW1lID0gKHRpbWU6IFRpbWUpID0+IHtcclxuICAgICAgbGV0IGRhdGU6IERhdGU7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIEJ1c2luZXNzRGF5IGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGltZSBhcyBCdXNpbmVzc0RheTtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcclxuICAgICAgICBtb250aDogJ3Nob3J0JyxcclxuICAgICAgICBkYXk6ICdudW1lcmljJyxcclxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgaG91cjEyOiBmYWxzZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gRm9yIGRhaWx5IHRpbWVmcmFtZXMsIGRvbid0IHNob3cgdGltZVxyXG4gICAgICBpZiAodGltZWZyYW1lID09PSAnMWQnKSB7XHJcbiAgICAgICAgZGVsZXRlIGZvcm1hdE9wdGlvbnMuaG91cjtcclxuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5taW51dGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIGZvcm1hdE9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjaGFydE9wdGlvbnM6IERlZXBQYXJ0aWFsPENoYXJ0T3B0aW9ucz4gPSB7XHJcbiAgICAgIGxheW91dDoge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHsgY29sb3I6ICcjMUUyMjJEJyB9LFxyXG4gICAgICAgIHRleHRDb2xvcjogJyNEREQnLFxyXG4gICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICBmb250RmFtaWx5OiAnUm9ib3RvLCBzYW5zLXNlcmlmJyxcclxuICAgICAgfSxcclxuICAgICAgZ3JpZDoge1xyXG4gICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyMyQjJCNDMnIH0sXHJcbiAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcclxuICAgICAgfSxcclxuICAgICAgY3Jvc3NoYWlyOiB7XHJcbiAgICAgICAgbW9kZTogMSxcclxuICAgICAgICB2ZXJ0TGluZToge1xyXG4gICAgICAgICAgd2lkdGg6IDEgYXMgTGluZVdpZHRoLFxyXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcclxuICAgICAgICAgIHN0eWxlOiAzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9yekxpbmU6IHtcclxuICAgICAgICAgIHdpZHRoOiAxIGFzIExpbmVXaWR0aCxcclxuICAgICAgICAgIGNvbG9yOiAnIzc1ODY5NicsXHJcbiAgICAgICAgICBzdHlsZTogMyxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB0aW1lU2NhbGU6IHtcclxuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxyXG4gICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgIHNlY29uZHNWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XHJcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcclxuICAgICAgfSxcclxuICAgICAgbG9jYWxpemF0aW9uOiB7XHJcbiAgICAgICAgdGltZUZvcm1hdHRlcjogZm9ybWF0VGltZSxcclxuICAgICAgfSxcclxuICAgICAgd2F0ZXJtYXJrOiB7XHJcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xyXG4gICAgICAuLi5jaGFydE9wdGlvbnMsXHJcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XHJcbiAgICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcclxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxyXG4gICAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxyXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XHJcblxyXG4gICAgLy8gRmV0Y2ggaGlzdG9yaWNhbCBkYXRhXHJcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoaXN0b3JpY2FsRGF0YSA9IGF3YWl0IGdldEhpc3RvcmljYWxEYXRhKHRpbWVmcmFtZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBoaXN0b3JpY2FsIGRhdGE6JywgaGlzdG9yaWNhbERhdGEubGVuZ3RoKTtcclxuICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gaGlzdG9yaWNhbERhdGE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2V0IGNhbmRsZXN0aWNrIGRhdGFcclxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50Py5zZXREYXRhKGhpc3RvcmljYWxEYXRhLm1hcChkID0+ICh7XHJcbiAgICAgICAgICB0aW1lOiBkLnRpbWUgYXMgVGltZSxcclxuICAgICAgICAgIG9wZW46IGQub3BlbixcclxuICAgICAgICAgIGhpZ2g6IGQuaGlnaCxcclxuICAgICAgICAgIGxvdzogZC5sb3csXHJcbiAgICAgICAgICBjbG9zZTogZC5jbG9zZVxyXG4gICAgICAgIH0pKSk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgc3RyYXRlZ3kgaW5kaWNhdG9ycyBpZiBhIHN0cmF0ZWd5IGlzIHNlbGVjdGVkXHJcbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgc3RyYXRlZ3kgaW5kaWNhdG9ycyBhZnRlciBsb2FkaW5nIGRhdGEnKTtcclxuICAgICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YSwgY2hhcnQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGhpc3RvcmljYWwgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbG9hZERhdGEoKTtcclxuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gcmVhbC10aW1lIHByaWNlIHVwZGF0ZXNcclxuICAgIGxldCBjdXJyZW50Q2FuZGxlID0ge1xyXG4gICAgICBvcGVuOiAwLFxyXG4gICAgICBoaWdoOiAtSW5maW5pdHksXHJcbiAgICAgIGxvdzogSW5maW5pdHksXHJcbiAgICAgIGNsb3NlOiAwLFxyXG4gICAgICB0aW1lOiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBnZXRJbnRlcnZhbFNlY29uZHMgPSAodGY6IFRpbWVmcmFtZSk6IG51bWJlciA9PiB7XHJcbiAgICAgIHN3aXRjaCAodGYpIHtcclxuICAgICAgICBjYXNlICcxbSc6IHJldHVybiA2MDtcclxuICAgICAgICBjYXNlICc1bSc6IHJldHVybiAzMDA7XHJcbiAgICAgICAgY2FzZSAnMTVtJzogcmV0dXJuIDkwMDtcclxuICAgICAgICBjYXNlICczMG0nOiByZXR1cm4gMTgwMDtcclxuICAgICAgICBjYXNlICcxaCc6IHJldHVybiAzNjAwO1xyXG4gICAgICAgIGNhc2UgJzRoJzogcmV0dXJuIDE0NDAwO1xyXG4gICAgICAgIGNhc2UgJzFkJzogcmV0dXJuIDg2NDAwO1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiA2MDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZVRvUHJpY2UoKGRhdGEpID0+IHtcclxuICAgICAgaWYgKGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCBpbnRlcnZhbFNlY29uZHMgPSBnZXRJbnRlcnZhbFNlY29uZHModGltZWZyYW1lKTtcclxuICAgICAgICBjb25zdCBjYW5kbGVUaW1lc3RhbXAgPSBNYXRoLmZsb29yKGRhdGEudGltZSAvIGludGVydmFsU2Vjb25kcykgKiBpbnRlcnZhbFNlY29uZHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBjYW5kbGVcclxuICAgICAgICBpZiAoY2FuZGxlVGltZXN0YW1wICE9PSAoY3VycmVudENhbmRsZS50aW1lIGFzIFVUQ1RpbWVzdGFtcCkpIHtcclxuICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNhbmRsZSwgZmluYWxpemUgaXRcclxuICAgICAgICAgIGlmIChjdXJyZW50Q2FuZGxlLnRpbWUgIT09IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2FuZGxlID0ge1xyXG4gICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcclxuICAgICAgICAgICAgICBvcGVuOiBjdXJyZW50Q2FuZGxlLm9wZW4sXHJcbiAgICAgICAgICAgICAgaGlnaDogY3VycmVudENhbmRsZS5oaWdoLFxyXG4gICAgICAgICAgICAgIGxvdzogY3VycmVudENhbmRsZS5sb3csXHJcbiAgICAgICAgICAgICAgY2xvc2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKG5ld0NhbmRsZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgaGlzdG9yaWNhbCBkYXRhIHdpdGggdGhlIG5ldyBjYW5kbGVcclxuICAgICAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IFsuLi5oaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LnNsaWNlKDEpLCB7XHJcbiAgICAgICAgICAgICAgLi4ubmV3Q2FuZGxlLFxyXG4gICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSBhcyBVVENUaW1lc3RhbXBcclxuICAgICAgICAgICAgfV07XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9ycyB3aXRoIGNvbXBsZXRlZCBjYW5kbGVcclxuICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCAmJiBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGNhbmRsZVxyXG4gICAgICAgICAgY3VycmVudENhbmRsZSA9IHtcclxuICAgICAgICAgICAgdGltZTogTnVtYmVyKGNhbmRsZVRpbWVzdGFtcCkgYXMgVVRDVGltZXN0YW1wLFxyXG4gICAgICAgICAgICBvcGVuOiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICBoaWdoOiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICBsb3c6IGRhdGEudmFsdWUsXHJcbiAgICAgICAgICAgIGNsb3NlOiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNhbmRsZVxyXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPiBjdXJyZW50Q2FuZGxlLmhpZ2gpIGN1cnJlbnRDYW5kbGUuaGlnaCA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA8IGN1cnJlbnRDYW5kbGUubG93KSBjdXJyZW50Q2FuZGxlLmxvdyA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgICBjdXJyZW50Q2FuZGxlLmNsb3NlID0gZGF0YS52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBjYW5kbGVzdGljayBzZXJpZXMgd2l0aCB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKGN1cnJlbnRDYW5kbGUpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9ycyB3aXRoIGN1cnJlbnQgaW4tcHJvZ3Jlc3MgY2FuZGxlXHJcbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCAmJiBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2l6ZSA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQsIHtcclxuICAgICAgICAgICAgLi4uY3VycmVudENhbmRsZSxcclxuICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lIGFzIFVUQ1RpbWVzdGFtcFxyXG4gICAgICAgICAgfV07XHJcbiAgICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnModXBkYXRlZERhdGEsIGNoYXJ0UmVmLmN1cnJlbnQsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIHRpbWVmcmFtZSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIFRyYWRpbmdWaWV3IGxvZ28gZWxlbWVudHMgaWYgdGhleSBleGlzdFxyXG4gICAgY29uc3QgcmVtb3ZlVHJhZGluZ1ZpZXdMb2dvID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBsb2dvRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0di1hdHRyLWxvZ28nKTtcclxuICAgICAgaWYgKGxvZ29FbGVtZW50KSB7XHJcbiAgICAgICAgbG9nb0VsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGhlYWRlckxvZ28gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHYtaGVhZGVyX19saW5rJyk7XHJcbiAgICAgIGlmIChoZWFkZXJMb2dvKSB7XHJcbiAgICAgICAgaGVhZGVyTG9nby5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSdW4gbG9nbyByZW1vdmFsIGFmdGVyIGNoYXJ0IGlzIGNyZWF0ZWRcclxuICAgIHJlbW92ZVRyYWRpbmdWaWV3TG9nbygpO1xyXG4gICAgLy8gQWxzbyBydW4gYWZ0ZXIgYSBzaG9ydCBkZWxheSB0byBjYXRjaCBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xyXG4gICAgY29uc3QgbG9nb1RpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVtb3ZlVHJhZGluZ1ZpZXdMb2dvLCAxMDApO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQuYXBwbHlPcHRpb25zKHtcclxuICAgICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgY2xlYXJUaW1lb3V0KGxvZ29UaW1lb3V0SWQpO1xyXG4gICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW3RpbWVmcmFtZSwgc3RyYXRlZ3ldKTtcclxuXHJcbiAgcmV0dXJuIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiIC8+O1xyXG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJjcmVhdGVDaGFydCIsImdldEhpc3RvcmljYWxEYXRhIiwic3Vic2NyaWJlVG9QcmljZSIsImdldFN0cmF0ZWd5IiwiY2FsY3VsYXRlRU1BIiwiY2FsY3VsYXRlU01BIiwiQ2FuZGxlc3RpY2tDaGFydCIsInRpbWVmcmFtZSIsInN0cmF0ZWd5IiwidG9rZW4iLCJleGNoYW5nZSIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJtYXJrZXJTZXJpZXNSZWYiLCJoaXN0b3JpY2FsRGF0YVJlZiIsInNhZmVseVJlbW92ZVNlcmllcyIsImNoYXJ0Iiwic2VyaWVzIiwicmVtb3ZlU2VyaWVzIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsInVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyIsImRhdGEiLCJpc0luaXRpYWxTZXR1cCIsImxlbmd0aCIsImxvZyIsInNlbGVjdGVkU3RyYXRlZ3kiLCJjdXJyZW50IiwiYWRkQ2FuZGxlc3RpY2tTZXJpZXMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsImlkIiwiaW5kaWNhdG9ycyIsImZvckVhY2giLCJuYW1lIiwiaW5kZXgiLCJjb2xvcnMiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImNvbG9yIiwibGluZVdpZHRoIiwidGl0bGUiLCJwcmljZUZvcm1hdCIsInR5cGUiLCJwcmVjaXNpb24iLCJtaW5Nb3ZlIiwibGluZVN0eWxlIiwic2V0IiwicHJpY2VzIiwibWFwIiwiZCIsImNsb3NlIiwiZmFzdFBlcmlvZCIsInNsb3dQZXJpb2QiLCJmYXN0TGluZSIsInNsb3dMaW5lIiwiZmFzdFNlcmllcyIsImdldCIsInNsb3dTZXJpZXMiLCJmYXN0RGF0YSIsInZhbHVlIiwiaWR4IiwidGltZSIsImlzTmFOIiwic2xvd0RhdGEiLCJzZXREYXRhIiwibWFya2VycyIsImkiLCJwcmV2RmFzdCIsInByZXZTbG93IiwiY3VyckZhc3QiLCJjdXJyU2xvdyIsInB1c2giLCJwb3NpdGlvbiIsInNoYXBlIiwidGV4dCIsInNpemUiLCJzZXRNYXJrZXJzIiwiY2xlYXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZm9ybWF0VGltZSIsImRhdGUiLCJEYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJ0b0xvY2FsZVN0cmluZyIsImNoYXJ0T3B0aW9ucyIsImxheW91dCIsImJhY2tncm91bmQiLCJ0ZXh0Q29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJncmlkIiwidmVydExpbmVzIiwiaG9yekxpbmVzIiwiY3Jvc3NoYWlyIiwibW9kZSIsInZlcnRMaW5lIiwid2lkdGgiLCJzdHlsZSIsImhvcnpMaW5lIiwidGltZVNjYWxlIiwiYm9yZGVyQ29sb3IiLCJ0aW1lVmlzaWJsZSIsInNlY29uZHNWaXNpYmxlIiwicmlnaHRQcmljZVNjYWxlIiwibG9jYWxpemF0aW9uIiwidGltZUZvcm1hdHRlciIsIndhdGVybWFyayIsInZpc2libGUiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNhbmRsZXN0aWNrU2VyaWVzIiwibG9hZERhdGEiLCJoaXN0b3JpY2FsRGF0YSIsIm9wZW4iLCJoaWdoIiwibG93IiwiY3VycmVudENhbmRsZSIsIkluZmluaXR5IiwiZ2V0SW50ZXJ2YWxTZWNvbmRzIiwidGYiLCJ1bnN1YnNjcmliZSIsImludGVydmFsU2Vjb25kcyIsImNhbmRsZVRpbWVzdGFtcCIsIk1hdGgiLCJmbG9vciIsIm5ld0NhbmRsZSIsInVwZGF0ZSIsInNsaWNlIiwiTnVtYmVyIiwidXBkYXRlZERhdGEiLCJyZW1vdmVUcmFkaW5nVmlld0xvZ28iLCJsb2dvRWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyZW1vdmUiLCJoZWFkZXJMb2dvIiwicXVlcnlTZWxlY3RvciIsImxvZ29UaW1lb3V0SWQiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
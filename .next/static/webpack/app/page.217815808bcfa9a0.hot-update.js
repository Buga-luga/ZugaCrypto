"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// Import the calculateEMA function from the strategy file\nfunction calculateEMA(data, period) {\n    const ema = [];\n    const multiplier = 2 / (period + 1);\n    // First EMA uses SMA as initial value\n    let sum = 0;\n    for(let i = 0; i < period; i++){\n        sum += data[i];\n        ema.push(NaN); // Fill initial values with NaN\n    }\n    ema[period - 1] = sum / period;\n    // Calculate EMA for remaining values\n    for(let i = period; i < data.length; i++){\n        const currentValue = data[i];\n        const previousEMA = ema[i - 1];\n        const currentEMA = (currentValue - previousEMA) * multiplier + previousEMA;\n        ema.push(currentEMA);\n    }\n    return ema;\n}\nfunction CandlestickChart(param) {\n    let { timeframe, strategy } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Function to detect signals from EMA data\n    const detectEMASignals = (data, fastEMA, slowEMA)=>{\n        const markers = [];\n        for(let i = 1; i < Math.min(data.length, fastEMA.length, slowEMA.length); i++){\n            const prevFast = fastEMA[i - 1];\n            const prevSlow = slowEMA[i - 1];\n            const currFast = fastEMA[i];\n            const currSlow = slowEMA[i];\n            // Debug crossover conditions\n            console.log(\"Checking crossover:\", {\n                time: new Date(data[i].time * 1000).toLocaleString(),\n                prevFast: prevFast === null || prevFast === void 0 ? void 0 : prevFast.toFixed(2),\n                prevSlow: prevSlow === null || prevSlow === void 0 ? void 0 : prevSlow.toFixed(2),\n                currFast: currFast === null || currFast === void 0 ? void 0 : currFast.toFixed(2),\n                currSlow: currSlow === null || currSlow === void 0 ? void 0 : currSlow.toFixed(2),\n                isBuy: prevFast <= prevSlow && currFast > currSlow,\n                isSell: prevFast >= prevSlow && currFast < currSlow\n            });\n            // Only add signals if we have valid EMA values\n            if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                // Buy signal: Fast EMA crosses above Slow EMA\n                if (prevFast <= prevSlow && currFast > currSlow) {\n                    markers.push({\n                        time: data[i].time,\n                        position: \"belowBar\",\n                        color: \"#26a69a\",\n                        shape: \"arrowUp\",\n                        text: \"BUY\\n$\".concat(data[i].close.toFixed(2)),\n                        size: 2\n                    });\n                    console.log(\"\\uD83D\\uDFE2 Buy Signal Detected:\", {\n                        price: data[i].close,\n                        time: new Date(data[i].time * 1000).toLocaleString(),\n                        fastEMA: currFast.toFixed(2),\n                        slowEMA: currSlow.toFixed(2),\n                        diff: (currFast - currSlow).toFixed(2)\n                    });\n                } else if (prevFast >= prevSlow && currFast < currSlow) {\n                    markers.push({\n                        time: data[i].time,\n                        position: \"aboveBar\",\n                        color: \"#ef5350\",\n                        shape: \"arrowDown\",\n                        text: \"SELL\\n$\".concat(data[i].close.toFixed(2)),\n                        size: 2\n                    });\n                    console.log(\"\\uD83D\\uDD34 Sell Signal Detected:\", {\n                        price: data[i].close,\n                        time: new Date(data[i].time * 1000).toLocaleString(),\n                        fastEMA: currFast.toFixed(2),\n                        slowEMA: currSlow.toFixed(2),\n                        diff: (currFast - currSlow).toFixed(2)\n                    });\n                }\n            }\n        }\n        return markers;\n    };\n    // Function to safely remove a series\n    const safelyRemoveSeries = (chart, series)=>{\n        try {\n            if (series && chart) {\n                chart.removeSeries(series);\n            }\n        } catch (e) {\n            console.error(\"Error removing series:\", e);\n        }\n    };\n    // Function to update strategy indicators\n    const updateStrategyIndicators = (data, chart)=>{\n        try {\n            if (!chart || !data.length) {\n                console.log(\"Chart or data not ready, skipping update\");\n                return;\n            }\n            // Clear existing markers and indicators\n            safelyRemoveSeries(chart, markerSeriesRef.current);\n            markerSeriesRef.current = null;\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chart, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            if (strategy === \"none\") {\n                console.log(\"No strategy selected, clearing indicators\");\n                return;\n            }\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!(selectedStrategy === null || selectedStrategy === void 0 ? void 0 : selectedStrategy.indicators)) {\n                console.log(\"No indicators found for strategy:\", strategy);\n                return;\n            }\n            console.log(\"Setting up strategy:\", selectedStrategy.id);\n            // Create marker series for signals\n            markerSeriesRef.current = candlestickSeriesRef.current; // Use the candlestick series for markers\n            // Run strategy analysis and update indicators\n            const prices = data.map((d)=>d.close);\n            if (selectedStrategy.id === \"ema_crossover\" || selectedStrategy.id === \"sma_crossover\") {\n                console.log(\"Calculating \".concat(selectedStrategy.id === \"ema_crossover\" ? \"EMAs\" : \"SMAs\", \" for crossover strategy\"));\n                const fastPeriod = 9;\n                const slowPeriod = 21;\n                const fastLine = selectedStrategy.id === \"ema_crossover\" ? calculateEMA(prices, fastPeriod) : calculateSMA(prices, fastPeriod);\n                const slowLine = selectedStrategy.id === \"ema_crossover\" ? calculateEMA(prices, slowPeriod) : calculateSMA(prices, slowPeriod);\n                // Add indicator lines\n                selectedStrategy.indicators.forEach((indicator, index)=>{\n                    console.log(\"Adding indicator: \".concat(indicator.name));\n                    const colors = [\n                        \"#2962FF\",\n                        \"#FF6B6B\"\n                    ]; // Blue for fast, Red for slow\n                    const lineSeries = chart.addLineSeries({\n                        color: colors[index],\n                        lineWidth: 2,\n                        title: indicator.name,\n                        priceFormat: {\n                            type: \"price\",\n                            precision: 2,\n                            minMove: 0.01\n                        },\n                        lineStyle: 1\n                    });\n                    indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                    // Update indicator data\n                    const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                            time: data[idx].time,\n                            value: value\n                        }));\n                    lineSeries.setData(lineData);\n                });\n                // Get historical signals\n                const markers = [];\n                for(let i = 1; i < data.length; i++){\n                    const prevFast = fastLine[i - 1];\n                    const prevSlow = slowLine[i - 1];\n                    const currFast = fastLine[i];\n                    const currSlow = slowLine[i];\n                    if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                        if (prevFast <= prevSlow && currFast > currSlow) {\n                            // Buy signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"belowBar\",\n                                color: \"#26a69a\",\n                                shape: \"arrowUp\",\n                                text: \"BUY\",\n                                size: 2\n                            });\n                            console.log(\"Buy Signal at:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close,\n                                fastLine: currFast.toFixed(2),\n                                slowLine: currSlow.toFixed(2)\n                            });\n                        } else if (prevFast >= prevSlow && currFast < currSlow) {\n                            // Sell signal\n                            markers.push({\n                                time: data[i].time,\n                                position: \"aboveBar\",\n                                color: \"#ef5350\",\n                                shape: \"arrowDown\",\n                                text: \"SELL\",\n                                size: 2\n                            });\n                            console.log(\"Sell Signal at:\", {\n                                time: new Date(data[i].time * 1000).toLocaleString(),\n                                price: data[i].close,\n                                fastLine: currFast.toFixed(2),\n                                fastEMA: currFast.toFixed(2),\n                                slowEMA: currSlow.toFixed(2)\n                            });\n                        }\n                    }\n                }\n                if (markers.length > 0) {\n                    console.log(\"Setting markers:\", markers);\n                    markerSeriesRef.current.setMarkers(markers);\n                }\n            }\n        } catch (e) {\n            console.error(\"Error in updateStrategyIndicators:\", e);\n        }\n    };\n    // Update the strategy change effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Strategy changed:\", strategy);\n        if (chartRef.current) {\n            // Clear existing indicators and markers\n            safelyRemoveSeries(chartRef.current, markerSeriesRef.current);\n            markerSeriesRef.current = null;\n            indicatorSeriesRefs.current.forEach((series)=>{\n                safelyRemoveSeries(chartRef.current, series);\n            });\n            indicatorSeriesRefs.current.clear();\n            // Reinitialize strategy indicators\n            if (historicalDataRef.current.length > 0) {\n                console.log(\"Reinitializing strategy indicators with data length:\", historicalDataRef.current.length);\n                updateStrategyIndicators(historicalDataRef.current, chartRef.current);\n            }\n        }\n    }, [\n        strategy\n    ]); // Only run when strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        console.log(\"Initializing chart with timeframe:\", timeframe);\n        const formatTime = (time)=>{\n            let date;\n            if (typeof time === \"number\") {\n                date = new Date(time * 1000);\n            } else if (typeof time === \"string\") {\n                date = new Date(time);\n            } else {\n                // Handle BusinessDay format\n                const { year, month, day } = time;\n                date = new Date(year, month - 1, day);\n            }\n            const formatOptions = {\n                month: \"short\",\n                day: \"numeric\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                hour12: false\n            };\n            // For daily timeframes, don't show time\n            if (timeframe === \"1d\") {\n                delete formatOptions.hour;\n                delete formatOptions.minute;\n            }\n            return date.toLocaleString(\"en-US\", formatOptions);\n        };\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\",\n                fontSize: 12,\n                fontFamily: \"Roboto, sans-serif\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            crosshair: {\n                mode: 1,\n                vertLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                },\n                horzLine: {\n                    width: 1,\n                    color: \"#758696\",\n                    style: 3\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true,\n                secondsVisible: false\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\"\n            },\n            localization: {\n                timeFormatter: formatTime\n            },\n            watermark: {\n                visible: false\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n            ...chartOptions,\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight\n        });\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\"\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        // Fetch historical data\n        const loadData = async ()=>{\n            try {\n                const historicalData = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe);\n                console.log(\"Loaded historical data:\", historicalData.length);\n                historicalDataRef.current = historicalData;\n                candlestickSeries.setData(historicalData.map((d)=>({\n                        time: d.time,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close\n                    })));\n                // Update strategy indicators with initial data\n                updateStrategyIndicators(historicalData, chart);\n            } catch (error) {\n                console.error(\"Error loading historical data:\", error);\n            }\n        };\n        loadData();\n        chartRef.current = chart;\n        // Subscribe to real-time price updates with improved candle formation\n        let currentCandle = {\n            open: 0,\n            high: -Infinity,\n            low: Infinity,\n            close: 0,\n            time: 0\n        };\n        const getIntervalSeconds = (tf)=>{\n            switch(tf){\n                case \"1m\":\n                    return 60;\n                case \"5m\":\n                    return 300;\n                case \"15m\":\n                    return 900;\n                case \"30m\":\n                    return 1800;\n                case \"1h\":\n                    return 3600;\n                case \"4h\":\n                    return 14400;\n                case \"1d\":\n                    return 86400;\n                default:\n                    return 60;\n            }\n        };\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (candlestickSeriesRef.current) {\n                const intervalSeconds = getIntervalSeconds(timeframe);\n                const currentTimestamp = Math.floor(Date.now() / 1000);\n                const candleTimestamp = Math.floor(currentTimestamp / intervalSeconds) * intervalSeconds;\n                // If this is a new candle\n                if (candleTimestamp !== currentCandle.time) {\n                    // If there was a previous candle, finalize it\n                    if (currentCandle.time !== 0) {\n                        const newCandle = {\n                            time: currentCandle.time,\n                            open: currentCandle.open,\n                            high: currentCandle.high,\n                            low: currentCandle.low,\n                            close: currentCandle.close\n                        };\n                        candlestickSeriesRef.current.update(newCandle);\n                        // Update historical data with the new candle\n                        historicalDataRef.current = [\n                            ...historicalDataRef.current.slice(1),\n                            newCandle\n                        ];\n                    }\n                    // Start a new candle\n                    currentCandle = {\n                        time: candleTimestamp,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    };\n                    // Update candlestick series with the new candle\n                    candlestickSeriesRef.current.update(currentCandle);\n                } else {\n                    // Update existing candle\n                    if (data.value > currentCandle.high) currentCandle.high = data.value;\n                    if (data.value < currentCandle.low) currentCandle.low = data.value;\n                    currentCandle.close = data.value;\n                    // Update candlestick series with the current state\n                    candlestickSeriesRef.current.update(currentCandle);\n                }\n                // Update strategy indicators if we have a strategy selected\n                if (strategy !== \"none\" && chartRef.current && indicatorSeriesRefs.current.size > 0) {\n                    const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n                    if (selectedStrategy && selectedStrategy.id === \"ema_crossover\") {\n                        // Include the current candle in the calculations\n                        const updatedData = [\n                            ...historicalDataRef.current.slice(1),\n                            currentCandle\n                        ];\n                        const prices = updatedData.map((d)=>d.close);\n                        const fastPeriod = 9;\n                        const slowPeriod = 21;\n                        const fastEMA = calculateEMA(prices, fastPeriod);\n                        const slowEMA = calculateEMA(prices, slowPeriod);\n                        // Update the line series with new data\n                        indicatorSeriesRefs.current.forEach((series, name)=>{\n                            const emaData = (name === \"Fast EMA (9)\" ? fastEMA : slowEMA).map((value, index)=>({\n                                    time: updatedData[index].time,\n                                    value: value\n                                }));\n                            series.setData(emaData);\n                        });\n                        // Check for new signal\n                        const last = fastEMA.length - 1;\n                        const prev = last - 1;\n                        if (prev >= 0 && !isNaN(fastEMA[prev]) && !isNaN(slowEMA[prev]) && !isNaN(fastEMA[last]) && !isNaN(slowEMA[last])) {\n                            // Debug real-time crossover conditions\n                            const crossingUp = fastEMA[prev] <= slowEMA[prev] && fastEMA[last] > slowEMA[last];\n                            const crossingDown = fastEMA[prev] >= slowEMA[prev] && fastEMA[last] < slowEMA[last];\n                            if (crossingUp || crossingDown) {\n                                console.log(\"Real-time EMA Status:\", {\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    price: currentCandle.close,\n                                    prevFastEMA: fastEMA[prev].toFixed(2),\n                                    prevSlowEMA: slowEMA[prev].toFixed(2),\n                                    currFastEMA: fastEMA[last].toFixed(2),\n                                    currSlowEMA: slowEMA[last].toFixed(2),\n                                    signal: crossingUp ? \"BUY\" : \"SELL\"\n                                });\n                            }\n                            let newMarker = null;\n                            if (crossingUp) {\n                                // Buy signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"belowBar\",\n                                    color: \"#26a69a\",\n                                    shape: \"arrowUp\",\n                                    text: \"BUY\",\n                                    size: 2\n                                };\n                                console.log(\"\\uD83D\\uDFE2 Real-time Buy Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    fastEMA: fastEMA[last].toFixed(2),\n                                    slowEMA: slowEMA[last].toFixed(2),\n                                    diff: (fastEMA[last] - slowEMA[last]).toFixed(2)\n                                });\n                            } else if (crossingDown) {\n                                // Sell signal\n                                newMarker = {\n                                    time: currentCandle.time,\n                                    position: \"aboveBar\",\n                                    color: \"#ef5350\",\n                                    shape: \"arrowDown\",\n                                    text: \"SELL\",\n                                    size: 2\n                                };\n                                console.log(\"\\uD83D\\uDD34 Real-time Sell Signal:\", {\n                                    price: currentCandle.close,\n                                    time: new Date(currentCandle.time * 1000).toLocaleString(),\n                                    fastEMA: fastEMA[last].toFixed(2),\n                                    slowEMA: slowEMA[last].toFixed(2),\n                                    diff: (fastEMA[last] - slowEMA[last]).toFixed(2)\n                                });\n                            }\n                            // Add new marker if signal detected\n                            if (newMarker && candlestickSeriesRef.current) {\n                                const currentMarkers = candlestickSeriesRef.current.markers() || [];\n                                const signalExists = currentMarkers.some((m)=>m.time === newMarker.time && m.text === newMarker.text);\n                                if (!signalExists) {\n                                    candlestickSeriesRef.current.setMarkers([\n                                        ...currentMarkers,\n                                        newMarker\n                                    ]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }, timeframe);\n        // Remove TradingView logo elements if they exist\n        const removeTradingViewLogo = ()=>{\n            const logoElement = document.getElementById(\"tv-attr-logo\");\n            if (logoElement) {\n                logoElement.remove();\n            }\n            const headerLogo = document.querySelector(\".tv-header__link\");\n            if (headerLogo) {\n                headerLogo.remove();\n            }\n        };\n        // Run logo removal after chart is created\n        removeTradingViewLogo();\n        // Also run after a short delay to catch dynamically added elements\n        const logoTimeoutId = setTimeout(removeTradingViewLogo, 100);\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(logoTimeoutId);\n            unsubscribe();\n            if (chartRef.current) {\n                chartRef.current.remove();\n            }\n        };\n    }, [\n        timeframe,\n        strategy\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full h-full\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 588,\n        columnNumber: 10\n    }, this);\n}\n_s(CandlestickChart, \"79wJC2kgSopMt/NxaIK+M+7bdVo=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUMwQztBQUNzRjtBQUMvQjtBQUNqQztBQUVoRSwwREFBMEQ7QUFDMUQsU0FBU00sYUFBYUMsSUFBYyxFQUFFQyxNQUFjO0lBQ2xELE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsYUFBYSxJQUFLRixDQUFBQSxTQUFTO0lBRWpDLHNDQUFzQztJQUN0QyxJQUFJRyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JELE9BQU9KLElBQUksQ0FBQ0ssRUFBRTtRQUNkSCxJQUFJSSxJQUFJLENBQUNDLE1BQU0sK0JBQStCO0lBQ2hEO0lBQ0FMLEdBQUcsQ0FBQ0QsU0FBUyxFQUFFLEdBQUdHLE1BQU1IO0lBRXhCLHFDQUFxQztJQUNyQyxJQUFLLElBQUlJLElBQUlKLFFBQVFJLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztRQUN6QyxNQUFNSSxlQUFlVCxJQUFJLENBQUNLLEVBQUU7UUFDNUIsTUFBTUssY0FBY1IsR0FBRyxDQUFDRyxJQUFJLEVBQUU7UUFDOUIsTUFBTU0sYUFBYSxDQUFDRixlQUFlQyxXQUFVLElBQUtQLGFBQWFPO1FBQy9EUixJQUFJSSxJQUFJLENBQUNLO0lBQ1g7SUFFQSxPQUFPVDtBQUNUO0FBV08sU0FBU1UsaUJBQWlCLEtBQThDO1FBQTlDLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUF5QixHQUE5Qzs7SUFDL0IsTUFBTUMsb0JBQW9CckIsNkNBQU1BLENBQWlCO0lBQ2pELE1BQU1zQixXQUFXdEIsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU11Qix1QkFBdUJ2Qiw2Q0FBTUEsQ0FBTTtJQUN6QyxNQUFNd0Isc0JBQXNCeEIsNkNBQU1BLENBQW1CLElBQUl5QjtJQUN6RCxNQUFNQyxvQkFBb0IxQiw2Q0FBTUEsQ0FBUSxFQUFFO0lBQzFDLE1BQU0yQixrQkFBa0IzQiw2Q0FBTUEsQ0FBTTtJQUVwQywyQ0FBMkM7SUFDM0MsTUFBTTRCLG1CQUFtQixDQUFDdEIsTUFBYXVCLFNBQW1CQztRQUN4RCxNQUFNQyxVQUFpQixFQUFFO1FBQ3pCLElBQUssSUFBSXBCLElBQUksR0FBR0EsSUFBSXFCLEtBQUtDLEdBQUcsQ0FBQzNCLEtBQUtRLE1BQU0sRUFBRWUsUUFBUWYsTUFBTSxFQUFFZ0IsUUFBUWhCLE1BQU0sR0FBR0gsSUFBSztZQUM5RSxNQUFNdUIsV0FBV0wsT0FBTyxDQUFDbEIsSUFBSSxFQUFFO1lBQy9CLE1BQU13QixXQUFXTCxPQUFPLENBQUNuQixJQUFJLEVBQUU7WUFDL0IsTUFBTXlCLFdBQVdQLE9BQU8sQ0FBQ2xCLEVBQUU7WUFDM0IsTUFBTTBCLFdBQVdQLE9BQU8sQ0FBQ25CLEVBQUU7WUFFM0IsNkJBQTZCO1lBQzdCMkIsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QjtnQkFDakNDLE1BQU0sSUFBSUMsS0FBS25DLElBQUksQ0FBQ0ssRUFBRSxDQUFDNkIsSUFBSSxHQUFHLE1BQU1FLGNBQWM7Z0JBQ2xEUixRQUFRLEVBQUVBLHFCQUFBQSwrQkFBQUEsU0FBVVMsT0FBTyxDQUFDO2dCQUM1QlIsUUFBUSxFQUFFQSxxQkFBQUEsK0JBQUFBLFNBQVVRLE9BQU8sQ0FBQztnQkFDNUJQLFFBQVEsRUFBRUEscUJBQUFBLCtCQUFBQSxTQUFVTyxPQUFPLENBQUM7Z0JBQzVCTixRQUFRLEVBQUVBLHFCQUFBQSwrQkFBQUEsU0FBVU0sT0FBTyxDQUFDO2dCQUM1QkMsT0FBT1YsWUFBWUMsWUFBWUMsV0FBV0M7Z0JBQzFDUSxRQUFRWCxZQUFZQyxZQUFZQyxXQUFXQztZQUM3QztZQUVBLCtDQUErQztZQUMvQyxJQUFJLENBQUNTLE1BQU1aLGFBQWEsQ0FBQ1ksTUFBTVgsYUFBYSxDQUFDVyxNQUFNVixhQUFhLENBQUNVLE1BQU1ULFdBQVc7Z0JBQ2hGLDhDQUE4QztnQkFDOUMsSUFBSUgsWUFBWUMsWUFBWUMsV0FBV0MsVUFBVTtvQkFDL0NOLFFBQVFuQixJQUFJLENBQUM7d0JBQ1g0QixNQUFNbEMsSUFBSSxDQUFDSyxFQUFFLENBQUM2QixJQUFJO3dCQUNsQk8sVUFBVTt3QkFDVkMsT0FBTzt3QkFDUEMsT0FBTzt3QkFDUEMsTUFBTSxTQUFrQyxPQUF6QjVDLElBQUksQ0FBQ0ssRUFBRSxDQUFDd0MsS0FBSyxDQUFDUixPQUFPLENBQUM7d0JBQ3JDUyxNQUFNO29CQUNSO29CQUNBZCxRQUFRQyxHQUFHLENBQUMscUNBQTJCO3dCQUNyQ2MsT0FBTy9DLElBQUksQ0FBQ0ssRUFBRSxDQUFDd0MsS0FBSzt3QkFDcEJYLE1BQU0sSUFBSUMsS0FBS25DLElBQUksQ0FBQ0ssRUFBRSxDQUFDNkIsSUFBSSxHQUFHLE1BQU1FLGNBQWM7d0JBQ2xEYixTQUFTTyxTQUFTTyxPQUFPLENBQUM7d0JBQzFCYixTQUFTTyxTQUFTTSxPQUFPLENBQUM7d0JBQzFCVyxNQUFNLENBQUNsQixXQUFXQyxRQUFPLEVBQUdNLE9BQU8sQ0FBQztvQkFDdEM7Z0JBQ0YsT0FFSyxJQUFJVCxZQUFZQyxZQUFZQyxXQUFXQyxVQUFVO29CQUNwRE4sUUFBUW5CLElBQUksQ0FBQzt3QkFDWDRCLE1BQU1sQyxJQUFJLENBQUNLLEVBQUUsQ0FBQzZCLElBQUk7d0JBQ2xCTyxVQUFVO3dCQUNWQyxPQUFPO3dCQUNQQyxPQUFPO3dCQUNQQyxNQUFNLFVBQW1DLE9BQXpCNUMsSUFBSSxDQUFDSyxFQUFFLENBQUN3QyxLQUFLLENBQUNSLE9BQU8sQ0FBQzt3QkFDdENTLE1BQU07b0JBQ1I7b0JBQ0FkLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBNEI7d0JBQ3RDYyxPQUFPL0MsSUFBSSxDQUFDSyxFQUFFLENBQUN3QyxLQUFLO3dCQUNwQlgsTUFBTSxJQUFJQyxLQUFLbkMsSUFBSSxDQUFDSyxFQUFFLENBQUM2QixJQUFJLEdBQUcsTUFBTUUsY0FBYzt3QkFDbERiLFNBQVNPLFNBQVNPLE9BQU8sQ0FBQzt3QkFDMUJiLFNBQVNPLFNBQVNNLE9BQU8sQ0FBQzt3QkFDMUJXLE1BQU0sQ0FBQ2xCLFdBQVdDLFFBQU8sRUFBR00sT0FBTyxDQUFDO29CQUN0QztnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxPQUFPWjtJQUNUO0lBRUEscUNBQXFDO0lBQ3JDLE1BQU13QixxQkFBcUIsQ0FBQ0MsT0FBa0JDO1FBQzVDLElBQUk7WUFDRixJQUFJQSxVQUFVRCxPQUFPO2dCQUNuQkEsTUFBTUUsWUFBWSxDQUFDRDtZQUNyQjtRQUNGLEVBQUUsT0FBT0UsR0FBRztZQUNWckIsUUFBUXNCLEtBQUssQ0FBQywwQkFBMEJEO1FBQzFDO0lBQ0Y7SUFFQSx5Q0FBeUM7SUFDekMsTUFBTUUsMkJBQTJCLENBQUN2RCxNQUFha0Q7UUFDN0MsSUFBSTtZQUNGLElBQUksQ0FBQ0EsU0FBUyxDQUFDbEQsS0FBS1EsTUFBTSxFQUFFO2dCQUMxQndCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsd0NBQXdDO1lBQ3hDZ0IsbUJBQW1CQyxPQUFPN0IsZ0JBQWdCbUMsT0FBTztZQUNqRG5DLGdCQUFnQm1DLE9BQU8sR0FBRztZQUUxQnRDLG9CQUFvQnNDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDTixDQUFBQTtnQkFDbENGLG1CQUFtQkMsT0FBT0M7WUFDNUI7WUFDQWpDLG9CQUFvQnNDLE9BQU8sQ0FBQ0UsS0FBSztZQUVqQyxJQUFJNUMsYUFBYSxRQUFRO2dCQUN2QmtCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUEsTUFBTTBCLG1CQUFtQjdELGlFQUFXQSxDQUFDZ0I7WUFDckMsSUFBSSxFQUFDNkMsNkJBQUFBLHVDQUFBQSxpQkFBa0JDLFVBQVUsR0FBRTtnQkFDakM1QixRQUFRQyxHQUFHLENBQUMscUNBQXFDbkI7Z0JBQ2pEO1lBQ0Y7WUFFQWtCLFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0IwQixpQkFBaUJFLEVBQUU7WUFFdkQsbUNBQW1DO1lBQ25DeEMsZ0JBQWdCbUMsT0FBTyxHQUFHdkMscUJBQXFCdUMsT0FBTyxFQUFHLHlDQUF5QztZQUVsRyw4Q0FBOEM7WUFDOUMsTUFBTU0sU0FBUzlELEtBQUsrRCxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVuQixLQUFLO1lBRXBDLElBQUljLGlCQUFpQkUsRUFBRSxLQUFLLG1CQUFtQkYsaUJBQWlCRSxFQUFFLEtBQUssaUJBQWlCO2dCQUN0RjdCLFFBQVFDLEdBQUcsQ0FBQyxlQUF5RSxPQUExRDBCLGlCQUFpQkUsRUFBRSxLQUFLLGtCQUFrQixTQUFTLFFBQU87Z0JBQ3JGLE1BQU1JLGFBQWE7Z0JBQ25CLE1BQU1DLGFBQWE7Z0JBQ25CLE1BQU1DLFdBQVdSLGlCQUFpQkUsRUFBRSxLQUFLLGtCQUNyQzlELGFBQWErRCxRQUFRRyxjQUNyQkcsYUFBYU4sUUFBUUc7Z0JBQ3pCLE1BQU1JLFdBQVdWLGlCQUFpQkUsRUFBRSxLQUFLLGtCQUNyQzlELGFBQWErRCxRQUFRSSxjQUNyQkUsYUFBYU4sUUFBUUk7Z0JBRXpCLHNCQUFzQjtnQkFDdEJQLGlCQUFpQkMsVUFBVSxDQUFDSCxPQUFPLENBQUMsQ0FBQ2EsV0FBV0M7b0JBQzlDdkMsUUFBUUMsR0FBRyxDQUFDLHFCQUFvQyxPQUFmcUMsVUFBVUUsSUFBSTtvQkFDL0MsTUFBTUMsU0FBUzt3QkFBQzt3QkFBVztxQkFBVSxFQUFFLDhCQUE4QjtvQkFDckUsTUFBTUMsYUFBYXhCLE1BQU15QixhQUFhLENBQUM7d0JBQ3JDakMsT0FBTytCLE1BQU0sQ0FBQ0YsTUFBTTt3QkFDcEJLLFdBQVc7d0JBQ1hDLE9BQU9QLFVBQVVFLElBQUk7d0JBQ3JCTSxhQUFhOzRCQUNYQyxNQUFNOzRCQUNOQyxXQUFXOzRCQUNYQyxTQUFTO3dCQUNYO3dCQUNBQyxXQUFXO29CQUNiO29CQUNBaEUsb0JBQW9Cc0MsT0FBTyxDQUFDMkIsR0FBRyxDQUFDYixVQUFVRSxJQUFJLEVBQUVFO29CQUVoRCx3QkFBd0I7b0JBQ3hCLE1BQU1VLFdBQVcsQ0FBQ2IsVUFBVSxJQUFJSixXQUFXRSxRQUFPLEVBQUdOLEdBQUcsQ0FBQyxDQUFDc0IsT0FBT0MsTUFBUzs0QkFDeEVwRCxNQUFNbEMsSUFBSSxDQUFDc0YsSUFBSSxDQUFDcEQsSUFBSTs0QkFDcEJtRCxPQUFPQTt3QkFDVDtvQkFDQVgsV0FBV2EsT0FBTyxDQUFDSDtnQkFDckI7Z0JBRUEseUJBQXlCO2dCQUN6QixNQUFNM0QsVUFBVSxFQUFFO2dCQUNsQixJQUFLLElBQUlwQixJQUFJLEdBQUdBLElBQUlMLEtBQUtRLE1BQU0sRUFBRUgsSUFBSztvQkFDcEMsTUFBTXVCLFdBQVd1QyxRQUFRLENBQUM5RCxJQUFJLEVBQUU7b0JBQ2hDLE1BQU13QixXQUFXd0MsUUFBUSxDQUFDaEUsSUFBSSxFQUFFO29CQUNoQyxNQUFNeUIsV0FBV3FDLFFBQVEsQ0FBQzlELEVBQUU7b0JBQzVCLE1BQU0wQixXQUFXc0MsUUFBUSxDQUFDaEUsRUFBRTtvQkFFNUIsSUFBSSxDQUFDbUMsTUFBTVosYUFBYSxDQUFDWSxNQUFNWCxhQUFhLENBQUNXLE1BQU1WLGFBQWEsQ0FBQ1UsTUFBTVQsV0FBVzt3QkFDaEYsSUFBSUgsWUFBWUMsWUFBWUMsV0FBV0MsVUFBVTs0QkFDL0MsYUFBYTs0QkFDYk4sUUFBUW5CLElBQUksQ0FBQztnQ0FDWDRCLE1BQU1sQyxJQUFJLENBQUNLLEVBQUUsQ0FBQzZCLElBQUk7Z0NBQ2xCTyxVQUFVO2dDQUNWQyxPQUFPO2dDQUNQQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNORSxNQUFNOzRCQUNSOzRCQUNBZCxRQUFRQyxHQUFHLENBQUMsa0JBQWtCO2dDQUM1QkMsTUFBTSxJQUFJQyxLQUFLbkMsSUFBSSxDQUFDSyxFQUFFLENBQUM2QixJQUFJLEdBQUcsTUFBTUUsY0FBYztnQ0FDbERXLE9BQU8vQyxJQUFJLENBQUNLLEVBQUUsQ0FBQ3dDLEtBQUs7Z0NBQ3BCc0IsVUFBVXJDLFNBQVNPLE9BQU8sQ0FBQztnQ0FDM0JnQyxVQUFVdEMsU0FBU00sT0FBTyxDQUFDOzRCQUM3Qjt3QkFDRixPQUFPLElBQUlULFlBQVlDLFlBQVlDLFdBQVdDLFVBQVU7NEJBQ3RELGNBQWM7NEJBQ2ROLFFBQVFuQixJQUFJLENBQUM7Z0NBQ1g0QixNQUFNbEMsSUFBSSxDQUFDSyxFQUFFLENBQUM2QixJQUFJO2dDQUNsQk8sVUFBVTtnQ0FDVkMsT0FBTztnQ0FDUEMsT0FBTztnQ0FDUEMsTUFBTTtnQ0FDTkUsTUFBTTs0QkFDUjs0QkFDQWQsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQjtnQ0FDN0JDLE1BQU0sSUFBSUMsS0FBS25DLElBQUksQ0FBQ0ssRUFBRSxDQUFDNkIsSUFBSSxHQUFHLE1BQU1FLGNBQWM7Z0NBQ2xEVyxPQUFPL0MsSUFBSSxDQUFDSyxFQUFFLENBQUN3QyxLQUFLO2dDQUNwQnNCLFVBQVVyQyxTQUFTTyxPQUFPLENBQUM7Z0NBQzNCZCxTQUFTTyxTQUFTTyxPQUFPLENBQUM7Z0NBQzFCYixTQUFTTyxTQUFTTSxPQUFPLENBQUM7NEJBQzVCO3dCQUNGO29CQUNGO2dCQUNGO2dCQUVBLElBQUlaLFFBQVFqQixNQUFNLEdBQUcsR0FBRztvQkFDdEJ3QixRQUFRQyxHQUFHLENBQUMsb0JBQW9CUjtvQkFDaENKLGdCQUFnQm1DLE9BQU8sQ0FBQ2dDLFVBQVUsQ0FBQy9EO2dCQUNyQztZQUNGO1FBQ0YsRUFBRSxPQUFPNEIsR0FBRztZQUNWckIsUUFBUXNCLEtBQUssQ0FBQyxzQ0FBc0NEO1FBQ3REO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEM1RCxnREFBU0EsQ0FBQztRQUNSdUMsUUFBUUMsR0FBRyxDQUFDLHFCQUFxQm5CO1FBRWpDLElBQUlFLFNBQVN3QyxPQUFPLEVBQUU7WUFDcEIsd0NBQXdDO1lBQ3hDUCxtQkFBbUJqQyxTQUFTd0MsT0FBTyxFQUFFbkMsZ0JBQWdCbUMsT0FBTztZQUM1RG5DLGdCQUFnQm1DLE9BQU8sR0FBRztZQUUxQnRDLG9CQUFvQnNDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDTixDQUFBQTtnQkFDbENGLG1CQUFtQmpDLFNBQVN3QyxPQUFPLEVBQUdMO1lBQ3hDO1lBQ0FqQyxvQkFBb0JzQyxPQUFPLENBQUNFLEtBQUs7WUFFakMsbUNBQW1DO1lBQ25DLElBQUl0QyxrQkFBa0JvQyxPQUFPLENBQUNoRCxNQUFNLEdBQUcsR0FBRztnQkFDeEN3QixRQUFRQyxHQUFHLENBQUMsd0RBQXdEYixrQkFBa0JvQyxPQUFPLENBQUNoRCxNQUFNO2dCQUNwRytDLHlCQUF5Qm5DLGtCQUFrQm9DLE9BQU8sRUFBRXhDLFNBQVN3QyxPQUFPO1lBQ3RFO1FBQ0Y7SUFDRixHQUFHO1FBQUMxQztLQUFTLEdBQUcsaUNBQWlDO0lBRWpEckIsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNzQixrQkFBa0J5QyxPQUFPLEVBQUU7UUFDaEN4QixRQUFRQyxHQUFHLENBQUMsc0NBQXNDcEI7UUFFbEQsTUFBTTRFLGFBQWEsQ0FBQ3ZEO1lBQ2xCLElBQUl3RDtZQUVKLElBQUksT0FBT3hELFNBQVMsVUFBVTtnQkFDNUJ3RCxPQUFPLElBQUl2RCxLQUFLRCxPQUFPO1lBQ3pCLE9BQU8sSUFBSSxPQUFPQSxTQUFTLFVBQVU7Z0JBQ25Dd0QsT0FBTyxJQUFJdkQsS0FBS0Q7WUFDbEIsT0FBTztnQkFDTCw0QkFBNEI7Z0JBQzVCLE1BQU0sRUFBRXlELElBQUksRUFBRUMsS0FBSyxFQUFFQyxHQUFHLEVBQUUsR0FBRzNEO2dCQUM3QndELE9BQU8sSUFBSXZELEtBQUt3RCxNQUFNQyxRQUFRLEdBQUdDO1lBQ25DO1lBRUEsTUFBTUMsZ0JBQTRDO2dCQUNoREYsT0FBTztnQkFDUEMsS0FBSztnQkFDTEUsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsUUFBUTtZQUNWO1lBRUEsd0NBQXdDO1lBQ3hDLElBQUlwRixjQUFjLE1BQU07Z0JBQ3RCLE9BQU9pRixjQUFjQyxJQUFJO2dCQUN6QixPQUFPRCxjQUFjRSxNQUFNO1lBQzdCO1lBRUEsT0FBT04sS0FBS3RELGNBQWMsQ0FBQyxTQUFTMEQ7UUFDdEM7UUFFQSxNQUFNSSxlQUEwQztZQUM5Q0MsUUFBUTtnQkFDTkMsWUFBWTtvQkFBRTFELE9BQU87Z0JBQVU7Z0JBQy9CMkQsV0FBVztnQkFDWEMsVUFBVTtnQkFDVkMsWUFBWTtZQUNkO1lBQ0FDLE1BQU07Z0JBQ0pDLFdBQVc7b0JBQUUvRCxPQUFPO2dCQUFVO2dCQUM5QmdFLFdBQVc7b0JBQUVoRSxPQUFPO2dCQUFVO1lBQ2hDO1lBQ0FpRSxXQUFXO2dCQUNUQyxNQUFNO2dCQUNOQyxVQUFVO29CQUNSQyxPQUFPO29CQUNQcEUsT0FBTztvQkFDUHFFLE9BQU87Z0JBQ1Q7Z0JBQ0FDLFVBQVU7b0JBQ1JGLE9BQU87b0JBQ1BwRSxPQUFPO29CQUNQcUUsT0FBTztnQkFDVDtZQUNGO1lBQ0FFLFdBQVc7Z0JBQ1RDLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JDLGdCQUFnQjtZQUNsQjtZQUNBQyxpQkFBaUI7Z0JBQ2ZILGFBQWE7WUFDZjtZQUNBSSxjQUFjO2dCQUNaQyxlQUFlOUI7WUFDakI7WUFDQStCLFdBQVc7Z0JBQ1RDLFNBQVM7WUFDWDtRQUNGO1FBRUEsTUFBTXZFLFFBQVF2RCwrREFBV0EsQ0FBQ29CLGtCQUFrQnlDLE9BQU8sRUFBRTtZQUNuRCxHQUFHMEMsWUFBWTtZQUNmWSxPQUFPL0Ysa0JBQWtCeUMsT0FBTyxDQUFDa0UsV0FBVztZQUM1Q0MsUUFBUTVHLGtCQUFrQnlDLE9BQU8sQ0FBQ29FLFlBQVk7UUFDaEQ7UUFFQSxNQUFNQyxvQkFBb0IzRSxNQUFNNEUsb0JBQW9CLENBQUM7WUFDbkRDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxlQUFlO1lBQ2ZDLGFBQWE7WUFDYkMsZUFBZTtRQUNqQjtRQUVBbEgscUJBQXFCdUMsT0FBTyxHQUFHcUU7UUFFL0Isd0JBQXdCO1FBQ3hCLE1BQU1PLFdBQVc7WUFDZixJQUFJO2dCQUNGLE1BQU1DLGlCQUFpQixNQUFNekksaUZBQWlCQSxDQUFDaUI7Z0JBQy9DbUIsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQm9HLGVBQWU3SCxNQUFNO2dCQUM1RFksa0JBQWtCb0MsT0FBTyxHQUFHNkU7Z0JBQzVCUixrQkFBa0J0QyxPQUFPLENBQUM4QyxlQUFldEUsR0FBRyxDQUFDQyxDQUFBQSxJQUFNO3dCQUNqRDlCLE1BQU04QixFQUFFOUIsSUFBSTt3QkFDWm9HLE1BQU10RSxFQUFFc0UsSUFBSTt3QkFDWkMsTUFBTXZFLEVBQUV1RSxJQUFJO3dCQUNaQyxLQUFLeEUsRUFBRXdFLEdBQUc7d0JBQ1YzRixPQUFPbUIsRUFBRW5CLEtBQUs7b0JBQ2hCO2dCQUVBLCtDQUErQztnQkFDL0NVLHlCQUF5QjhFLGdCQUFnQm5GO1lBQzNDLEVBQUUsT0FBT0ksT0FBTztnQkFDZHRCLFFBQVFzQixLQUFLLENBQUMsa0NBQWtDQTtZQUNsRDtRQUNGO1FBRUE4RTtRQUNBcEgsU0FBU3dDLE9BQU8sR0FBR047UUFFbkIsc0VBQXNFO1FBQ3RFLElBQUl1RixnQkFBZ0I7WUFDbEJILE1BQU07WUFDTkMsTUFBTSxDQUFDRztZQUNQRixLQUFLRTtZQUNMN0YsT0FBTztZQUNQWCxNQUFNO1FBQ1I7UUFFQSxNQUFNeUcscUJBQXFCLENBQUNDO1lBQzFCLE9BQVFBO2dCQUNOLEtBQUs7b0JBQU0sT0FBTztnQkFDbEIsS0FBSztvQkFBTSxPQUFPO2dCQUNsQixLQUFLO29CQUFPLE9BQU87Z0JBQ25CLEtBQUs7b0JBQU8sT0FBTztnQkFDbkIsS0FBSztvQkFBTSxPQUFPO2dCQUNsQixLQUFLO29CQUFNLE9BQU87Z0JBQ2xCLEtBQUs7b0JBQU0sT0FBTztnQkFDbEI7b0JBQVMsT0FBTztZQUNsQjtRQUNGO1FBRUEsTUFBTUMsY0FBY2hKLGdGQUFnQkEsQ0FBQyxDQUFDRztZQUNwQyxJQUFJaUIscUJBQXFCdUMsT0FBTyxFQUFFO2dCQUNoQyxNQUFNc0Ysa0JBQWtCSCxtQkFBbUI5SDtnQkFDM0MsTUFBTWtJLG1CQUFtQnJILEtBQUtzSCxLQUFLLENBQUM3RyxLQUFLOEcsR0FBRyxLQUFLO2dCQUNqRCxNQUFNQyxrQkFBa0J4SCxLQUFLc0gsS0FBSyxDQUFDRCxtQkFBbUJELG1CQUFtQkE7Z0JBRXpFLDBCQUEwQjtnQkFDMUIsSUFBSUksb0JBQW9CVCxjQUFjdkcsSUFBSSxFQUFFO29CQUMxQyw4Q0FBOEM7b0JBQzlDLElBQUl1RyxjQUFjdkcsSUFBSSxLQUFLLEdBQUc7d0JBQzVCLE1BQU1pSCxZQUFZOzRCQUNoQmpILE1BQU11RyxjQUFjdkcsSUFBSTs0QkFDeEJvRyxNQUFNRyxjQUFjSCxJQUFJOzRCQUN4QkMsTUFBTUUsY0FBY0YsSUFBSTs0QkFDeEJDLEtBQUtDLGNBQWNELEdBQUc7NEJBQ3RCM0YsT0FBTzRGLGNBQWM1RixLQUFLO3dCQUM1Qjt3QkFDQTVCLHFCQUFxQnVDLE9BQU8sQ0FBQzRGLE1BQU0sQ0FBQ0Q7d0JBRXBDLDZDQUE2Qzt3QkFDN0MvSCxrQkFBa0JvQyxPQUFPLEdBQUc7K0JBQUlwQyxrQkFBa0JvQyxPQUFPLENBQUM2RixLQUFLLENBQUM7NEJBQUlGO3lCQUFVO29CQUNoRjtvQkFFQSxxQkFBcUI7b0JBQ3JCVixnQkFBZ0I7d0JBQ2R2RyxNQUFNZ0g7d0JBQ05aLE1BQU10SSxLQUFLcUYsS0FBSzt3QkFDaEJrRCxNQUFNdkksS0FBS3FGLEtBQUs7d0JBQ2hCbUQsS0FBS3hJLEtBQUtxRixLQUFLO3dCQUNmeEMsT0FBTzdDLEtBQUtxRixLQUFLO29CQUNuQjtvQkFFQSxnREFBZ0Q7b0JBQ2hEcEUscUJBQXFCdUMsT0FBTyxDQUFDNEYsTUFBTSxDQUFDWDtnQkFDdEMsT0FBTztvQkFDTCx5QkFBeUI7b0JBQ3pCLElBQUl6SSxLQUFLcUYsS0FBSyxHQUFHb0QsY0FBY0YsSUFBSSxFQUFFRSxjQUFjRixJQUFJLEdBQUd2SSxLQUFLcUYsS0FBSztvQkFDcEUsSUFBSXJGLEtBQUtxRixLQUFLLEdBQUdvRCxjQUFjRCxHQUFHLEVBQUVDLGNBQWNELEdBQUcsR0FBR3hJLEtBQUtxRixLQUFLO29CQUNsRW9ELGNBQWM1RixLQUFLLEdBQUc3QyxLQUFLcUYsS0FBSztvQkFFaEMsbURBQW1EO29CQUNuRHBFLHFCQUFxQnVDLE9BQU8sQ0FBQzRGLE1BQU0sQ0FBQ1g7Z0JBQ3RDO2dCQUVBLDREQUE0RDtnQkFDNUQsSUFBSTNILGFBQWEsVUFBVUUsU0FBU3dDLE9BQU8sSUFBSXRDLG9CQUFvQnNDLE9BQU8sQ0FBQ1YsSUFBSSxHQUFHLEdBQUc7b0JBQ25GLE1BQU1hLG1CQUFtQjdELGlFQUFXQSxDQUFDZ0I7b0JBQ3JDLElBQUk2QyxvQkFBb0JBLGlCQUFpQkUsRUFBRSxLQUFLLGlCQUFpQjt3QkFDL0QsaURBQWlEO3dCQUNqRCxNQUFNeUYsY0FBYzsrQkFBSWxJLGtCQUFrQm9DLE9BQU8sQ0FBQzZGLEtBQUssQ0FBQzs0QkFBSVo7eUJBQWM7d0JBQzFFLE1BQU0zRSxTQUFTd0YsWUFBWXZGLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5CLEtBQUs7d0JBQzNDLE1BQU1vQixhQUFhO3dCQUNuQixNQUFNQyxhQUFhO3dCQUNuQixNQUFNM0MsVUFBVXhCLGFBQWErRCxRQUFRRzt3QkFDckMsTUFBTXpDLFVBQVV6QixhQUFhK0QsUUFBUUk7d0JBRXJDLHVDQUF1Qzt3QkFDdkNoRCxvQkFBb0JzQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDTixRQUFRcUI7NEJBQzNDLE1BQU0rRSxVQUFVLENBQUMvRSxTQUFTLGlCQUFpQmpELFVBQVVDLE9BQU0sRUFBR3VDLEdBQUcsQ0FBQyxDQUFDc0IsT0FBT2QsUUFBVztvQ0FDbkZyQyxNQUFNb0gsV0FBVyxDQUFDL0UsTUFBTSxDQUFDckMsSUFBSTtvQ0FDN0JtRCxPQUFPQTtnQ0FDVDs0QkFDQWxDLE9BQU9vQyxPQUFPLENBQUNnRTt3QkFDakI7d0JBRUEsdUJBQXVCO3dCQUN2QixNQUFNQyxPQUFPakksUUFBUWYsTUFBTSxHQUFHO3dCQUM5QixNQUFNaUosT0FBT0QsT0FBTzt3QkFDcEIsSUFBSUMsUUFBUSxLQUFLLENBQUNqSCxNQUFNakIsT0FBTyxDQUFDa0ksS0FBSyxLQUFLLENBQUNqSCxNQUFNaEIsT0FBTyxDQUFDaUksS0FBSyxLQUMxRCxDQUFDakgsTUFBTWpCLE9BQU8sQ0FBQ2lJLEtBQUssS0FBSyxDQUFDaEgsTUFBTWhCLE9BQU8sQ0FBQ2dJLEtBQUssR0FBRzs0QkFFbEQsdUNBQXVDOzRCQUN2QyxNQUFNRSxhQUFhbkksT0FBTyxDQUFDa0ksS0FBSyxJQUFJakksT0FBTyxDQUFDaUksS0FBSyxJQUFJbEksT0FBTyxDQUFDaUksS0FBSyxHQUFHaEksT0FBTyxDQUFDZ0ksS0FBSzs0QkFDbEYsTUFBTUcsZUFBZXBJLE9BQU8sQ0FBQ2tJLEtBQUssSUFBSWpJLE9BQU8sQ0FBQ2lJLEtBQUssSUFBSWxJLE9BQU8sQ0FBQ2lJLEtBQUssR0FBR2hJLE9BQU8sQ0FBQ2dJLEtBQUs7NEJBRXBGLElBQUlFLGNBQWNDLGNBQWM7Z0NBQzlCM0gsUUFBUUMsR0FBRyxDQUFDLHlCQUF5QjtvQ0FDbkNDLE1BQU0sSUFBSUMsS0FBS3NHLGNBQWN2RyxJQUFJLEdBQUcsTUFBTUUsY0FBYztvQ0FDeERXLE9BQU8wRixjQUFjNUYsS0FBSztvQ0FDMUIrRyxhQUFhckksT0FBTyxDQUFDa0ksS0FBSyxDQUFDcEgsT0FBTyxDQUFDO29DQUNuQ3dILGFBQWFySSxPQUFPLENBQUNpSSxLQUFLLENBQUNwSCxPQUFPLENBQUM7b0NBQ25DeUgsYUFBYXZJLE9BQU8sQ0FBQ2lJLEtBQUssQ0FBQ25ILE9BQU8sQ0FBQztvQ0FDbkMwSCxhQUFhdkksT0FBTyxDQUFDZ0ksS0FBSyxDQUFDbkgsT0FBTyxDQUFDO29DQUNuQzJILFFBQVFOLGFBQWEsUUFBUTtnQ0FDL0I7NEJBQ0Y7NEJBRUEsSUFBSU8sWUFBWTs0QkFDaEIsSUFBSVAsWUFBWTtnQ0FDZCxhQUFhO2dDQUNiTyxZQUFZO29DQUNWL0gsTUFBTXVHLGNBQWN2RyxJQUFJO29DQUN4Qk8sVUFBVTtvQ0FDVkMsT0FBTztvQ0FDUEMsT0FBTztvQ0FDUEMsTUFBTTtvQ0FDTkUsTUFBTTtnQ0FDUjtnQ0FDQWQsUUFBUUMsR0FBRyxDQUFDLHNDQUE0QjtvQ0FDdENjLE9BQU8wRixjQUFjNUYsS0FBSztvQ0FDMUJYLE1BQU0sSUFBSUMsS0FBS3NHLGNBQWN2RyxJQUFJLEdBQUcsTUFBTUUsY0FBYztvQ0FDeERiLFNBQVNBLE9BQU8sQ0FBQ2lJLEtBQUssQ0FBQ25ILE9BQU8sQ0FBQztvQ0FDL0JiLFNBQVNBLE9BQU8sQ0FBQ2dJLEtBQUssQ0FBQ25ILE9BQU8sQ0FBQztvQ0FDL0JXLE1BQU0sQ0FBQ3pCLE9BQU8sQ0FBQ2lJLEtBQUssR0FBR2hJLE9BQU8sQ0FBQ2dJLEtBQUssRUFBRW5ILE9BQU8sQ0FBQztnQ0FDaEQ7NEJBQ0YsT0FBTyxJQUFJc0gsY0FBYztnQ0FDdkIsY0FBYztnQ0FDZE0sWUFBWTtvQ0FDVi9ILE1BQU11RyxjQUFjdkcsSUFBSTtvQ0FDeEJPLFVBQVU7b0NBQ1ZDLE9BQU87b0NBQ1BDLE9BQU87b0NBQ1BDLE1BQU07b0NBQ05FLE1BQU07Z0NBQ1I7Z0NBQ0FkLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBNkI7b0NBQ3ZDYyxPQUFPMEYsY0FBYzVGLEtBQUs7b0NBQzFCWCxNQUFNLElBQUlDLEtBQUtzRyxjQUFjdkcsSUFBSSxHQUFHLE1BQU1FLGNBQWM7b0NBQ3hEYixTQUFTQSxPQUFPLENBQUNpSSxLQUFLLENBQUNuSCxPQUFPLENBQUM7b0NBQy9CYixTQUFTQSxPQUFPLENBQUNnSSxLQUFLLENBQUNuSCxPQUFPLENBQUM7b0NBQy9CVyxNQUFNLENBQUN6QixPQUFPLENBQUNpSSxLQUFLLEdBQUdoSSxPQUFPLENBQUNnSSxLQUFLLEVBQUVuSCxPQUFPLENBQUM7Z0NBQ2hEOzRCQUNGOzRCQUVBLG9DQUFvQzs0QkFDcEMsSUFBSTRILGFBQWFoSixxQkFBcUJ1QyxPQUFPLEVBQUU7Z0NBQzdDLE1BQU0wRyxpQkFBaUJqSixxQkFBcUJ1QyxPQUFPLENBQUMvQixPQUFPLE1BQU0sRUFBRTtnQ0FDbkUsTUFBTTBJLGVBQWVELGVBQWVFLElBQUksQ0FDdEMsQ0FBQ0MsSUFBV0EsRUFBRW5JLElBQUksS0FBSytILFVBQVUvSCxJQUFJLElBQUltSSxFQUFFekgsSUFBSSxLQUFLcUgsVUFBVXJILElBQUk7Z0NBR3BFLElBQUksQ0FBQ3VILGNBQWM7b0NBQ2pCbEoscUJBQXFCdUMsT0FBTyxDQUFDZ0MsVUFBVSxDQUFDOzJDQUFJMEU7d0NBQWdCRDtxQ0FBVTtnQ0FDeEU7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGLEdBQUdwSjtRQUVILGlEQUFpRDtRQUNqRCxNQUFNeUosd0JBQXdCO1lBQzVCLE1BQU1DLGNBQWNDLFNBQVNDLGNBQWMsQ0FBQztZQUM1QyxJQUFJRixhQUFhO2dCQUNmQSxZQUFZRyxNQUFNO1lBQ3BCO1lBRUEsTUFBTUMsYUFBYUgsU0FBU0ksYUFBYSxDQUFDO1lBQzFDLElBQUlELFlBQVk7Z0JBQ2RBLFdBQVdELE1BQU07WUFDbkI7UUFDRjtRQUVBLDBDQUEwQztRQUMxQ0o7UUFDQSxtRUFBbUU7UUFDbkUsTUFBTU8sZ0JBQWdCQyxXQUFXUix1QkFBdUI7UUFFeEQsTUFBTVMsZUFBZTtZQUNuQixJQUFJaEssa0JBQWtCeUMsT0FBTyxJQUFJeEMsU0FBU3dDLE9BQU8sRUFBRTtnQkFDakR4QyxTQUFTd0MsT0FBTyxDQUFDd0gsWUFBWSxDQUFDO29CQUM1QmxFLE9BQU8vRixrQkFBa0J5QyxPQUFPLENBQUNrRSxXQUFXO29CQUM1Q0MsUUFBUTVHLGtCQUFrQnlDLE9BQU8sQ0FBQ29FLFlBQVk7Z0JBQ2hEO1lBQ0Y7UUFDRjtRQUVBcUQsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUg7UUFFbEMsT0FBTztZQUNMRSxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVSjtZQUNyQ0ssYUFBYVA7WUFDYmhDO1lBQ0EsSUFBSTdILFNBQVN3QyxPQUFPLEVBQUU7Z0JBQ3BCeEMsU0FBU3dDLE9BQU8sQ0FBQ2tILE1BQU07WUFDekI7UUFDRjtJQUNGLEdBQUc7UUFBQzdKO1FBQVdDO0tBQVM7SUFFeEIscUJBQU8sOERBQUN1SztRQUFJQyxLQUFLdks7UUFBbUJ3SyxXQUFVOzs7Ozs7QUFDaEQ7R0FyaUJnQjNLO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4PzhkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVDaGFydCwgQ29sb3JUeXBlLCBJQ2hhcnRBcGksIERlZXBQYXJ0aWFsLCBDaGFydE9wdGlvbnMsIExpbmVXaWR0aCwgVGltZSwgQnVzaW5lc3NEYXkgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgZ2V0SGlzdG9yaWNhbERhdGEsIHN1YnNjcmliZVRvUHJpY2UsIFRpbWVmcmFtZSB9IGZyb20gJ0Avc2VydmljZXMvYXBpL2NyeXB0b0NvbXBhcmVBUEknO1xuaW1wb3J0IHsgU3RyYXRlZ3lJZCwgZ2V0U3RyYXRlZ3kgfSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMnO1xuXG4vLyBJbXBvcnQgdGhlIGNhbGN1bGF0ZUVNQSBmdW5jdGlvbiBmcm9tIHRoZSBzdHJhdGVneSBmaWxlXG5mdW5jdGlvbiBjYWxjdWxhdGVFTUEoZGF0YTogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCBlbWE6IG51bWJlcltdID0gW107XG4gIGNvbnN0IG11bHRpcGxpZXIgPSAyIC8gKHBlcmlvZCArIDEpO1xuXG4gIC8vIEZpcnN0IEVNQSB1c2VzIFNNQSBhcyBpbml0aWFsIHZhbHVlXG4gIGxldCBzdW0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBlcmlvZDsgaSsrKSB7XG4gICAgc3VtICs9IGRhdGFbaV07XG4gICAgZW1hLnB1c2goTmFOKTsgLy8gRmlsbCBpbml0aWFsIHZhbHVlcyB3aXRoIE5hTlxuICB9XG4gIGVtYVtwZXJpb2QgLSAxXSA9IHN1bSAvIHBlcmlvZDtcblxuICAvLyBDYWxjdWxhdGUgRU1BIGZvciByZW1haW5pbmcgdmFsdWVzXG4gIGZvciAobGV0IGkgPSBwZXJpb2Q7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gZGF0YVtpXTtcbiAgICBjb25zdCBwcmV2aW91c0VNQSA9IGVtYVtpIC0gMV07XG4gICAgY29uc3QgY3VycmVudEVNQSA9IChjdXJyZW50VmFsdWUgLSBwcmV2aW91c0VNQSkgKiBtdWx0aXBsaWVyICsgcHJldmlvdXNFTUE7XG4gICAgZW1hLnB1c2goY3VycmVudEVNQSk7XG4gIH1cblxuICByZXR1cm4gZW1hO1xufVxuXG4vLyBXQVJOSU5HOiBUaGlzIGNvbXBvbmVudCB1c2VzIHRoZSBDcnlwdG9Db21wYXJlIEFQSSBmb3IgcmVhbC10aW1lIEJpdGNvaW4gcHJpY2UgZGF0YS5cbi8vIERPIE5PVCByZXBsYWNlIHRoaXMgd2l0aCBzYW1wbGUgZGF0YSBvciBtb2RpZnkgdGhlIGRhdGEgZmVlZCBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoZSBwcmljZSBmZWVkIGlzIHdvcmtpbmcgY29ycmVjdGx5IGFuZCBzaG91bGQgcmVtYWluIGNvbm5lY3RlZCB0byBDcnlwdG9Db21wYXJlLlxuXG5leHBvcnQgaW50ZXJmYWNlIENhbmRsZXN0aWNrQ2hhcnRQcm9wcyB7XG4gIHRpbWVmcmFtZTogVGltZWZyYW1lO1xuICBzdHJhdGVneTogU3RyYXRlZ3lJZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhbmRsZXN0aWNrQ2hhcnQoeyB0aW1lZnJhbWUsIHN0cmF0ZWd5IH06IENhbmRsZXN0aWNrQ2hhcnRQcm9wcykge1xuICBjb25zdCBjaGFydENvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGNoYXJ0UmVmID0gdXNlUmVmPElDaGFydEFwaSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjYW5kbGVzdGlja1Nlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuICBjb25zdCBpbmRpY2F0b3JTZXJpZXNSZWZzID0gdXNlUmVmPE1hcDxzdHJpbmcsIGFueT4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IGhpc3RvcmljYWxEYXRhUmVmID0gdXNlUmVmPGFueVtdPihbXSk7XG4gIGNvbnN0IG1hcmtlclNlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGRldGVjdCBzaWduYWxzIGZyb20gRU1BIGRhdGFcbiAgY29uc3QgZGV0ZWN0RU1BU2lnbmFscyA9IChkYXRhOiBhbnlbXSwgZmFzdEVNQTogbnVtYmVyW10sIHNsb3dFTUE6IG51bWJlcltdKTogYW55W10gPT4ge1xuICAgIGNvbnN0IG1hcmtlcnM6IGFueVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZmFzdEVNQS5sZW5ndGgsIHNsb3dFTUEubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCBwcmV2RmFzdCA9IGZhc3RFTUFbaSAtIDFdO1xuICAgICAgY29uc3QgcHJldlNsb3cgPSBzbG93RU1BW2kgLSAxXTtcbiAgICAgIGNvbnN0IGN1cnJGYXN0ID0gZmFzdEVNQVtpXTtcbiAgICAgIGNvbnN0IGN1cnJTbG93ID0gc2xvd0VNQVtpXTtcblxuICAgICAgLy8gRGVidWcgY3Jvc3NvdmVyIGNvbmRpdGlvbnNcbiAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBjcm9zc292ZXI6Jywge1xuICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICBwcmV2RmFzdDogcHJldkZhc3Q/LnRvRml4ZWQoMiksXG4gICAgICAgIHByZXZTbG93OiBwcmV2U2xvdz8udG9GaXhlZCgyKSxcbiAgICAgICAgY3VyckZhc3Q6IGN1cnJGYXN0Py50b0ZpeGVkKDIpLFxuICAgICAgICBjdXJyU2xvdzogY3VyclNsb3c/LnRvRml4ZWQoMiksXG4gICAgICAgIGlzQnV5OiBwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93LFxuICAgICAgICBpc1NlbGw6IHByZXZGYXN0ID49IHByZXZTbG93ICYmIGN1cnJGYXN0IDwgY3VyclNsb3dcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPbmx5IGFkZCBzaWduYWxzIGlmIHdlIGhhdmUgdmFsaWQgRU1BIHZhbHVlc1xuICAgICAgaWYgKCFpc05hTihwcmV2RmFzdCkgJiYgIWlzTmFOKHByZXZTbG93KSAmJiAhaXNOYU4oY3VyckZhc3QpICYmICFpc05hTihjdXJyU2xvdykpIHtcbiAgICAgICAgLy8gQnV5IHNpZ25hbDogRmFzdCBFTUEgY3Jvc3NlcyBhYm92ZSBTbG93IEVNQVxuICAgICAgICBpZiAocHJldkZhc3QgPD0gcHJldlNsb3cgJiYgY3VyckZhc3QgPiBjdXJyU2xvdykge1xuICAgICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXG4gICAgICAgICAgICBzaGFwZTogJ2Fycm93VXAnLFxuICAgICAgICAgICAgdGV4dDogYEJVWVxcbiQke2RhdGFbaV0uY2xvc2UudG9GaXhlZCgyKX1gLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+foiBCdXkgU2lnbmFsIERldGVjdGVkOicsIHtcbiAgICAgICAgICAgIHByaWNlOiBkYXRhW2ldLmNsb3NlLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoZGF0YVtpXS50aW1lICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgIGZhc3RFTUE6IGN1cnJGYXN0LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBzbG93RU1BOiBjdXJyU2xvdy50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgZGlmZjogKGN1cnJGYXN0IC0gY3VyclNsb3cpLnRvRml4ZWQoMilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWxsIHNpZ25hbDogRmFzdCBFTUEgY3Jvc3NlcyBiZWxvdyBTbG93IEVNQVxuICAgICAgICBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgY29sb3I6ICcjZWY1MzUwJyxcbiAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcbiAgICAgICAgICAgIHRleHQ6IGBTRUxMXFxuJCR7ZGF0YVtpXS5jbG9zZS50b0ZpeGVkKDIpfWAsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5S0IFNlbGwgU2lnbmFsIERldGVjdGVkOicsIHtcbiAgICAgICAgICAgIHByaWNlOiBkYXRhW2ldLmNsb3NlLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoZGF0YVtpXS50aW1lICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgIGZhc3RFTUE6IGN1cnJGYXN0LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBzbG93RU1BOiBjdXJyU2xvdy50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgZGlmZjogKGN1cnJGYXN0IC0gY3VyclNsb3cpLnRvRml4ZWQoMilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya2VycztcbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byBzYWZlbHkgcmVtb3ZlIGEgc2VyaWVzXG4gIGNvbnN0IHNhZmVseVJlbW92ZVNlcmllcyA9IChjaGFydDogSUNoYXJ0QXBpLCBzZXJpZXM6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoc2VyaWVzICYmIGNoYXJ0KSB7XG4gICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNlcmllczonLCBlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHN0cmF0ZWd5IGluZGljYXRvcnNcbiAgY29uc3QgdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzID0gKGRhdGE6IGFueVtdLCBjaGFydDogSUNoYXJ0QXBpKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY2hhcnQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGFydCBvciBkYXRhIG5vdCByZWFkeSwgc2tpcHBpbmcgdXBkYXRlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgbWFya2VycyBhbmQgaW5kaWNhdG9yc1xuICAgICAgc2FmZWx5UmVtb3ZlU2VyaWVzKGNoYXJ0LCBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG5cbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICAgIHNhZmVseVJlbW92ZVNlcmllcyhjaGFydCwgc2VyaWVzKTtcbiAgICAgIH0pO1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG5cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBzdHJhdGVneSBzZWxlY3RlZCwgY2xlYXJpbmcgaW5kaWNhdG9ycycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGVkU3RyYXRlZ3kgPSBnZXRTdHJhdGVneShzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGVjdGVkU3RyYXRlZ3k/LmluZGljYXRvcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGluZGljYXRvcnMgZm91bmQgZm9yIHN0cmF0ZWd5OicsIHN0cmF0ZWd5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1cCBzdHJhdGVneTonLCBzZWxlY3RlZFN0cmF0ZWd5LmlkKTtcblxuICAgICAgLy8gQ3JlYXRlIG1hcmtlciBzZXJpZXMgZm9yIHNpZ25hbHNcbiAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudDsgIC8vIFVzZSB0aGUgY2FuZGxlc3RpY2sgc2VyaWVzIGZvciBtYXJrZXJzXG5cbiAgICAgIC8vIFJ1biBzdHJhdGVneSBhbmFseXNpcyBhbmQgdXBkYXRlIGluZGljYXRvcnNcbiAgICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XG4gICAgICBcbiAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcicgfHwgc2VsZWN0ZWRTdHJhdGVneS5pZCA9PT0gJ3NtYV9jcm9zc292ZXInKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDYWxjdWxhdGluZyAke3NlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyA/ICdFTUFzJyA6ICdTTUFzJ30gZm9yIGNyb3Nzb3ZlciBzdHJhdGVneWApO1xuICAgICAgICBjb25zdCBmYXN0UGVyaW9kID0gOTtcbiAgICAgICAgY29uc3Qgc2xvd1BlcmlvZCA9IDIxO1xuICAgICAgICBjb25zdCBmYXN0TGluZSA9IHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJyBcbiAgICAgICAgICA/IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpXG4gICAgICAgICAgOiBjYWxjdWxhdGVTTUEocHJpY2VzLCBmYXN0UGVyaW9kKTtcbiAgICAgICAgY29uc3Qgc2xvd0xpbmUgPSBzZWxlY3RlZFN0cmF0ZWd5LmlkID09PSAnZW1hX2Nyb3Nzb3ZlcidcbiAgICAgICAgICA/IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpXG4gICAgICAgICAgOiBjYWxjdWxhdGVTTUEocHJpY2VzLCBzbG93UGVyaW9kKTtcblxuICAgICAgICAvLyBBZGQgaW5kaWNhdG9yIGxpbmVzXG4gICAgICAgIHNlbGVjdGVkU3RyYXRlZ3kuaW5kaWNhdG9ycy5mb3JFYWNoKChpbmRpY2F0b3IsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBpbmRpY2F0b3I6ICR7aW5kaWNhdG9yLm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgY29sb3JzID0gWycjMjk2MkZGJywgJyNGRjZCNkInXTsgLy8gQmx1ZSBmb3IgZmFzdCwgUmVkIGZvciBzbG93XG4gICAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpbmRleF0sXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICB0aXRsZTogaW5kaWNhdG9yLm5hbWUsXG4gICAgICAgICAgICBwcmljZUZvcm1hdDoge1xuICAgICAgICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICAgICAgICBwcmVjaXNpb246IDIsXG4gICAgICAgICAgICAgIG1pbk1vdmU6IDAuMDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVN0eWxlOiAxLCAvLyBTb2xpZCBsaW5lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LnNldChpbmRpY2F0b3IubmFtZSwgbGluZVNlcmllcyk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgaW5kaWNhdG9yIGRhdGFcbiAgICAgICAgICBjb25zdCBsaW5lRGF0YSA9IChpbmRleCA9PT0gMCA/IGZhc3RMaW5lIDogc2xvd0xpbmUpLm1hcCgodmFsdWUsIGlkeCkgPT4gKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGFbaWR4XS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGxpbmVTZXJpZXMuc2V0RGF0YShsaW5lRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdldCBoaXN0b3JpY2FsIHNpZ25hbHNcbiAgICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwcmV2RmFzdCA9IGZhc3RMaW5lW2kgLSAxXTtcbiAgICAgICAgICBjb25zdCBwcmV2U2xvdyA9IHNsb3dMaW5lW2kgLSAxXTtcbiAgICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xuICAgICAgICAgIGNvbnN0IGN1cnJTbG93ID0gc2xvd0xpbmVbaV07XG5cbiAgICAgICAgICBpZiAoIWlzTmFOKHByZXZGYXN0KSAmJiAhaXNOYU4ocHJldlNsb3cpICYmICFpc05hTihjdXJyRmFzdCkgJiYgIWlzTmFOKGN1cnJTbG93KSkge1xuICAgICAgICAgICAgaWYgKHByZXZGYXN0IDw9IHByZXZTbG93ICYmIGN1cnJGYXN0ID4gY3VyclNsb3cpIHtcbiAgICAgICAgICAgICAgLy8gQnV5IHNpZ25hbFxuICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JlbG93QmFyJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dVcCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ0JVWScsXG4gICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCdXkgU2lnbmFsIGF0OicsIHtcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHByaWNlOiBkYXRhW2ldLmNsb3NlLFxuICAgICAgICAgICAgICAgIGZhc3RMaW5lOiBjdXJyRmFzdC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgIHNsb3dMaW5lOiBjdXJyU2xvdy50b0ZpeGVkKDIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XG4gICAgICAgICAgICAgIC8vIFNlbGwgc2lnbmFsXG4gICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogZGF0YVtpXS50aW1lLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICAgICAgICAgICAgc2hhcGU6ICdhcnJvd0Rvd24nLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdTRUxMJyxcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NlbGwgU2lnbmFsIGF0OicsIHtcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhW2ldLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHByaWNlOiBkYXRhW2ldLmNsb3NlLFxuICAgICAgICAgICAgICAgIGZhc3RMaW5lOiBjdXJyRmFzdC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgIGZhc3RFTUE6IGN1cnJGYXN0LnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgc2xvd0VNQTogY3VyclNsb3cudG9GaXhlZCgyKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgbWFya2VyczonLCBtYXJrZXJzKTtcbiAgICAgICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudC5zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlU3RyYXRlZ3lJbmRpY2F0b3JzOicsIGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVcGRhdGUgdGhlIHN0cmF0ZWd5IGNoYW5nZSBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnU3RyYXRlZ3kgY2hhbmdlZDonLCBzdHJhdGVneSk7XG4gICAgXG4gICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGluZGljYXRvcnMgYW5kIG1hcmtlcnNcbiAgICAgIHNhZmVseVJlbW92ZVNlcmllcyhjaGFydFJlZi5jdXJyZW50LCBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG5cbiAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICAgIHNhZmVseVJlbW92ZVNlcmllcyhjaGFydFJlZi5jdXJyZW50ISwgc2VyaWVzKTtcbiAgICAgIH0pO1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG5cbiAgICAgIC8vIFJlaW5pdGlhbGl6ZSBzdHJhdGVneSBpbmRpY2F0b3JzXG4gICAgICBpZiAoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWluaXRpYWxpemluZyBzdHJhdGVneSBpbmRpY2F0b3JzIHdpdGggZGF0YSBsZW5ndGg6JywgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5sZW5ndGgpO1xuICAgICAgICB1cGRhdGVTdHJhdGVneUluZGljYXRvcnMoaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc3RyYXRlZ3ldKTsgLy8gT25seSBydW4gd2hlbiBzdHJhdGVneSBjaGFuZ2VzXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIGNoYXJ0IHdpdGggdGltZWZyYW1lOicsIHRpbWVmcmFtZSk7XG5cbiAgICBjb25zdCBmb3JtYXRUaW1lID0gKHRpbWU6IFRpbWUpID0+IHtcbiAgICAgIGxldCBkYXRlOiBEYXRlO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUodGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgQnVzaW5lc3NEYXkgZm9ybWF0XG4gICAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGltZSBhcyBCdXNpbmVzc0RheTtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybWF0T3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICAgIG1vbnRoOiAnc2hvcnQnLFxuICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgICAgaG91cjEyOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgLy8gRm9yIGRhaWx5IHRpbWVmcmFtZXMsIGRvbid0IHNob3cgdGltZVxuICAgICAgaWYgKHRpbWVmcmFtZSA9PT0gJzFkJykge1xuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5ob3VyO1xuICAgICAgICBkZWxldGUgZm9ybWF0T3B0aW9ucy5taW51dGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIGZvcm1hdE9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGFydE9wdGlvbnM6IERlZXBQYXJ0aWFsPENoYXJ0T3B0aW9ucz4gPSB7XG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgYmFja2dyb3VuZDogeyBjb2xvcjogJyMxRTIyMkQnIH0sXG4gICAgICAgIHRleHRDb2xvcjogJyNEREQnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdSb2JvdG8sIHNhbnMtc2VyaWYnLFxuICAgICAgfSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgdmVydExpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcbiAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnIzJCMkI0MycgfSxcbiAgICAgIH0sXG4gICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgbW9kZTogMSxcbiAgICAgICAgdmVydExpbmU6IHtcbiAgICAgICAgICB3aWR0aDogMSBhcyBMaW5lV2lkdGgsXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcbiAgICAgICAgICBzdHlsZTogMyxcbiAgICAgICAgfSxcbiAgICAgICAgaG9yekxpbmU6IHtcbiAgICAgICAgICB3aWR0aDogMSBhcyBMaW5lV2lkdGgsXG4gICAgICAgICAgY29sb3I6ICcjNzU4Njk2JyxcbiAgICAgICAgICBzdHlsZTogMyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0aW1lU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgICAgdGltZVZpc2libGU6IHRydWUsXG4gICAgICAgIHNlY29uZHNWaXNpYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICByaWdodFByaWNlU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgIH0sXG4gICAgICBsb2NhbGl6YXRpb246IHtcbiAgICAgICAgdGltZUZvcm1hdHRlcjogZm9ybWF0VGltZSxcbiAgICAgIH0sXG4gICAgICB3YXRlcm1hcms6IHtcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBjaGFydCA9IGNyZWF0ZUNoYXJ0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQsIHtcbiAgICAgIC4uLmNoYXJ0T3B0aW9ucyxcbiAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xuICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgIHdpY2tVcENvbG9yOiAnIzI2YTY5YScsXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgfSk7XG5cbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XG5cbiAgICAvLyBGZXRjaCBoaXN0b3JpY2FsIGRhdGFcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcmljYWxEYXRhID0gYXdhaXQgZ2V0SGlzdG9yaWNhbERhdGEodGltZWZyYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBoaXN0b3JpY2FsIGRhdGE6JywgaGlzdG9yaWNhbERhdGEubGVuZ3RoKTtcbiAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IGhpc3RvcmljYWxEYXRhO1xuICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5zZXREYXRhKGhpc3RvcmljYWxEYXRhLm1hcChkID0+ICh7XG4gICAgICAgICAgdGltZTogZC50aW1lLFxuICAgICAgICAgIG9wZW46IGQub3BlbixcbiAgICAgICAgICBoaWdoOiBkLmhpZ2gsXG4gICAgICAgICAgbG93OiBkLmxvdyxcbiAgICAgICAgICBjbG9zZTogZC5jbG9zZVxuICAgICAgICB9KSkpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdHJhdGVneSBpbmRpY2F0b3JzIHdpdGggaW5pdGlhbCBkYXRhXG4gICAgICAgIHVwZGF0ZVN0cmF0ZWd5SW5kaWNhdG9ycyhoaXN0b3JpY2FsRGF0YSwgY2hhcnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBoaXN0b3JpY2FsIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkRGF0YSgpO1xuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcblxuICAgIC8vIFN1YnNjcmliZSB0byByZWFsLXRpbWUgcHJpY2UgdXBkYXRlcyB3aXRoIGltcHJvdmVkIGNhbmRsZSBmb3JtYXRpb25cbiAgICBsZXQgY3VycmVudENhbmRsZSA9IHtcbiAgICAgIG9wZW46IDAsXG4gICAgICBoaWdoOiAtSW5maW5pdHksXG4gICAgICBsb3c6IEluZmluaXR5LFxuICAgICAgY2xvc2U6IDAsXG4gICAgICB0aW1lOiAwLFxuICAgIH07XG5cbiAgICBjb25zdCBnZXRJbnRlcnZhbFNlY29uZHMgPSAodGY6IFRpbWVmcmFtZSk6IG51bWJlciA9PiB7XG4gICAgICBzd2l0Y2ggKHRmKSB7XG4gICAgICAgIGNhc2UgJzFtJzogcmV0dXJuIDYwO1xuICAgICAgICBjYXNlICc1bSc6IHJldHVybiAzMDA7XG4gICAgICAgIGNhc2UgJzE1bSc6IHJldHVybiA5MDA7XG4gICAgICAgIGNhc2UgJzMwbSc6IHJldHVybiAxODAwO1xuICAgICAgICBjYXNlICcxaCc6IHJldHVybiAzNjAwO1xuICAgICAgICBjYXNlICc0aCc6IHJldHVybiAxNDQwMDtcbiAgICAgICAgY2FzZSAnMWQnOiByZXR1cm4gODY0MDA7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiA2MDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1ByaWNlKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBpbnRlcnZhbFNlY29uZHMgPSBnZXRJbnRlcnZhbFNlY29uZHModGltZWZyYW1lKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICBjb25zdCBjYW5kbGVUaW1lc3RhbXAgPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lc3RhbXAgLyBpbnRlcnZhbFNlY29uZHMpICogaW50ZXJ2YWxTZWNvbmRzO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBjYW5kbGVcbiAgICAgICAgaWYgKGNhbmRsZVRpbWVzdGFtcCAhPT0gY3VycmVudENhbmRsZS50aW1lKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY2FuZGxlLCBmaW5hbGl6ZSBpdFxuICAgICAgICAgIGlmIChjdXJyZW50Q2FuZGxlLnRpbWUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhbmRsZSA9IHtcbiAgICAgICAgICAgICAgdGltZTogY3VycmVudENhbmRsZS50aW1lLFxuICAgICAgICAgICAgICBvcGVuOiBjdXJyZW50Q2FuZGxlLm9wZW4sXG4gICAgICAgICAgICAgIGhpZ2g6IGN1cnJlbnRDYW5kbGUuaGlnaCxcbiAgICAgICAgICAgICAgbG93OiBjdXJyZW50Q2FuZGxlLmxvdyxcbiAgICAgICAgICAgICAgY2xvc2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUobmV3Q2FuZGxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGhpc3RvcmljYWwgZGF0YSB3aXRoIHRoZSBuZXcgY2FuZGxlXG4gICAgICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50ID0gWy4uLmhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQuc2xpY2UoMSksIG5ld0NhbmRsZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGNhbmRsZVxuICAgICAgICAgIGN1cnJlbnRDYW5kbGUgPSB7XG4gICAgICAgICAgICB0aW1lOiBjYW5kbGVUaW1lc3RhbXAsXG4gICAgICAgICAgICBvcGVuOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGxvdzogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGNsb3NlOiBkYXRhLnZhbHVlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBVcGRhdGUgY2FuZGxlc3RpY2sgc2VyaWVzIHdpdGggdGhlIG5ldyBjYW5kbGVcbiAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZShjdXJyZW50Q2FuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2FuZGxlXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPiBjdXJyZW50Q2FuZGxlLmhpZ2gpIGN1cnJlbnRDYW5kbGUuaGlnaCA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPCBjdXJyZW50Q2FuZGxlLmxvdykgY3VycmVudENhbmRsZS5sb3cgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIGN1cnJlbnRDYW5kbGUuY2xvc2UgPSBkYXRhLnZhbHVlO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC51cGRhdGUoY3VycmVudENhbmRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgc3RyYXRlZ3kgaW5kaWNhdG9ycyBpZiB3ZSBoYXZlIGEgc3RyYXRlZ3kgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCAmJiBpbmRpY2F0b3JTZXJpZXNSZWZzLmN1cnJlbnQuc2l6ZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFN0cmF0ZWd5ID0gZ2V0U3RyYXRlZ3koc3RyYXRlZ3kpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZFN0cmF0ZWd5ICYmIHNlbGVjdGVkU3RyYXRlZ3kuaWQgPT09ICdlbWFfY3Jvc3NvdmVyJykge1xuICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgY3VycmVudCBjYW5kbGUgaW4gdGhlIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBbLi4uaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudC5zbGljZSgxKSwgY3VycmVudENhbmRsZV07XG4gICAgICAgICAgICBjb25zdCBwcmljZXMgPSB1cGRhdGVkRGF0YS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IGZhc3RQZXJpb2QgPSA5O1xuICAgICAgICAgICAgY29uc3Qgc2xvd1BlcmlvZCA9IDIxO1xuICAgICAgICAgICAgY29uc3QgZmFzdEVNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIGZhc3RQZXJpb2QpO1xuICAgICAgICAgICAgY29uc3Qgc2xvd0VNQSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIHNsb3dQZXJpb2QpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgc2VyaWVzIHdpdGggbmV3IGRhdGFcbiAgICAgICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKChzZXJpZXMsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZW1hRGF0YSA9IChuYW1lID09PSAnRmFzdCBFTUEgKDkpJyA/IGZhc3RFTUEgOiBzbG93RU1BKS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0aW1lOiB1cGRhdGVkRGF0YVtpbmRleF0udGltZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBzZXJpZXMuc2V0RGF0YShlbWFEYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbmV3IHNpZ25hbFxuICAgICAgICAgICAgY29uc3QgbGFzdCA9IGZhc3RFTUEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBsYXN0IC0gMTtcbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgIWlzTmFOKGZhc3RFTUFbcHJldl0pICYmICFpc05hTihzbG93RU1BW3ByZXZdKSAmJiBcbiAgICAgICAgICAgICAgICAhaXNOYU4oZmFzdEVNQVtsYXN0XSkgJiYgIWlzTmFOKHNsb3dFTUFbbGFzdF0pKSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBEZWJ1ZyByZWFsLXRpbWUgY3Jvc3NvdmVyIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgY29uc3QgY3Jvc3NpbmdVcCA9IGZhc3RFTUFbcHJldl0gPD0gc2xvd0VNQVtwcmV2XSAmJiBmYXN0RU1BW2xhc3RdID4gc2xvd0VNQVtsYXN0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Jvc3NpbmdEb3duID0gZmFzdEVNQVtwcmV2XSA+PSBzbG93RU1BW3ByZXZdICYmIGZhc3RFTUFbbGFzdF0gPCBzbG93RU1BW2xhc3RdO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKGNyb3NzaW5nVXAgfHwgY3Jvc3NpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWwtdGltZSBFTUEgU3RhdHVzOicsIHtcbiAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKGN1cnJlbnRDYW5kbGUudGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBwcmljZTogY3VycmVudENhbmRsZS5jbG9zZSxcbiAgICAgICAgICAgICAgICAgIHByZXZGYXN0RU1BOiBmYXN0RU1BW3ByZXZdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBwcmV2U2xvd0VNQTogc2xvd0VNQVtwcmV2XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgY3VyckZhc3RFTUE6IGZhc3RFTUFbbGFzdF0udG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgIGN1cnJTbG93RU1BOiBzbG93RU1BW2xhc3RdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBzaWduYWw6IGNyb3NzaW5nVXAgPyAnQlVZJyA6ICdTRUxMJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IG5ld01hcmtlciA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChjcm9zc2luZ1VwKSB7XG4gICAgICAgICAgICAgICAgLy8gQnV5IHNpZ25hbFxuICAgICAgICAgICAgICAgIG5ld01hcmtlciA9IHtcbiAgICAgICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYmVsb3dCYXInLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dVcCcsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiAnQlVZJyxcbiAgICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+foiBSZWFsLXRpbWUgQnV5IFNpZ25hbDonLCB7XG4gICAgICAgICAgICAgICAgICBwcmljZTogY3VycmVudENhbmRsZS5jbG9zZSxcbiAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKGN1cnJlbnRDYW5kbGUudGltZSAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBmYXN0RU1BOiBmYXN0RU1BW2xhc3RdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBzbG93RU1BOiBzbG93RU1BW2xhc3RdLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICBkaWZmOiAoZmFzdEVNQVtsYXN0XSAtIHNsb3dFTUFbbGFzdF0pLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc2luZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxsIHNpZ25hbFxuICAgICAgICAgICAgICAgIG5ld01hcmtlciA9IHtcbiAgICAgICAgICAgICAgICAgIHRpbWU6IGN1cnJlbnRDYW5kbGUudGltZSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjZWY1MzUwJyxcbiAgICAgICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dEb3duJyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdTRUxMJyxcbiAgICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UtCBSZWFsLXRpbWUgU2VsbCBTaWduYWw6Jywge1xuICAgICAgICAgICAgICAgICAgcHJpY2U6IGN1cnJlbnRDYW5kbGUuY2xvc2UsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShjdXJyZW50Q2FuZGxlLnRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgZmFzdEVNQTogZmFzdEVNQVtsYXN0XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgc2xvd0VNQTogc2xvd0VNQVtsYXN0XS50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgZGlmZjogKGZhc3RFTUFbbGFzdF0gLSBzbG93RU1BW2xhc3RdKS50b0ZpeGVkKDIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgbmV3IG1hcmtlciBpZiBzaWduYWwgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAgaWYgKG5ld01hcmtlciAmJiBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1hcmtlcnMgPSBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50Lm1hcmtlcnMoKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxFeGlzdHMgPSBjdXJyZW50TWFya2Vycy5zb21lKFxuICAgICAgICAgICAgICAgICAgKG06IGFueSkgPT4gbS50aW1lID09PSBuZXdNYXJrZXIudGltZSAmJiBtLnRleHQgPT09IG5ld01hcmtlci50ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIXNpZ25hbEV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC5zZXRNYXJrZXJzKFsuLi5jdXJyZW50TWFya2VycywgbmV3TWFya2VyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGltZWZyYW1lKTtcblxuICAgIC8vIFJlbW92ZSBUcmFkaW5nVmlldyBsb2dvIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3RcbiAgICBjb25zdCByZW1vdmVUcmFkaW5nVmlld0xvZ28gPSAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dvRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0di1hdHRyLWxvZ28nKTtcbiAgICAgIGlmIChsb2dvRWxlbWVudCkge1xuICAgICAgICBsb2dvRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVhZGVyTG9nbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50di1oZWFkZXJfX2xpbmsnKTtcbiAgICAgIGlmIChoZWFkZXJMb2dvKSB7XG4gICAgICAgIGhlYWRlckxvZ28ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJ1biBsb2dvIHJlbW92YWwgYWZ0ZXIgY2hhcnQgaXMgY3JlYXRlZFxuICAgIHJlbW92ZVRyYWRpbmdWaWV3TG9nbygpO1xuICAgIC8vIEFsc28gcnVuIGFmdGVyIGEgc2hvcnQgZGVsYXkgdG8gY2F0Y2ggZHluYW1pY2FsbHkgYWRkZWQgZWxlbWVudHNcbiAgICBjb25zdCBsb2dvVGltZW91dElkID0gc2V0VGltZW91dChyZW1vdmVUcmFkaW5nVmlld0xvZ28sIDEwMCk7XG5cbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQuYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICB3aWR0aDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQobG9nb1RpbWVvdXRJZCk7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbdGltZWZyYW1lLCBzdHJhdGVneV0pO1xuXG4gIHJldHVybiA8ZGl2IHJlZj17Y2hhcnRDb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIiAvPjtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUNoYXJ0IiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJzdWJzY3JpYmVUb1ByaWNlIiwiZ2V0U3RyYXRlZ3kiLCJjYWxjdWxhdGVFTUEiLCJkYXRhIiwicGVyaW9kIiwiZW1hIiwibXVsdGlwbGllciIsInN1bSIsImkiLCJwdXNoIiwiTmFOIiwibGVuZ3RoIiwiY3VycmVudFZhbHVlIiwicHJldmlvdXNFTUEiLCJjdXJyZW50RU1BIiwiQ2FuZGxlc3RpY2tDaGFydCIsInRpbWVmcmFtZSIsInN0cmF0ZWd5IiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZXN0aWNrU2VyaWVzUmVmIiwiaW5kaWNhdG9yU2VyaWVzUmVmcyIsIk1hcCIsImhpc3RvcmljYWxEYXRhUmVmIiwibWFya2VyU2VyaWVzUmVmIiwiZGV0ZWN0RU1BU2lnbmFscyIsImZhc3RFTUEiLCJzbG93RU1BIiwibWFya2VycyIsIk1hdGgiLCJtaW4iLCJwcmV2RmFzdCIsInByZXZTbG93IiwiY3VyckZhc3QiLCJjdXJyU2xvdyIsImNvbnNvbGUiLCJsb2ciLCJ0aW1lIiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwidG9GaXhlZCIsImlzQnV5IiwiaXNTZWxsIiwiaXNOYU4iLCJwb3NpdGlvbiIsImNvbG9yIiwic2hhcGUiLCJ0ZXh0IiwiY2xvc2UiLCJzaXplIiwicHJpY2UiLCJkaWZmIiwic2FmZWx5UmVtb3ZlU2VyaWVzIiwiY2hhcnQiLCJzZXJpZXMiLCJyZW1vdmVTZXJpZXMiLCJlIiwiZXJyb3IiLCJ1cGRhdGVTdHJhdGVneUluZGljYXRvcnMiLCJjdXJyZW50IiwiZm9yRWFjaCIsImNsZWFyIiwic2VsZWN0ZWRTdHJhdGVneSIsImluZGljYXRvcnMiLCJpZCIsInByaWNlcyIsIm1hcCIsImQiLCJmYXN0UGVyaW9kIiwic2xvd1BlcmlvZCIsImZhc3RMaW5lIiwiY2FsY3VsYXRlU01BIiwic2xvd0xpbmUiLCJpbmRpY2F0b3IiLCJpbmRleCIsIm5hbWUiLCJjb2xvcnMiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImxpbmVXaWR0aCIsInRpdGxlIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsImxpbmVTdHlsZSIsInNldCIsImxpbmVEYXRhIiwidmFsdWUiLCJpZHgiLCJzZXREYXRhIiwic2V0TWFya2VycyIsImZvcm1hdFRpbWUiLCJkYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZm9ybWF0T3B0aW9ucyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJjaGFydE9wdGlvbnMiLCJsYXlvdXQiLCJiYWNrZ3JvdW5kIiwidGV4dENvbG9yIiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiZ3JpZCIsInZlcnRMaW5lcyIsImhvcnpMaW5lcyIsImNyb3NzaGFpciIsIm1vZGUiLCJ2ZXJ0TGluZSIsIndpZHRoIiwic3R5bGUiLCJob3J6TGluZSIsInRpbWVTY2FsZSIsImJvcmRlckNvbG9yIiwidGltZVZpc2libGUiLCJzZWNvbmRzVmlzaWJsZSIsInJpZ2h0UHJpY2VTY2FsZSIsImxvY2FsaXphdGlvbiIsInRpbWVGb3JtYXR0ZXIiLCJ3YXRlcm1hcmsiLCJ2aXNpYmxlIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjYW5kbGVzdGlja1NlcmllcyIsImFkZENhbmRsZXN0aWNrU2VyaWVzIiwidXBDb2xvciIsImRvd25Db2xvciIsImJvcmRlclZpc2libGUiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJsb2FkRGF0YSIsImhpc3RvcmljYWxEYXRhIiwib3BlbiIsImhpZ2giLCJsb3ciLCJjdXJyZW50Q2FuZGxlIiwiSW5maW5pdHkiLCJnZXRJbnRlcnZhbFNlY29uZHMiLCJ0ZiIsInVuc3Vic2NyaWJlIiwiaW50ZXJ2YWxTZWNvbmRzIiwiY3VycmVudFRpbWVzdGFtcCIsImZsb29yIiwibm93IiwiY2FuZGxlVGltZXN0YW1wIiwibmV3Q2FuZGxlIiwidXBkYXRlIiwic2xpY2UiLCJ1cGRhdGVkRGF0YSIsImVtYURhdGEiLCJsYXN0IiwicHJldiIsImNyb3NzaW5nVXAiLCJjcm9zc2luZ0Rvd24iLCJwcmV2RmFzdEVNQSIsInByZXZTbG93RU1BIiwiY3VyckZhc3RFTUEiLCJjdXJyU2xvd0VNQSIsInNpZ25hbCIsIm5ld01hcmtlciIsImN1cnJlbnRNYXJrZXJzIiwic2lnbmFsRXhpc3RzIiwic29tZSIsIm0iLCJyZW1vdmVUcmFkaW5nVmlld0xvZ28iLCJsb2dvRWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyZW1vdmUiLCJoZWFkZXJMb2dvIiwicXVlcnlTZWxlY3RvciIsImxvZ29UaW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiaGFuZGxlUmVzaXplIiwiYXBwbHlPcHRpb25zIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhclRpbWVvdXQiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});
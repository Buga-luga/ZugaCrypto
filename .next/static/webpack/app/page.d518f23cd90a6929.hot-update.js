"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx":
/*!***************************************************!*\
  !*** ./src/components/Chart/CandlestickChart.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: function() { return /* binding */ CandlestickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/api/cryptoCompareAPI */ \"(app-pages-browser)/./src/services/api/cryptoCompareAPI.ts\");\n/* harmony import */ var _services_strategies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/strategies */ \"(app-pages-browser)/./src/services/strategies/index.ts\");\n/* harmony import */ var _services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/strategies/moving-averages */ \"(app-pages-browser)/./src/services/strategies/moving-averages.ts\");\n/* harmony import */ var _TickerHeader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TickerHeader */ \"(app-pages-browser)/./src/components/Chart/TickerHeader.tsx\");\n/* harmony import */ var _utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/priceFormat */ \"(app-pages-browser)/./src/utils/priceFormat.ts\");\n/* __next_internal_client_entry_do_not_use__ CandlestickChart auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Function to get interval in seconds\nconst getIntervalSeconds = (tf)=>{\n    switch(tf){\n        case \"1m\":\n            return 60;\n        case \"5m\":\n            return 300;\n        case \"15m\":\n            return 900;\n        case \"30m\":\n            return 1800;\n        case \"1h\":\n            return 3600;\n        case \"4h\":\n            return 14400;\n        case \"1d\":\n            return 86400;\n        default:\n            return 60;\n    }\n};\nfunction CandlestickChart(param) {\n    let { timeframe, strategy, token = \"BTC\", baseToken = \"USDT\", exchange = \"CryptoCompare\", onPairChange = ()=>{}, signals = [] } = param;\n    _s();\n    const [selectedExchange, setSelectedExchange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(exchange);\n    const [currentBaseToken, setCurrentBaseToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(baseToken);\n    const [currentPrice, setCurrentPrice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken));\n    const [priceStats, setPriceStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>({\n            change1h: \"0.00\",\n            change24h: \"0.00\",\n            change7d: \"0.00\",\n            high24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken),\n            low24h: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(0, baseToken)\n        }));\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorSeriesRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const historicalDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const currentCandleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastSignalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Add reference for stats data\n    const statsDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Function to fetch data for stats calculations\n    const fetchStatsData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        try {\n            // Fetch 1-minute data for accurate stats calculations\n            const data = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(\"1m\", token, currentBaseToken);\n            statsDataRef.current = data;\n            updatePriceStats(data);\n        } catch (error) {\n            console.error(\"Error fetching stats data:\", error);\n        }\n    }, [\n        token,\n        currentBaseToken,\n        updatePriceStats\n    ]);\n    // Effect to fetch stats data when pair changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchStatsData();\n    }, [\n        token,\n        currentBaseToken,\n        fetchStatsData\n    ]);\n    // Handle trading pair change\n    const handlePairChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((newToken, newBaseToken)=>{\n        onPairChange(newToken, newBaseToken);\n        setCurrentBaseToken(newBaseToken);\n    }, [\n        onPairChange\n    ]);\n    // Function to update price stats\n    const updatePriceStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((data)=>{\n        if (data.length < 2) return;\n        const currentPrice = data[data.length - 1].close;\n        const currentTime = data[data.length - 1].time;\n        // Calculate time thresholds in seconds\n        const oneHourAgo = currentTime - 60 * 60;\n        const twentyFourHoursAgo = currentTime - 24 * 60 * 60;\n        const sevenDaysAgo = currentTime - 7 * 24 * 60 * 60;\n        // Filter data for each time period\n        const last1h = data.filter((d)=>d.time >= oneHourAgo);\n        const last24h = data.filter((d)=>d.time >= twentyFourHoursAgo);\n        const last7d = data.filter((d)=>d.time >= sevenDaysAgo);\n        // Calculate high and low for 24h\n        const high24h = Math.max(...last24h.map((d)=>d.high));\n        const low24h = Math.min(...last24h.map((d)=>d.low));\n        // Calculate percentage changes\n        const getPercentChange = (periodData)=>{\n            if (periodData.length < 1) return 0;\n            const oldPrice = periodData[0].close;\n            return (currentPrice - oldPrice) / oldPrice * 100;\n        };\n        const change1h = getPercentChange(last1h);\n        const change24h = getPercentChange(last24h);\n        const change7d = getPercentChange(last7d);\n        // Format prices using the price format utility\n        const formattedHigh = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(high24h, currentBaseToken);\n        const formattedLow = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(low24h, currentBaseToken);\n        setPriceStats({\n            change1h: change1h.toFixed(2),\n            change24h: change24h.toFixed(2),\n            change7d: change7d.toFixed(2),\n            high24h: formattedHigh,\n            low24h: formattedLow\n        });\n    }, [\n        currentBaseToken\n    ]);\n    // Function to add strategy indicators\n    const addStrategyIndicators = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chart, data)=>{\n        if (!chart) {\n            console.error(\"Chart is not initialized\");\n            return;\n        }\n        try {\n            // Clear any existing indicators\n            indicatorSeriesRefs.current.forEach((series)=>{\n                try {\n                    if (series && chart) {\n                        chart.removeSeries(series);\n                    }\n                } catch (e) {\n                    console.error(\"Error removing series:\", e);\n                }\n            });\n            indicatorSeriesRefs.current.clear();\n            if (markerSeriesRef.current) {\n                try {\n                    chart.removeSeries(markerSeriesRef.current);\n                } catch (e) {\n                    console.error(\"Error removing marker series:\", e);\n                }\n                markerSeriesRef.current = null;\n            }\n            if (strategy === \"none\") return;\n            // Calculate indicators based on strategy\n            const prices = data.map((d)=>d.close);\n            let fastLine = [];\n            let slowLine = [];\n            switch(strategy){\n                case \"ema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 21);\n                    break;\n                case \"sma_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 21);\n                    break;\n                case \"tema_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 7);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, 21);\n                    break;\n                case \"golden_cross\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 50);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, 200);\n                    break;\n                case \"hull_crossover\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 9);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, 21);\n                    break;\n                case \"ema_5_13\":\n                    fastLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 5);\n                    slowLine = (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, 13);\n                    break;\n            }\n            // Add indicator lines\n            const selectedStrategy = (0,_services_strategies__WEBPACK_IMPORTED_MODULE_4__.getStrategy)(strategy);\n            if (!selectedStrategy) return;\n            const colors = [\n                \"#2962FF\",\n                \"#FF6B6B\"\n            ];\n            selectedStrategy.indicators.forEach((indicator, index)=>{\n                const lineSeries = chart.addLineSeries({\n                    color: colors[index],\n                    lineWidth: 2,\n                    title: indicator.name,\n                    priceFormat: {\n                        type: \"price\",\n                        precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                        minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n                    }\n                });\n                indicatorSeriesRefs.current.set(indicator.name, lineSeries);\n                const lineData = (index === 0 ? fastLine : slowLine).map((value, idx)=>({\n                        time: data[idx].time,\n                        value: isNaN(value) ? null : value\n                    })).filter((d)=>d.value !== null);\n                lineSeries.setData(lineData);\n            });\n            // Add crossover signals with markers, text, and triangle shape\n            const markers = [];\n            for(let i = 1; i < data.length; i++){\n                const prevFast = fastLine[i - 1];\n                const prevSlow = slowLine[i - 1];\n                const currFast = fastLine[i];\n                const currSlow = slowLine[i];\n                if (!isNaN(prevFast) && !isNaN(prevSlow) && !isNaN(currFast) && !isNaN(currSlow)) {\n                    if (prevFast <= prevSlow && currFast > currSlow) {\n                        markers.push({\n                            time: data[i].time,\n                            position: \"belowBar\",\n                            color: \"#26a69a\",\n                            shape: \"arrowUp\",\n                            text: \"Buy\"\n                        });\n                    } else if (prevFast >= prevSlow && currFast < currSlow) {\n                        markers.push({\n                            time: data[i].time,\n                            position: \"aboveBar\",\n                            color: \"#ef5350\",\n                            shape: \"arrowDown\",\n                            text: \"Sell\"\n                        });\n                    }\n                }\n            }\n            markerSeriesRef.current = markers;\n        } catch (error) {\n            console.error(\"Error adding strategy indicators:\", error);\n        }\n    }, [\n        strategy,\n        currentBaseToken\n    ]);\n    // Effect for strategy changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartRef.current || historicalDataRef.current.length === 0) {\n            return;\n        }\n        try {\n            addStrategyIndicators(chartRef.current, historicalDataRef.current);\n        } catch (error) {\n            console.error(\"Error in strategy change effect:\", error);\n        }\n    }, [\n        strategy,\n        addStrategyIndicators\n    ]);\n    // Main chart initialization effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!chartContainerRef.current) return;\n        const chartOptions = {\n            layout: {\n                background: {\n                    color: \"#1E222D\"\n                },\n                textColor: \"#DDD\"\n            },\n            grid: {\n                vertLines: {\n                    color: \"#2B2B43\"\n                },\n                horzLines: {\n                    color: \"#2B2B43\"\n                }\n            },\n            timeScale: {\n                borderColor: \"#2B2B43\",\n                timeVisible: true\n            },\n            rightPriceScale: {\n                borderColor: \"#2B2B43\",\n                visible: true,\n                scaleMargins: {\n                    top: 0.1,\n                    bottom: 0.4\n                },\n                autoScale: true,\n                mode: 0,\n                alignLabels: true,\n                borderVisible: true,\n                entireTextOnly: true,\n                ticksVisible: true\n            },\n            width: chartContainerRef.current.clientWidth,\n            height: chartContainerRef.current.clientHeight,\n            localization: {\n                priceFormatter: (price)=>(0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(price, currentBaseToken)\n            }\n        };\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, chartOptions);\n        // Create candlestick series with price format\n        const candlestickSeries = chart.addCandlestickSeries({\n            upColor: \"#26a69a\",\n            downColor: \"#ef5350\",\n            borderVisible: false,\n            wickUpColor: \"#26a69a\",\n            wickDownColor: \"#ef5350\",\n            priceFormat: {\n                type: \"price\",\n                precision: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 8 : 2,\n                minMove: (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.isBTCPair)(currentBaseToken) ? 0.00000001 : 0.01\n            }\n        });\n        candlestickSeriesRef.current = candlestickSeries;\n        chartRef.current = chart;\n        // Load initial data\n        const loadData = async ()=>{\n            try {\n                const data = await (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.getHistoricalData)(timeframe, token, currentBaseToken);\n                historicalDataRef.current = data;\n                candlestickSeries.setData(data);\n                updatePriceStats(data);\n                // Set the current candle reference to the last candle\n                if (data.length > 0) {\n                    currentCandleRef.current = data[data.length - 1];\n                }\n                if (strategy !== \"none\") {\n                    addStrategyIndicators(chart, data);\n                }\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            }\n        };\n        loadData();\n        // Real-time updates\n        const unsubscribe = (0,_services_api_cryptoCompareAPI__WEBPACK_IMPORTED_MODULE_3__.subscribeToPrice)((data)=>{\n            if (!candlestickSeriesRef.current) {\n                console.warn(\"Candlestick series not initialized\");\n                return;\n            }\n            // Update current price display immediately\n            const formattedPrice = (0,_utils_priceFormat__WEBPACK_IMPORTED_MODULE_7__.formatPrice)(data.value, currentBaseToken);\n            setCurrentPrice(formattedPrice);\n            const intervalSeconds = getIntervalSeconds(timeframe);\n            const candleTimestamp = Math.floor(data.time / intervalSeconds) * intervalSeconds;\n            // Update chart candles\n            if (!currentCandleRef.current || candleTimestamp !== currentCandleRef.current.time) {\n                if (currentCandleRef.current) {\n                    historicalDataRef.current.push(currentCandleRef.current);\n                }\n                const newCandle = {\n                    time: candleTimestamp,\n                    open: data.value,\n                    high: data.value,\n                    low: data.value,\n                    close: data.value\n                };\n                currentCandleRef.current = newCandle;\n                candlestickSeriesRef.current.update(newCandle);\n                if (strategy !== \"none\" && chartRef.current) {\n                    addStrategyIndicators(chartRef.current, historicalDataRef.current);\n                }\n            } else {\n                const updatedCandle = {\n                    ...currentCandleRef.current,\n                    high: Math.max(currentCandleRef.current.high, data.value),\n                    low: Math.min(currentCandleRef.current.low, data.value),\n                    close: data.value\n                };\n                currentCandleRef.current = updatedCandle;\n                candlestickSeriesRef.current.update(updatedCandle);\n            }\n            // Update stats data with the latest price\n            if (statsDataRef.current.length > 0) {\n                const updatedStatsData = [\n                    ...statsDataRef.current\n                ];\n                const lastCandle = updatedStatsData[updatedStatsData.length - 1];\n                if (data.time > lastCandle.time) {\n                    // Add new candle to stats data\n                    updatedStatsData.push({\n                        time: data.time,\n                        open: data.value,\n                        high: data.value,\n                        low: data.value,\n                        close: data.value\n                    });\n                    // Remove old data to keep the array size manageable\n                    if (updatedStatsData.length > 10080) {\n                        updatedStatsData.shift();\n                    }\n                } else {\n                    // Update last candle\n                    lastCandle.close = data.value;\n                    lastCandle.high = Math.max(lastCandle.high, data.value);\n                    lastCandle.low = Math.min(lastCandle.low, data.value);\n                }\n                statsDataRef.current = updatedStatsData;\n                updatePriceStats(updatedStatsData);\n            }\n        }, timeframe, token, currentBaseToken);\n        // Handle window resize\n        const handleResize = ()=>{\n            if (chartContainerRef.current && chartRef.current) {\n                chartRef.current.applyOptions({\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight\n                });\n            }\n        };\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            unsubscribe();\n            if (chartRef.current) {\n                indicatorSeriesRefs.current.forEach((series)=>{\n                    try {\n                        var _chartRef_current;\n                        (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.removeSeries(series);\n                    } catch (e) {\n                        console.error(\"Error removing indicator series during cleanup:\", e);\n                    }\n                });\n                indicatorSeriesRefs.current.clear();\n                if (markerSeriesRef.current) {\n                    try {\n                        chartRef.current.removeSeries(markerSeriesRef.current);\n                    } catch (e) {\n                        console.error(\"Error removing marker series during cleanup:\", e);\n                    }\n                    markerSeriesRef.current = null;\n                }\n                chart.remove();\n            }\n        };\n    }, [\n        timeframe,\n        currentBaseToken,\n        strategy,\n        token,\n        updatePriceStats,\n        addStrategyIndicators\n    ]);\n    // Ensure markers are set on the candlestick series\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (candlestickSeriesRef.current && markerSeriesRef.current) {\n            candlestickSeriesRef.current.setMarkers(markerSeriesRef.current);\n        }\n    }, [\n        markerSeriesRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (historicalDataRef.current.length > 0) {\n            updatePriceStats(historicalDataRef.current);\n        }\n    }, [\n        historicalDataRef.current\n    ]);\n    // Helper function to calculate indicators\n    const calculateIndicator = (prices, type, period)=>{\n        switch(type){\n            case \"ema\":\n                return (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateEMA)(prices, period);\n            case \"sma\":\n                return (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateSMA)(prices, period);\n            case \"tema\":\n                return (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateTEMA)(prices, period);\n            case \"hma\":\n                return (0,_services_strategies_moving_averages__WEBPACK_IMPORTED_MODULE_5__.calculateHMA)(prices, period);\n            default:\n                return [];\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col w-full h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TickerHeader__WEBPACK_IMPORTED_MODULE_6__.TickerHeader, {\n                token: token,\n                baseToken: currentBaseToken,\n                exchange: selectedExchange,\n                currentPrice: currentPrice,\n                priceStats: priceStats,\n                onExchangeChange: setSelectedExchange,\n                onPairChange: handlePairChange\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 523,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"flex-1\"\n            }, void 0, false, {\n                fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n                lineNumber: 532,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Programming\\\\ZugaCrypto\\\\src\\\\components\\\\Chart\\\\CandlestickChart.tsx\",\n        lineNumber: 522,\n        columnNumber: 5\n    }, this);\n}\n_s(CandlestickChart, \"ZkKUMfUYwcPYvSZM2XkCJoio8kk=\");\n_c = CandlestickChart;\nvar _c;\n$RefreshReg$(_c, \"CandlestickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVpRTtBQUNoQjtBQUNnRDtBQUNqQjtBQU9qQztBQUNEO0FBUWpCO0FBb0I3QixzQ0FBc0M7QUFDdEMsTUFBTWUscUJBQXFCLENBQUNDO0lBQzFCLE9BQVFBO1FBQ04sS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFPLE9BQU87UUFDbkIsS0FBSztZQUFPLE9BQU87UUFDbkIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEIsS0FBSztZQUFNLE9BQU87UUFDbEI7WUFBUyxPQUFPO0lBQ2xCO0FBQ0Y7QUFFTyxTQUFTQyxpQkFBaUIsS0FRVDtRQVJTLEVBQy9CQyxTQUFTLEVBQ1RDLFFBQVEsRUFDUkMsUUFBUSxLQUFLLEVBQ2JDLFlBQVksTUFBTSxFQUNsQkMsV0FBVyxlQUFlLEVBQzFCQyxlQUFlLEtBQU8sQ0FBQyxFQUN2QkMsVUFBVSxFQUFFLEVBQ1UsR0FSUzs7SUFTL0IsTUFBTSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHeEIsK0NBQVFBLENBQUNvQjtJQUN6RCxNQUFNLENBQUNLLGtCQUFrQkMsb0JBQW9CLEdBQUcxQiwrQ0FBUUEsQ0FBQ21CO0lBQ3pELE1BQU0sQ0FBQ1EsY0FBY0MsZ0JBQWdCLEdBQUc1QiwrQ0FBUUEsQ0FBUyxJQUFNVywrREFBV0EsQ0FBQyxHQUFHUTtJQUM5RSxNQUFNLENBQUNVLFlBQVlDLGNBQWMsR0FBRzlCLCtDQUFRQSxDQUFDLElBQU87WUFDbEQrQixVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxTQUFTdkIsK0RBQVdBLENBQUMsR0FBR1E7WUFDeEJnQixRQUFReEIsK0RBQVdBLENBQUMsR0FBR1E7UUFDekI7SUFFQSxNQUFNaUIsb0JBQW9CckMsNkNBQU1BLENBQWlCO0lB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LFVBQVUsQ0FBQ3JJLGdCQUFnQk8sT0FBTztRQUNqRTtJQUNGLEdBQUc7UUFBQ1AsZ0JBQWdCTyxPQUFPO0tBQUM7SUFFNUJsRCxnREFBU0EsQ0FBQztRQUNSLElBQUk0QyxrQkFBa0JNLE9BQU8sQ0FBQ08sTUFBTSxHQUFHLEdBQUc7WUFDeENOLGlCQUFpQlAsa0JBQWtCTSxPQUFPO1FBQzVDO0lBQ0YsR0FBRztRQUFDTixrQkFBa0JNLE9BQU87S0FBQztJQUU5QiwwQ0FBMEM7SUFDMUMsTUFBTStILHFCQUFxQixDQUFDekYsUUFBa0JlLE1BQWMyRTtRQUMxRCxPQUFRM0U7WUFDTixLQUFLO2dCQUNILE9BQU8vRixrRkFBWUEsQ0FBQ2dGLFFBQVEwRjtZQUM5QixLQUFLO2dCQUNILE9BQU96SyxrRkFBWUEsQ0FBQytFLFFBQVEwRjtZQUM5QixLQUFLO2dCQUNILE9BQU94SyxtRkFBYUEsQ0FBQzhFLFFBQVEwRjtZQUMvQixLQUFLO2dCQUNILE9BQU92SyxrRkFBWUEsQ0FBQzZFLFFBQVEwRjtZQUM5QjtnQkFDRSxPQUFPLEVBQUU7UUFDYjtJQUNGO0lBRUEscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDeEssdURBQVlBO2dCQUNYUSxPQUFPQTtnQkFDUEMsV0FBV007Z0JBQ1hMLFVBQVVHO2dCQUNWSSxjQUFjQTtnQkFDZEUsWUFBWUE7Z0JBQ1pzSixrQkFBa0IzSjtnQkFDbEJILGNBQWMrQjs7Ozs7OzBCQUVoQiw4REFBQzZIO2dCQUFJRyxLQUFLaEo7Z0JBQW1COEksV0FBVTs7Ozs7Ozs7Ozs7O0FBRzdDO0dBL2RnQm5LO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0L0NhbmRsZXN0aWNrQ2hhcnQudHN4PzhkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgVGltZSwgSUNoYXJ0QXBpLCBDaGFydE9wdGlvbnMsIERlZXBQYXJ0aWFsLCBMaW5lV2lkdGgsIEJ1c2luZXNzRGF5LCBVVENUaW1lc3RhbXAgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCB7IGdldEhpc3RvcmljYWxEYXRhLCBzdWJzY3JpYmVUb1ByaWNlLCBUaW1lZnJhbWUgfSBmcm9tICdAL3NlcnZpY2VzL2FwaS9jcnlwdG9Db21wYXJlQVBJJztcbmltcG9ydCB7IFN0cmF0ZWd5SWQsIGdldFN0cmF0ZWd5LCBTdHJhdGVneVNpZ25hbCB9IGZyb20gJ0Avc2VydmljZXMvc3RyYXRlZ2llcyc7XG5pbXBvcnQgeyBcbiAgY2FsY3VsYXRlRU1BLFxuICBjYWxjdWxhdGVTTUEsXG4gIGNhbGN1bGF0ZVRFTUEsXG4gIGNhbGN1bGF0ZUhNQSxcbiAgY2FsY3VsYXRlTUFDRFxufSBmcm9tICdAL3NlcnZpY2VzL3N0cmF0ZWdpZXMvbW92aW5nLWF2ZXJhZ2VzJztcbmltcG9ydCB7IFRpY2tlckhlYWRlciB9IGZyb20gJy4vVGlja2VySGVhZGVyJztcbmltcG9ydCB7IFxuICBnZXRDaGFydFByaWNlRm9ybWF0LCBcbiAgZ2V0U2NhbGVGb3JtYXQsIFxuICBmb3JtYXRQcmljZSwgXG4gIGlzQlRDUGFpcixcbiAgREVGQVVMVF9CVENfRk9STUFULFxuICBERUZBVUxUX1VTRFRfRk9STUFUXG59IGZyb20gJ0AvdXRpbHMvcHJpY2VGb3JtYXQnO1xuXG5pbnRlcmZhY2UgQ2FuZGxlc3RpY2tDaGFydFByb3BzIHtcbiAgdGltZWZyYW1lOiBUaW1lZnJhbWU7XG4gIHN0cmF0ZWd5OiBTdHJhdGVneUlkO1xuICB0b2tlbj86IHN0cmluZztcbiAgYmFzZVRva2VuPzogc3RyaW5nO1xuICBleGNoYW5nZT86IHN0cmluZztcbiAgb25QYWlyQ2hhbmdlPzogKHRva2VuOiBzdHJpbmcsIGJhc2VUb2tlbjogc3RyaW5nKSA9PiB2b2lkO1xuICBzaWduYWxzPzogU3RyYXRlZ3lTaWduYWxbXTtcbn1cblxuaW50ZXJmYWNlIENhbmRsZSB7XG4gIHRpbWU6IFRpbWU7XG4gIG9wZW46IG51bWJlcjtcbiAgaGlnaDogbnVtYmVyO1xuICBsb3c6IG51bWJlcjtcbiAgY2xvc2U6IG51bWJlcjtcbn1cblxuLy8gRnVuY3Rpb24gdG8gZ2V0IGludGVydmFsIGluIHNlY29uZHNcbmNvbnN0IGdldEludGVydmFsU2Vjb25kcyA9ICh0ZjogVGltZWZyYW1lKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoICh0Zikge1xuICAgIGNhc2UgJzFtJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJzVtJzogcmV0dXJuIDMwMDtcbiAgICBjYXNlICcxNW0nOiByZXR1cm4gOTAwO1xuICAgIGNhc2UgJzMwbSc6IHJldHVybiAxODAwO1xuICAgIGNhc2UgJzFoJzogcmV0dXJuIDM2MDA7XG4gICAgY2FzZSAnNGgnOiByZXR1cm4gMTQ0MDA7XG4gICAgY2FzZSAnMWQnOiByZXR1cm4gODY0MDA7XG4gICAgZGVmYXVsdDogcmV0dXJuIDYwO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FuZGxlc3RpY2tDaGFydCh7IFxuICB0aW1lZnJhbWUsIFxuICBzdHJhdGVneSwgXG4gIHRva2VuID0gJ0JUQycsIFxuICBiYXNlVG9rZW4gPSAnVVNEVCcsXG4gIGV4Y2hhbmdlID0gJ0NyeXB0b0NvbXBhcmUnLFxuICBvblBhaXJDaGFuZ2UgPSAoKSA9PiB7fSxcbiAgc2lnbmFscyA9IFtdXG59OiBDYW5kbGVzdGlja0NoYXJ0UHJvcHMpIHtcbiAgY29uc3QgW3NlbGVjdGVkRXhjaGFuZ2UsIHNldFNlbGVjdGVkRXhjaGFuZ2VdID0gdXNlU3RhdGUoZXhjaGFuZ2UpO1xuICBjb25zdCBbY3VycmVudEJhc2VUb2tlbiwgc2V0Q3VycmVudEJhc2VUb2tlbl0gPSB1c2VTdGF0ZShiYXNlVG9rZW4pO1xuICBjb25zdCBbY3VycmVudFByaWNlLCBzZXRDdXJyZW50UHJpY2VdID0gdXNlU3RhdGU8c3RyaW5nPigoKSA9PiBmb3JtYXRQcmljZSgwLCBiYXNlVG9rZW4pKTtcbiAgY29uc3QgW3ByaWNlU3RhdHMsIHNldFByaWNlU3RhdHNdID0gdXNlU3RhdGUoKCkgPT4gKHtcbiAgICBjaGFuZ2UxaDogJzAuMDAnLFxuICAgIGNoYW5nZTI0aDogJzAuMDAnLFxuICAgIGNoYW5nZTdkOiAnMC4wMCcsXG4gICAgaGlnaDI0aDogZm9ybWF0UHJpY2UoMCwgYmFzZVRva2VuKSxcbiAgICBsb3cyNGg6IGZvcm1hdFByaWNlKDAsIGJhc2VUb2tlbilcbiAgfSkpO1xuXG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SUNoYXJ0QXBpIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGluZGljYXRvclNlcmllc1JlZnMgPSB1c2VSZWY8TWFwPHN0cmluZywgYW55Pj4obmV3IE1hcCgpKTtcbiAgY29uc3QgbWFya2VyU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGhpc3RvcmljYWxEYXRhUmVmID0gdXNlUmVmPGFueVtdPihbXSk7XG4gIGNvbnN0IGN1cnJlbnRDYW5kbGVSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgbGFzdFNpZ25hbFJlZiA9IHVzZVJlZjx7IHRpbWU6IG51bWJlciwgdHlwZTogJ2J1eScgfCAnc2VsbCcgfSB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEFkZCByZWZlcmVuY2UgZm9yIHN0YXRzIGRhdGFcbiAgY29uc3Qgc3RhdHNEYXRhUmVmID0gdXNlUmVmPGFueVtdPihbXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gZmV0Y2ggZGF0YSBmb3Igc3RhdHMgY2FsY3VsYXRpb25zXG4gIGNvbnN0IGZldGNoU3RhdHNEYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGZXRjaCAxLW1pbnV0ZSBkYXRhIGZvciBhY2N1cmF0ZSBzdGF0cyBjYWxjdWxhdGlvbnNcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSgnMW0nLCB0b2tlbiwgY3VycmVudEJhc2VUb2tlbik7XG4gICAgICBzdGF0c0RhdGFSZWYuY3VycmVudCA9IGRhdGE7XG4gICAgICB1cGRhdGVQcmljZVN0YXRzKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzdGF0cyBkYXRhOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFt0b2tlbiwgY3VycmVudEJhc2VUb2tlbiwgdXBkYXRlUHJpY2VTdGF0c10pO1xuXG4gIC8vIEVmZmVjdCB0byBmZXRjaCBzdGF0cyBkYXRhIHdoZW4gcGFpciBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hTdGF0c0RhdGEoKTtcbiAgfSwgW3Rva2VuLCBjdXJyZW50QmFzZVRva2VuLCBmZXRjaFN0YXRzRGF0YV0pO1xuXG4gIC8vIEhhbmRsZSB0cmFkaW5nIHBhaXIgY2hhbmdlXG4gIGNvbnN0IGhhbmRsZVBhaXJDaGFuZ2UgPSB1c2VDYWxsYmFjaygobmV3VG9rZW46IHN0cmluZywgbmV3QmFzZVRva2VuOiBzdHJpbmcpID0+IHtcbiAgICBvblBhaXJDaGFuZ2UobmV3VG9rZW4sIG5ld0Jhc2VUb2tlbik7XG4gICAgc2V0Q3VycmVudEJhc2VUb2tlbihuZXdCYXNlVG9rZW4pO1xuICB9LCBbb25QYWlyQ2hhbmdlXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHByaWNlIHN0YXRzXG4gIGNvbnN0IHVwZGF0ZVByaWNlU3RhdHMgPSB1c2VDYWxsYmFjaygoZGF0YTogYW55W10pID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uY2xvc2U7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0udGltZTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGltZSB0aHJlc2hvbGRzIGluIHNlY29uZHNcbiAgICBjb25zdCBvbmVIb3VyQWdvID0gY3VycmVudFRpbWUgLSAoNjAgKiA2MCk7XG4gICAgY29uc3QgdHdlbnR5Rm91ckhvdXJzQWdvID0gY3VycmVudFRpbWUgLSAoMjQgKiA2MCAqIDYwKTtcbiAgICBjb25zdCBzZXZlbkRheXNBZ28gPSBjdXJyZW50VGltZSAtICg3ICogMjQgKiA2MCAqIDYwKTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgZGF0YSBmb3IgZWFjaCB0aW1lIHBlcmlvZFxuICAgIGNvbnN0IGxhc3QxaCA9IGRhdGEuZmlsdGVyKGQgPT4gZC50aW1lID49IG9uZUhvdXJBZ28pO1xuICAgIGNvbnN0IGxhc3QyNGggPSBkYXRhLmZpbHRlcihkID0+IGQudGltZSA+PSB0d2VudHlGb3VySG91cnNBZ28pO1xuICAgIGNvbnN0IGxhc3Q3ZCA9IGRhdGEuZmlsdGVyKGQgPT4gZC50aW1lID49IHNldmVuRGF5c0Fnbyk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyBmb3IgMjRoXG4gICAgY29uc3QgaGlnaDI0aCA9IE1hdGgubWF4KC4uLmxhc3QyNGgubWFwKGQgPT4gZC5oaWdoKSk7XG4gICAgY29uc3QgbG93MjRoID0gTWF0aC5taW4oLi4ubGFzdDI0aC5tYXAoZCA9PiBkLmxvdykpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIGNoYW5nZXNcbiAgICBjb25zdCBnZXRQZXJjZW50Q2hhbmdlID0gKHBlcmlvZERhdGE6IGFueVtdKSA9PiB7XG4gICAgICBpZiAocGVyaW9kRGF0YS5sZW5ndGggPCAxKSByZXR1cm4gMDtcbiAgICAgIGNvbnN0IG9sZFByaWNlID0gcGVyaW9kRGF0YVswXS5jbG9zZTtcbiAgICAgIHJldHVybiAoKGN1cnJlbnRQcmljZSAtIG9sZFByaWNlKSAvIG9sZFByaWNlKSAqIDEwMDtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhbmdlMWggPSBnZXRQZXJjZW50Q2hhbmdlKGxhc3QxaCk7XG4gICAgY29uc3QgY2hhbmdlMjRoID0gZ2V0UGVyY2VudENoYW5nZShsYXN0MjRoKTtcbiAgICBjb25zdCBjaGFuZ2U3ZCA9IGdldFBlcmNlbnRDaGFuZ2UobGFzdDdkKTtcbiAgICBcbiAgICAvLyBGb3JtYXQgcHJpY2VzIHVzaW5nIHRoZSBwcmljZSBmb3JtYXQgdXRpbGl0eVxuICAgIGNvbnN0IGZvcm1hdHRlZEhpZ2ggPSBmb3JtYXRQcmljZShoaWdoMjRoLCBjdXJyZW50QmFzZVRva2VuKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRMb3cgPSBmb3JtYXRQcmljZShsb3cyNGgsIGN1cnJlbnRCYXNlVG9rZW4pO1xuXG4gICAgc2V0UHJpY2VTdGF0cyh7XG4gICAgICBjaGFuZ2UxaDogY2hhbmdlMWgudG9GaXhlZCgyKSxcbiAgICAgIGNoYW5nZTI0aDogY2hhbmdlMjRoLnRvRml4ZWQoMiksXG4gICAgICBjaGFuZ2U3ZDogY2hhbmdlN2QudG9GaXhlZCgyKSxcbiAgICAgIGhpZ2gyNGg6IGZvcm1hdHRlZEhpZ2gsXG4gICAgICBsb3cyNGg6IGZvcm1hdHRlZExvd1xuICAgIH0pO1xuICB9LCBbY3VycmVudEJhc2VUb2tlbl0pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGFkZCBzdHJhdGVneSBpbmRpY2F0b3JzXG4gIGNvbnN0IGFkZFN0cmF0ZWd5SW5kaWNhdG9ycyA9IHVzZUNhbGxiYWNrKChjaGFydDogSUNoYXJ0QXBpLCBkYXRhOiBhbnlbXSkgPT4ge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NoYXJ0IGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5kaWNhdG9yc1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VyaWVzICYmIGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzZXJpZXM6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG5cbiAgICAgIGlmIChtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYXJ0LnJlbW92ZVNlcmllcyhtYXJrZXJTZXJpZXNSZWYuY3VycmVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBtYXJrZXIgc2VyaWVzOicsIGUpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbm9uZScpIHJldHVybjtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGluZGljYXRvcnMgYmFzZWQgb24gc3RyYXRlZ3lcbiAgICAgIGNvbnN0IHByaWNlcyA9IGRhdGEubWFwKGQgPT4gZC5jbG9zZSk7XG4gICAgICBsZXQgZmFzdExpbmU6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgc2xvd0xpbmU6IG51bWJlcltdID0gW107XG5cbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAnZW1hX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCA5KTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDIxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc21hX2Nyb3Nzb3Zlcic6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVTTUEocHJpY2VzLCA5KTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDIxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGVtYV9jcm9zc292ZXInOlxuICAgICAgICAgIGZhc3RMaW5lID0gY2FsY3VsYXRlVEVNQShwcmljZXMsIDcpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlVEVNQShwcmljZXMsIDIxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ29sZGVuX2Nyb3NzJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDUwKTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZVNNQShwcmljZXMsIDIwMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2h1bGxfY3Jvc3NvdmVyJzpcbiAgICAgICAgICBmYXN0TGluZSA9IGNhbGN1bGF0ZUhNQShwcmljZXMsIDkpO1xuICAgICAgICAgIHNsb3dMaW5lID0gY2FsY3VsYXRlSE1BKHByaWNlcywgMjEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbWFfNV8xMyc6XG4gICAgICAgICAgZmFzdExpbmUgPSBjYWxjdWxhdGVFTUEocHJpY2VzLCA1KTtcbiAgICAgICAgICBzbG93TGluZSA9IGNhbGN1bGF0ZUVNQShwcmljZXMsIDEzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGluZGljYXRvciBsaW5lc1xuICAgICAgY29uc3Qgc2VsZWN0ZWRTdHJhdGVneSA9IGdldFN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgICAgIGlmICghc2VsZWN0ZWRTdHJhdGVneSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBjb2xvcnMgPSBbJyMyOTYyRkYnLCAnI0ZGNkI2QiddO1xuICAgICAgc2VsZWN0ZWRTdHJhdGVneS5pbmRpY2F0b3JzLmZvckVhY2goKGluZGljYXRvciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZExpbmVTZXJpZXMoe1xuICAgICAgICAgIGNvbG9yOiBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICB0aXRsZTogaW5kaWNhdG9yLm5hbWUsXG4gICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgICAgICBwcmVjaXNpb246IGlzQlRDUGFpcihjdXJyZW50QmFzZVRva2VuKSA/IDggOiAyLFxuICAgICAgICAgICAgbWluTW92ZTogaXNCVENQYWlyKGN1cnJlbnRCYXNlVG9rZW4pID8gMC4wMDAwMDAwMSA6IDAuMDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5zZXQoaW5kaWNhdG9yLm5hbWUsIGxpbmVTZXJpZXMpO1xuXG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gKGluZGV4ID09PSAwID8gZmFzdExpbmUgOiBzbG93TGluZSlcbiAgICAgICAgICAubWFwKCh2YWx1ZSwgaWR4KSA9PiAoe1xuICAgICAgICAgICAgdGltZTogZGF0YVtpZHhdLnRpbWUsXG4gICAgICAgICAgICB2YWx1ZTogaXNOYU4odmFsdWUpID8gbnVsbCA6IHZhbHVlXG4gICAgICAgICAgfSkpXG4gICAgICAgICAgLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpO1xuXG4gICAgICAgIGxpbmVTZXJpZXMuc2V0RGF0YShsaW5lRGF0YSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGNyb3Nzb3ZlciBzaWduYWxzIHdpdGggbWFya2VycywgdGV4dCwgYW5kIHRyaWFuZ2xlIHNoYXBlXG4gICAgICBjb25zdCBtYXJrZXJzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldkZhc3QgPSBmYXN0TGluZVtpIC0gMV07XG4gICAgICAgIGNvbnN0IHByZXZTbG93ID0gc2xvd0xpbmVbaSAtIDFdO1xuICAgICAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RMaW5lW2ldO1xuICAgICAgICBjb25zdCBjdXJyU2xvdyA9IHNsb3dMaW5lW2ldO1xuXG4gICAgICAgIGlmICghaXNOYU4ocHJldkZhc3QpICYmICFpc05hTihwcmV2U2xvdykgJiYgIWlzTmFOKGN1cnJGYXN0KSAmJiAhaXNOYU4oY3VyclNsb3cpKSB7XG4gICAgICAgICAgaWYgKHByZXZGYXN0IDw9IHByZXZTbG93ICYmIGN1cnJGYXN0ID4gY3VyclNsb3cpIHtcbiAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgIHRpbWU6IGRhdGFbaV0udGltZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdiZWxvd0JhcicsXG4gICAgICAgICAgICAgIGNvbG9yOiAnIzI2YTY5YScsXG4gICAgICAgICAgICAgIHNoYXBlOiAnYXJyb3dVcCcsXG4gICAgICAgICAgICAgIHRleHQ6ICdCdXknLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2RmFzdCA+PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA8IGN1cnJTbG93KSB7XG4gICAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICB0aW1lOiBkYXRhW2ldLnRpbWUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJvdmVCYXInLFxuICAgICAgICAgICAgICBjb2xvcjogJyNlZjUzNTAnLFxuICAgICAgICAgICAgICBzaGFwZTogJ2Fycm93RG93bicsXG4gICAgICAgICAgICAgIHRleHQ6ICdTZWxsJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCA9IG1hcmtlcnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzdHJhdGVneSBpbmRpY2F0b3JzOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtzdHJhdGVneSwgY3VycmVudEJhc2VUb2tlbl0pO1xuXG4gIC8vIEVmZmVjdCBmb3Igc3RyYXRlZ3kgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRSZWYuY3VycmVudCB8fCBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzKGNoYXJ0UmVmLmN1cnJlbnQsIGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzdHJhdGVneSBjaGFuZ2UgZWZmZWN0OicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtzdHJhdGVneSwgYWRkU3RyYXRlZ3lJbmRpY2F0b3JzXSk7XG5cbiAgLy8gTWFpbiBjaGFydCBpbml0aWFsaXphdGlvbiBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IGNoYXJ0T3B0aW9uczogRGVlcFBhcnRpYWw8Q2hhcnRPcHRpb25zPiA9IHtcbiAgICAgIGxheW91dDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzFFMjIyRCcgfSxcbiAgICAgICAgdGV4dENvbG9yOiAnI0RERCcsXG4gICAgICB9LFxuICAgICAgZ3JpZDoge1xuICAgICAgICB2ZXJ0TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgICBob3J6TGluZXM6IHsgY29sb3I6ICcjMkIyQjQzJyB9LFxuICAgICAgfSxcbiAgICAgIHRpbWVTY2FsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICByaWdodFByaWNlU2NhbGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgc2NhbGVNYXJnaW5zOiB7XG4gICAgICAgICAgdG9wOiAwLjEsXG4gICAgICAgICAgYm90dG9tOiAwLjQsXG4gICAgICAgIH0sXG4gICAgICAgIGF1dG9TY2FsZTogdHJ1ZSxcbiAgICAgICAgbW9kZTogMCxcbiAgICAgICAgYWxpZ25MYWJlbHM6IHRydWUsXG4gICAgICAgIGJvcmRlclZpc2libGU6IHRydWUsXG4gICAgICAgIGVudGlyZVRleHRPbmx5OiB0cnVlLFxuICAgICAgICB0aWNrc1Zpc2libGU6IHRydWUsXG4gICAgICB9LFxuICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgbG9jYWxpemF0aW9uOiB7XG4gICAgICAgIHByaWNlRm9ybWF0dGVyOiAocHJpY2U6IG51bWJlcikgPT4gZm9ybWF0UHJpY2UocHJpY2UsIGN1cnJlbnRCYXNlVG9rZW4pLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCBjaGFydE9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIGNhbmRsZXN0aWNrIHNlcmllcyB3aXRoIHByaWNlIGZvcm1hdFxuICAgIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe1xuICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgIHdpY2tVcENvbG9yOiAnIzI2YTY5YScsXG4gICAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgICBwcmljZUZvcm1hdDoge1xuICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICBwcmVjaXNpb246IGlzQlRDUGFpcihjdXJyZW50QmFzZVRva2VuKSA/IDggOiAyLFxuICAgICAgICBtaW5Nb3ZlOiBpc0JUQ1BhaXIoY3VycmVudEJhc2VUb2tlbikgPyAwLjAwMDAwMDAxIDogMC4wMSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2FuZGxlc3RpY2tTZXJpZXM7XG4gICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuXG4gICAgLy8gTG9hZCBpbml0aWFsIGRhdGFcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRIaXN0b3JpY2FsRGF0YSh0aW1lZnJhbWUsIHRva2VuLCBjdXJyZW50QmFzZVRva2VuKTtcbiAgICAgICAgaGlzdG9yaWNhbERhdGFSZWYuY3VycmVudCA9IGRhdGE7XG4gICAgICAgIFxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5zZXREYXRhKGRhdGEpO1xuICAgICAgICB1cGRhdGVQcmljZVN0YXRzKGRhdGEpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBjYW5kbGUgcmVmZXJlbmNlIHRvIHRoZSBsYXN0IGNhbmRsZVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudENhbmRsZVJlZi5jdXJyZW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBhZGRTdHJhdGVneUluZGljYXRvcnMoY2hhcnQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkRGF0YSgpO1xuXG4gICAgLy8gUmVhbC10aW1lIHVwZGF0ZXNcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZVRvUHJpY2UoKGRhdGEpID0+IHtcbiAgICAgIGlmICghY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NhbmRsZXN0aWNrIHNlcmllcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY3VycmVudCBwcmljZSBkaXNwbGF5IGltbWVkaWF0ZWx5XG4gICAgICBjb25zdCBmb3JtYXR0ZWRQcmljZSA9IGZvcm1hdFByaWNlKGRhdGEudmFsdWUsIGN1cnJlbnRCYXNlVG9rZW4pO1xuICAgICAgc2V0Q3VycmVudFByaWNlKGZvcm1hdHRlZFByaWNlKTtcblxuICAgICAgY29uc3QgaW50ZXJ2YWxTZWNvbmRzID0gZ2V0SW50ZXJ2YWxTZWNvbmRzKHRpbWVmcmFtZSk7XG4gICAgICBjb25zdCBjYW5kbGVUaW1lc3RhbXAgPSBNYXRoLmZsb29yKGRhdGEudGltZSAvIGludGVydmFsU2Vjb25kcykgKiBpbnRlcnZhbFNlY29uZHM7XG5cbiAgICAgIC8vIFVwZGF0ZSBjaGFydCBjYW5kbGVzXG4gICAgICBpZiAoIWN1cnJlbnRDYW5kbGVSZWYuY3VycmVudCB8fCBjYW5kbGVUaW1lc3RhbXAgIT09IGN1cnJlbnRDYW5kbGVSZWYuY3VycmVudC50aW1lKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50LnB1c2goY3VycmVudENhbmRsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld0NhbmRsZSA9IHtcbiAgICAgICAgICB0aW1lOiBjYW5kbGVUaW1lc3RhbXAgYXMgVVRDVGltZXN0YW1wLFxuICAgICAgICAgIG9wZW46IGRhdGEudmFsdWUsXG4gICAgICAgICAgaGlnaDogZGF0YS52YWx1ZSxcbiAgICAgICAgICBsb3c6IGRhdGEudmFsdWUsXG4gICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQgPSBuZXdDYW5kbGU7XG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQudXBkYXRlKG5ld0NhbmRsZSk7XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnbm9uZScgJiYgY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIGFkZFN0cmF0ZWd5SW5kaWNhdG9ycyhjaGFydFJlZi5jdXJyZW50LCBoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZENhbmRsZSA9IHtcbiAgICAgICAgICAuLi5jdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgaGlnaDogTWF0aC5tYXgoY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmhpZ2gsIGRhdGEudmFsdWUpLFxuICAgICAgICAgIGxvdzogTWF0aC5taW4oY3VycmVudENhbmRsZVJlZi5jdXJyZW50LmxvdywgZGF0YS52YWx1ZSksXG4gICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBjdXJyZW50Q2FuZGxlUmVmLmN1cnJlbnQgPSB1cGRhdGVkQ2FuZGxlO1xuICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnVwZGF0ZSh1cGRhdGVkQ2FuZGxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHN0YXRzIGRhdGEgd2l0aCB0aGUgbGF0ZXN0IHByaWNlXG4gICAgICBpZiAoc3RhdHNEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1cGRhdGVkU3RhdHNEYXRhID0gWy4uLnN0YXRzRGF0YVJlZi5jdXJyZW50XTtcbiAgICAgICAgY29uc3QgbGFzdENhbmRsZSA9IHVwZGF0ZWRTdGF0c0RhdGFbdXBkYXRlZFN0YXRzRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhLnRpbWUgPiBsYXN0Q2FuZGxlLnRpbWUpIHtcbiAgICAgICAgICAvLyBBZGQgbmV3IGNhbmRsZSB0byBzdGF0cyBkYXRhXG4gICAgICAgICAgdXBkYXRlZFN0YXRzRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IGRhdGEudGltZSxcbiAgICAgICAgICAgIG9wZW46IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBoaWdoOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgbG93OiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgY2xvc2U6IGRhdGEudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBSZW1vdmUgb2xkIGRhdGEgdG8ga2VlcCB0aGUgYXJyYXkgc2l6ZSBtYW5hZ2VhYmxlXG4gICAgICAgICAgaWYgKHVwZGF0ZWRTdGF0c0RhdGEubGVuZ3RoID4gMTAwODApIHsgLy8gS2VlcCBhYm91dCA3IGRheXMgb2YgMS1taW51dGUgZGF0YVxuICAgICAgICAgICAgdXBkYXRlZFN0YXRzRGF0YS5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVcGRhdGUgbGFzdCBjYW5kbGVcbiAgICAgICAgICBsYXN0Q2FuZGxlLmNsb3NlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBsYXN0Q2FuZGxlLmhpZ2ggPSBNYXRoLm1heChsYXN0Q2FuZGxlLmhpZ2gsIGRhdGEudmFsdWUpO1xuICAgICAgICAgIGxhc3RDYW5kbGUubG93ID0gTWF0aC5taW4obGFzdENhbmRsZS5sb3csIGRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdGF0c0RhdGFSZWYuY3VycmVudCA9IHVwZGF0ZWRTdGF0c0RhdGE7XG4gICAgICAgIHVwZGF0ZVByaWNlU3RhdHModXBkYXRlZFN0YXRzRGF0YSk7XG4gICAgICB9XG4gICAgfSwgdGltZWZyYW1lLCB0b2tlbiwgY3VycmVudEJhc2VUb2tlbik7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6ZVxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5hcHBseU9wdGlvbnMoe1xuICAgICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hhcnRDb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGluZGljYXRvclNlcmllc1JlZnMuY3VycmVudC5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQ/LnJlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGluZGljYXRvciBzZXJpZXMgZHVyaW5nIGNsZWFudXA6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNhdG9yU2VyaWVzUmVmcy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmVTZXJpZXMobWFya2VyU2VyaWVzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIG1hcmtlciBzZXJpZXMgZHVyaW5nIGNsZWFudXA6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtlclNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2hhcnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3RpbWVmcmFtZSwgY3VycmVudEJhc2VUb2tlbiwgc3RyYXRlZ3ksIHRva2VuLCB1cGRhdGVQcmljZVN0YXRzLCBhZGRTdHJhdGVneUluZGljYXRvcnNdKTtcblxuICAvLyBFbnN1cmUgbWFya2VycyBhcmUgc2V0IG9uIHRoZSBjYW5kbGVzdGljayBzZXJpZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCAmJiBtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC5zZXRNYXJrZXJzKG1hcmtlclNlcmllc1JlZi5jdXJyZW50KTtcbiAgICB9XG4gIH0sIFttYXJrZXJTZXJpZXNSZWYuY3VycmVudF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhpc3RvcmljYWxEYXRhUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlUHJpY2VTdGF0cyhoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9XG4gIH0sIFtoaXN0b3JpY2FsRGF0YVJlZi5jdXJyZW50XSk7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBpbmRpY2F0b3JzXG4gIGNvbnN0IGNhbGN1bGF0ZUluZGljYXRvciA9IChwcmljZXM6IG51bWJlcltdLCB0eXBlOiBzdHJpbmcsIHBlcmlvZDogbnVtYmVyKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdlbWEnOlxuICAgICAgICByZXR1cm4gY2FsY3VsYXRlRU1BKHByaWNlcywgcGVyaW9kKTtcbiAgICAgIGNhc2UgJ3NtYSc6XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVTTUEocHJpY2VzLCBwZXJpb2QpO1xuICAgICAgY2FzZSAndGVtYSc6XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVURU1BKHByaWNlcywgcGVyaW9kKTtcbiAgICAgIGNhc2UgJ2htYSc6XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVITUEocHJpY2VzLCBwZXJpb2QpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCB3LWZ1bGwgaC1mdWxsXCI+XG4gICAgICA8VGlja2VySGVhZGVyXG4gICAgICAgIHRva2VuPXt0b2tlbn1cbiAgICAgICAgYmFzZVRva2VuPXtjdXJyZW50QmFzZVRva2VufVxuICAgICAgICBleGNoYW5nZT17c2VsZWN0ZWRFeGNoYW5nZX1cbiAgICAgICAgY3VycmVudFByaWNlPXtjdXJyZW50UHJpY2V9XG4gICAgICAgIHByaWNlU3RhdHM9e3ByaWNlU3RhdHN9XG4gICAgICAgIG9uRXhjaGFuZ2VDaGFuZ2U9e3NldFNlbGVjdGVkRXhjaGFuZ2V9XG4gICAgICAgIG9uUGFpckNoYW5nZT17aGFuZGxlUGFpckNoYW5nZX1cbiAgICAgIC8+XG4gICAgICA8ZGl2IHJlZj17Y2hhcnRDb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cImZsZXgtMVwiIC8+XG4gICAgPC9kaXY+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiY3JlYXRlQ2hhcnQiLCJnZXRIaXN0b3JpY2FsRGF0YSIsInN1YnNjcmliZVRvUHJpY2UiLCJnZXRTdHJhdGVneSIsImNhbGN1bGF0ZUVNQSIsImNhbGN1bGF0ZVNNQSIsImNhbGN1bGF0ZVRFTUEiLCJjYWxjdWxhdGVITUEiLCJUaWNrZXJIZWFkZXIiLCJmb3JtYXRQcmljZSIsImlzQlRDUGFpciIsImdldEludGVydmFsU2Vjb25kcyIsInRmIiwiQ2FuZGxlc3RpY2tDaGFydCIsInRpbWVmcmFtZSIsInN0cmF0ZWd5IiwidG9rZW4iLCJiYXNlVG9rZW4iLCJleGNoYW5nZSIsIm9uUGFpckNoYW5nZSIsInNpZ25hbHMiLCJzZWxlY3RlZEV4Y2hhbmdlIiwic2V0U2VsZWN0ZWRFeGNoYW5nZSIsImN1cnJlbnRCYXNlVG9rZW4iLCJzZXRDdXJyZW50QmFzZVRva2VuIiwiY3VycmVudFByaWNlIiwic2V0Q3VycmVudFByaWNlIiwicHJpY2VTdGF0cyIsInNldFByaWNlU3RhdHMiLCJjaGFuZ2UxaCIsImNoYW5nZTI0aCIsImNoYW5nZTdkIiwiaGlnaDI0aCIsImxvdzI0aCIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsImluZGljYXRvclNlcmllc1JlZnMiLCJNYXAiLCJtYXJrZXJTZXJpZXNSZWYiLCJoaXN0b3JpY2FsRGF0YVJlZiIsImN1cnJlbnRDYW5kbGVSZWYiLCJsYXN0U2lnbmFsUmVmIiwic3RhdHNEYXRhUmVmIiwiZmV0Y2hTdGF0c0RhdGEiLCJkYXRhIiwiY3VycmVudCIsInVwZGF0ZVByaWNlU3RhdHMiLCJlcnJvciIsImNvbnNvbGUiLCJoYW5kbGVQYWlyQ2hhbmdlIiwibmV3VG9rZW4iLCJuZXdCYXNlVG9rZW4iLCJsZW5ndGgiLCJjbG9zZSIsImN1cnJlbnRUaW1lIiwidGltZSIsIm9uZUhvdXJBZ28iLCJ0d2VudHlGb3VySG91cnNBZ28iLCJzZXZlbkRheXNBZ28iLCJsYXN0MWgiLCJmaWx0ZXIiLCJkIiwibGFzdDI0aCIsImxhc3Q3ZCIsIk1hdGgiLCJtYXgiLCJtYXAiLCJoaWdoIiwibWluIiwibG93IiwiZ2V0UGVyY2VudENoYW5nZSIsInBlcmlvZERhdGEiLCJvbGRQcmljZSIsImZvcm1hdHRlZEhpZ2giLCJmb3JtYXR0ZWRMb3ciLCJ0b0ZpeGVkIiwiYWRkU3RyYXRlZ3lJbmRpY2F0b3JzIiwiY2hhcnQiLCJmb3JFYWNoIiwic2VyaWVzIiwicmVtb3ZlU2VyaWVzIiwiZSIsImNsZWFyIiwicHJpY2VzIiwiZmFzdExpbmUiLCJzbG93TGluZSIsInNlbGVjdGVkU3RyYXRlZ3kiLCJjb2xvcnMiLCJpbmRpY2F0b3JzIiwiaW5kaWNhdG9yIiwiaW5kZXgiLCJsaW5lU2VyaWVzIiwiYWRkTGluZVNlcmllcyIsImNvbG9yIiwibGluZVdpZHRoIiwidGl0bGUiLCJuYW1lIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJlY2lzaW9uIiwibWluTW92ZSIsInNldCIsImxpbmVEYXRhIiwidmFsdWUiLCJpZHgiLCJpc05hTiIsInNldERhdGEiLCJtYXJrZXJzIiwiaSIsInByZXZGYXN0IiwicHJldlNsb3ciLCJjdXJyRmFzdCIsImN1cnJTbG93IiwicHVzaCIsInBvc2l0aW9uIiwic2hhcGUiLCJ0ZXh0IiwiY2hhcnRPcHRpb25zIiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJ0aW1lU2NhbGUiLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwicmlnaHRQcmljZVNjYWxlIiwidmlzaWJsZSIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsImF1dG9TY2FsZSIsIm1vZGUiLCJhbGlnbkxhYmVscyIsImJvcmRlclZpc2libGUiLCJlbnRpcmVUZXh0T25seSIsInRpY2tzVmlzaWJsZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJsb2NhbGl6YXRpb24iLCJwcmljZUZvcm1hdHRlciIsInByaWNlIiwiY2FuZGxlc3RpY2tTZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsInVwQ29sb3IiLCJkb3duQ29sb3IiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJsb2FkRGF0YSIsInVuc3Vic2NyaWJlIiwid2FybiIsImZvcm1hdHRlZFByaWNlIiwiaW50ZXJ2YWxTZWNvbmRzIiwiY2FuZGxlVGltZXN0YW1wIiwiZmxvb3IiLCJuZXdDYW5kbGUiLCJvcGVuIiwidXBkYXRlIiwidXBkYXRlZENhbmRsZSIsInVwZGF0ZWRTdGF0c0RhdGEiLCJsYXN0Q2FuZGxlIiwic2hpZnQiLCJoYW5kbGVSZXNpemUiLCJhcHBseU9wdGlvbnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsInNldE1hcmtlcnMiLCJjYWxjdWxhdGVJbmRpY2F0b3IiLCJwZXJpb2QiLCJkaXYiLCJjbGFzc05hbWUiLCJvbkV4Y2hhbmdlQ2hhbmdlIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Chart/CandlestickChart.tsx\n"));

/***/ })

});